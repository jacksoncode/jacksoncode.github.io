# 05_10_su命令详解

## 1. 命令概述

`su`（switch user）命令是Linux系统中用于切换当前用户身份的重要工具，允许用户在不退出当前会话的情况下切换到其他用户账户（包括root超级用户）。通过`su`命令，系统管理员可以快速切换到普通用户进行测试，普通用户也可以在获得权限的情况下临时切换到其他用户身份执行特定操作。

`su`命令的主要功能和应用场景包括：
- 系统管理员切换到普通用户账户进行操作测试
- 普通用户在获得授权后临时切换到root用户执行管理任务
- 在多用户环境中，用户可以切换到其他用户账户进行协作
- 以特定用户身份运行单个命令，而不切换整个会话

## 2. 语法格式

`su`命令的基本语法格式如下：

```bash
su [选项] [用户名]
```

或用于执行单个命令：

```bash
su [选项] - [用户名] -c '命令'
```

其中，方括号`[]`表示可选参数。当不指定用户名时，默认切换到root用户。

## 3. 常用选项说明

`su`命令提供了多种选项，用于控制切换用户的行为和环境设置。以下是一些最常用的选项：

| 选项 | 英文全称 | 说明 |
|------|----------|------|
| `-` | `--login` | 模拟完整的用户登录过程，包括加载目标用户的环境变量和工作目录 |
| `-c COMMAND` | `--command=COMMAND` | 以目标用户身份执行指定的命令，然后返回当前用户身份 |
| `-l` | `--login` | 同`-`选项，模拟完整的用户登录 |
| `-m` | `--preserve-environment` | 保留当前用户的环境变量，不切换到目标用户的环境 |
| `-p` | `--preserve-environment` | 同`-m`选项，保留当前用户的环境变量 |
| `-s SHELL` | `--shell=SHELL` | 指定要使用的shell，而不是目标用户默认的shell |
| `-h` | `--help` | 显示帮助信息 |
| `-V` | `--version` | 显示版本信息 |

## 4. 基本用法示例

### 4.1 切换到root用户

最常见的`su`命令用法是切换到root用户，以执行需要管理员权限的操作：

```bash
# 基本用法，切换到root用户
su

# 输入root用户密码后，将切换到root用户
# 提示符通常会从$变为#，表示当前为root用户

# 验证当前用户
whoami
# 输出: root

# 退出root用户，返回原用户
exit
```

### 4.2 切换到指定用户

除了切换到root用户外，`su`命令还可以用于切换到系统中的其他用户账户：

```bash
# 切换到user1用户
su user1

# 输入user1用户的密码后，将切换到user1用户

# 验证当前用户
whoami
# 输出: user1

# 退出user1用户，返回原用户
exit
```

### 4.3 模拟完整用户登录

使用`-`或`-l`选项可以模拟完整的用户登录过程，包括加载目标用户的环境变量和工作目录：

```bash
# 模拟完整登录到root用户
su -
# 或
su -l

# 验证环境变量是否已加载
env | grep HOME
# 输出: HOME=/root

# 验证当前工作目录
pwd
# 输出: /root

# 退出root用户，返回原用户
exit
```

```bash
# 模拟完整登录到user1用户
su - user1

# 验证环境变量是否已加载
env | grep HOME
# 输出: HOME=/home/user1

# 验证当前工作目录
pwd
# 输出: /home/user1

# 退出user1用户，返回原用户
exit
```

### 4.4 以其他用户身份执行单个命令

使用`-c`选项可以以目标用户身份执行单个命令，而不需要完全切换用户会话：

```bash
# 以root用户身份执行ls命令，查看/root目录内容
su -c 'ls -la /root'

# 以user1用户身份执行whoami命令，验证用户身份
su user1 -c 'whoami'
# 输出: user1

# 以root用户身份创建一个目录
su -c 'mkdir /data/shared'

# 以root用户身份查看系统负载
su -c 'uptime'
```

### 4.5 保留当前用户环境变量

使用`-m`或`-p`选项可以在切换用户时保留当前用户的环境变量：

```bash
# 设置一个环境变量
export TEST_VAR="This is a test variable"

# 切换到root用户但保留当前环境变量
su -m
# 或
su -p

# 验证环境变量是否保留
echo $TEST_VAR
# 输出: This is a test variable

# 退出root用户，返回原用户
exit
```

### 4.6 指定shell

使用`-s`选项可以指定要使用的shell，而不是目标用户默认的shell：

```bash
# 切换到root用户并使用/bin/sh shell
su -s /bin/sh

# 验证当前使用的shell
 echo $SHELL
# 输出: /bin/sh

# 退出root用户，返回原用户
exit
```

## 5. 高级用法与技巧

### 5.1 交互式shell脚本中的用户切换

在shell脚本中，有时需要以不同用户身份执行特定命令。以下是一个示例脚本，演示如何在脚本中安全地切换用户并执行命令：

```bash
#!/bin/bash

# 交互式shell脚本中的用户切换示例

# 检查当前用户是否为root
if [ "$(id -u)" -ne 0 ]; then
    echo "错误：此脚本需要以root用户身份运行！"
    exit 1
fi

# 定义目标用户
TARGET_USER="user1"

# 检查目标用户是否存在
if ! id -u "$TARGET_USER" > /dev/null 2>&1; then
    echo "错误：用户 $TARGET_USER 不存在！"
    exit 1
fi

# 显示菜单
cat << EOF
用户切换菜单
-----------
1. 以 $TARGET_USER 身份执行单个命令
2. 切换到 $TARGET_USER 交互式会话
3. 以 $TARGET_USER 身份运行指定脚本
4. 退出
EOF

# 获取用户选择
read -p "请输入选择 [1-4]: " CHOICE

case "$CHOICE" in
    1)
        read -p "请输入要执行的命令: " COMMAND
        echo "以 $TARGET_USER 身份执行命令: $COMMAND"
        su - "$TARGET_USER" -c "$COMMAND"
        ;;
    2)
        echo "切换到 $TARGET_USER 交互式会话..."
        echo "注意：退出会话后将返回此脚本"
        su - "$TARGET_USER"
        echo "已返回脚本"
        ;;
    3)
        read -p "请输入要运行的脚本路径: " SCRIPT_PATH
        if [ ! -f "$SCRIPT_PATH" ]; then
            echo "错误：脚本文件 $SCRIPT_PATH 不存在！"
            exit 1
        fi
        if [ ! -x "$SCRIPT_PATH" ]; then
            echo "警告：脚本文件 $SCRIPT_PATH 没有执行权限，正在添加..."
            chmod +x "$SCRIPT_PATH"
        fi
        echo "以 $TARGET_USER 身份运行脚本: $SCRIPT_PATH"
        su - "$TARGET_USER" -c "$SCRIPT_PATH"
        ;;
    4)
        echo "退出脚本"
        exit 0
        ;;
    *)
        echo "错误：无效的选择！"
        exit 1
        ;;

esac

# 脚本结束
echo "脚本执行完毕"
```

保存脚本为`user_switch_menu.sh`，然后运行：
```bash
chmod +x user_switch_menu.sh
sudo ./user_switch_menu.sh
```

### 5.2 密码验证绕过配置

在某些情况下（如自动化脚本），可能需要配置特定用户在切换到其他用户时不需要输入密码。这可以通过修改`/etc/sudoers`文件或设置组权限来实现。以下是一个示例，允许特定用户组的成员无需密码即可切换到root用户：

**注意**：此操作可能带来安全风险，请谨慎配置并仅在必要时使用。

```bash
# 使用visudo编辑sudoers文件（这是推荐的安全方式）
sudo visudo

# 添加以下行，允许admin组的成员无需密码执行su命令
%admin ALL=(ALL) NOPASSWD: /bin/su

# 保存并退出编辑器

# 将用户添加到admin组
sudo usermod -aG admin user1

# 验证配置是否生效（切换到user1用户后执行）
 su - user1
 sudo su -
# 应该无需输入密码即可切换到root用户
```

### 5.3 多用户环境下的安全su使用策略

在多用户环境中，合理规划和使用`su`命令对于系统安全至关重要。以下是一个用于监控和限制`su`命令使用的脚本示例：

```bash
#!/bin/bash

# 多用户环境下的安全su使用策略脚本

# 配置文件路径
CONFIG_FILE="/etc/su_security.conf"
LOG_FILE="/var/log/su_security.log"

# 检查是否以root用户运行
if [ "$(id -u)" -ne 0 ]; then
    echo "错误：此脚本需要以root用户身份运行！"
    exit 1
fi

# 创建配置文件（如果不存在）
if [ ! -f "$CONFIG_FILE" ]; then
    cat > "$CONFIG_FILE" << EOF
# su命令安全配置文件

# 允许su到root的用户列表（空格分隔）
ALLOWED_USERS="admin user1"

# 允许su的目标用户列表（空格分隔）
ALLOWED_TARGETS="root user2"

# 启用日志记录（yes/no）
ENABLE_LOGGING="yes"

# 启用失败尝试限制（yes/no）
ENABLE_LIMIT="yes"

# 最大失败尝试次数
MAX_ATTEMPTS=3

# 失败尝试锁定时间（分钟）
LOCK_TIME=30

# 启用通知（yes/no）
ENABLE_NOTIFICATION="yes"

# 通知邮箱
NOTIFICATION_EMAIL="admin@example.com"
EOF
    echo "配置文件已创建：$CONFIG_FILE"
    echo "请编辑配置文件以自定义安全策略，然后重新运行脚本"
    exit 0
fi

# 加载配置文件
source "$CONFIG_FILE"

# 创建日志文件（如果不存在）
if [ ! -f "$LOG_FILE" ]; then
    touch "$LOG_FILE"
    chmod 600 "$LOG_FILE"
    echo "$(date) - 安全日志已创建"
fi

# 记录日志函数
log_event() {
    if [ "$ENABLE_LOGGING" = "yes" ]; then
        echo "$(date) - $1" >> "$LOG_FILE"
    fi
}

# 发送通知函数
send_notification() {
    if [ "$ENABLE_NOTIFICATION" = "yes" ]; then
        echo -e "Subject: SU 安全警报\n\n$1" | sendmail -t "$NOTIFICATION_EMAIL"
    fi
}

# 检查用户是否被允许su
export SU_SECURITY_SCRIPT="$0"
su_wrapper() {
    local SOURCE_USER="$1"
    local TARGET_USER="$2"
    local RESULT="$3"
    
    # 记录su尝试
    log_event "用户 $SOURCE_USER 尝试su到 $TARGET_USER: $RESULT"
    
    # 检查是否被允许
    if [[ ! " $ALLOWED_USERS " =~ " $SOURCE_USER " ]] || [[ ! " $ALLOWED_TARGETS " =~ " $TARGET_USER " ]]; then
        if [ "$RESULT" = "success" ]; then
            log_event "警告：未授权的su尝试成功！用户 $SOURCE_USER 成功su到 $TARGET_USER"
            send_notification "警告：未授权的su尝试成功！\n\n用户 $SOURCE_USER 成功su到 $TARGET_USER\n时间: $(date)\n主机: $(hostname)"
        fi
    fi
    
    # 失败尝试限制
    if [ "$ENABLE_LIMIT" = "yes" ]; then
        if [ "$RESULT" = "failure" ]; then
            local FAIL_COUNT=$(grep "用户 $SOURCE_USER 尝试su到.*: failure" "$LOG_FILE" | tail -n 5 | wc -l)
            if [ "$FAIL_COUNT" -ge "$MAX_ATTEMPTS" ]; then
                log_event "安全限制：用户 $SOURCE_USER 已达到最大失败尝试次数，临时锁定 $LOCK_TIME 分钟"
                send_notification "安全限制：用户已锁定\n\n用户 $SOURCE_USER 已达到最大失败尝试次数 ($MAX_ATTEMPTS)\n临时锁定 $LOCK_TIME 分钟\n时间: $(date)\n主机: $(hostname)"
                # 这里可以添加实际的锁定机制，如使用pam_faillock等
            fi
        fi
    fi
}

# 安装su命令包装器
if ! grep -q "SU_SECURITY_SCRIPT" /etc/profile.d/su_security.sh 2>/dev/null; then
    cat > /etc/profile.d/su_security.sh << 'EOF'
# su命令安全包装器
if [ -n "$SU_SECURITY_SCRIPT" ]; then
    su() {
        local SOURCE_USER="$(whoami)"
        local TARGET_USER="$1"
        if [ -z "$TARGET_USER" ]; then
            TARGET_USER="root"
        fi
        
        # 调用原始的su命令
        command su "$@"
        local RESULT=$?
        
        # 记录结果
        if [ "$RESULT" -eq 0 ]; then
            # 这里无法捕获成功的su，因为su会创建新会话
            # 成功的su需要在新会话中记录
            echo "$SU_SECURITY_SCRIPT" "$SOURCE_USER" "$TARGET_USER" "success" | at now
        else
            "$SU_SECURITY_SCRIPT" "$SOURCE_USER" "$TARGET_USER" "failure"
        fi
        
        return $RESULT
    }
fi
EOF
    chmod +x /etc/profile.d/su_security.sh
    echo "su命令安全包装器已安装"
    echo "请注销并重新登录以使配置生效"
else
    echo "su命令安全包装器已存在"
fi

# 显示当前配置
echo "\n当前su安全配置："
echo "------------------"
grep -v '^#' "$CONFIG_FILE" | grep -v '^$'

echo "\n安全策略已应用，请确保定期检查日志文件：$LOG_FILE"
```

保存脚本为`su_security_setup.sh`，然后运行：
```bash
chmod +x su_security_setup.sh
sudo ./su_security_setup.sh
```

### 5.4 su命令与sudo命令的结合使用

在某些情况下，结合使用`su`和`sudo`命令可以提供更灵活的权限管理。以下是一个示例脚本，演示如何结合使用这两个命令来实现复杂的权限控制：

```bash
#!/bin/bash

# su命令与sudo命令的结合使用示例

# 定义函数：以特定用户身份执行命令
run_as_user() {
    local USERNAME="$1"
    local COMMAND="$2"
    
    echo "以用户 $USERNAME 身份执行命令：$COMMAND"
    
    # 首先检查当前用户是否为root
    if [ "$(id -u)" -eq 0 ]; then
        # 如果是root用户，直接使用su切换
        su - "$USERNAME" -c "$COMMAND"
    else
        # 如果不是root用户，使用sudo提升权限后再su切换
        echo "需要提升权限以切换到 $USERNAME 用户"
        sudo su - "$USERNAME" -c "$COMMAND"
    fi
}

# 定义函数：以root身份执行命令
un_as_root() {
    local COMMAND="$1"
    
    echo "以root身份执行命令：$COMMAND"
    
    # 检查当前用户是否为root
    if [ "$(id -u)" -eq 0 ]; then
        # 如果是root用户，直接执行命令
        eval "$COMMAND"
    else
        # 如果不是root用户，使用sudo提升权限
        sudo bash -c "$COMMAND"
    fi
}

# 示例：管理Web服务器
manage_web_server() {
    echo "\n--- Web服务器管理菜单 ---"
    echo "1. 查看Apache日志（www-data用户）"
    echo "2. 重启Apache服务（root用户）"
    echo "3. 部署网站内容（www-data用户）"
    echo "4. 返回主菜单"
    
    read -p "请选择操作 [1-4]: " CHOICE
    
    case "$CHOICE" in
        1)
            run_as_user "www-data" "tail -f /var/log/apache2/access.log"
            ;;
        2)
            run_as_root "/etc/init.d/apache2 restart"
            ;;
        3)
            read -p "请输入网站文件路径: " WEB_PATH
            if [ -d "$WEB_PATH" ]; then
                run_as_root "chown -R www-data:www-data $WEB_PATH"
                run_as_root "chmod -R 755 $WEB_PATH"
                echo "网站内容已部署，并设置了正确的所有权"
            else
                echo "错误：路径 $WEB_PATH 不存在！"
            fi
            ;;
        4)
            return
            ;;
        *)
            echo "无效的选择！"
            ;;
    esac
}

# 示例：管理数据库服务器
manage_database() {
    echo "\n--- 数据库服务器管理菜单 ---"
    echo "1. 查看MySQL日志（mysql用户）"
    echo "2. 重启MySQL服务（root用户）"
    echo "3. 备份数据库（mysql用户）"
    echo "4. 返回主菜单"
    
    read -p "请选择操作 [1-4]: " CHOICE
    
    case "$CHOICE" in
        1)
            run_as_user "mysql" "tail -f /var/log/mysql/error.log"
            ;;
        2)
            run_as_root "/etc/init.d/mysql restart"
            ;;
        3)
            read -p "请输入要备份的数据库名: " DB_NAME
            read -p "请输入备份文件路径: " BACKUP_PATH
            run_as_user "mysql" "mysqldump -u root -p $DB_NAME > $BACKUP_PATH"
            echo "数据库备份已完成"
            ;;
        4)
            return
            ;;
        *)
            echo "无效的选择！"
            ;;
    esac
}

# 主菜单
while true; do
    echo "\n--- 权限管理主菜单 ---"
    echo "1. 管理Web服务器"
    echo "2. 管理数据库服务器"
    echo "3. 以特定用户身份执行自定义命令"
    echo "4. 退出"
    
    read -p "请选择操作 [1-4]: " MAIN_CHOICE
    
    case "$MAIN_CHOICE" in
        1)
            manage_web_server
            ;;
        2)
            manage_database
            ;;
        3)
            read -p "请输入目标用户名: " TARGET_USER
            read -p "请输入要执行的命令: " CUSTOM_COMMAND
            run_as_user "$TARGET_USER" "$CUSTOM_COMMAND"
            ;;
        4)
            echo "退出程序"
            exit 0
            ;;
        *)
            echo "无效的选择！"
            ;;
    esac
done
```

保存脚本为`permission_manager.sh`，然后运行：
```bash
chmod +x permission_manager.sh
./permission_manager.sh
```

### 5.5 自动登录脚本

在某些特殊情况下（如测试环境或自动化服务器），可能需要实现自动登录功能。以下是一个示例脚本，演示如何在受控环境中实现自动su登录：

**注意**：此脚本涉及密码存储，可能带来严重的安全风险。请仅在安全的受控环境中使用，并确保适当保护包含此脚本的文件。

```bash
#!/bin/bash

# 自动登录脚本（仅在受控环境中使用）

# 配置文件路径（请确保此文件权限为600，仅root可访问）
CONFIG_FILE="/etc/auto_su.conf"

# 检查是否以root用户运行
if [ "$(id -u)" -ne 0 ]; then
    echo "错误：此脚本需要以root用户身份运行！"
    exit 1
fi

# 创建配置文件（如果不存在）
if [ ! -f "$CONFIG_FILE" ]; then
    # 设置严格的文件权限
    umask 077
    
    cat > "$CONFIG_FILE" << EOF
# 自动su登录配置文件
# 格式：目标用户名:密码
# 请确保此文件权限为600

root:secure_password_here
user1:user1_password_here
user2:user2_password_here
EOF
    
    # 设置文件权限为600
    chmod 600 "$CONFIG_FILE"
    
    echo "配置文件已创建：$CONFIG_FILE"
    echo "请编辑配置文件添加用户密码，然后重新运行脚本"
    echo "警告：请确保此文件的权限为600，防止未授权访问！"
    exit 0
fi

# 检查配置文件权限
PERMISSIONS=$(stat -c "%a" "$CONFIG_FILE")
if [ "$PERMISSIONS" != "600" ]; then
    echo "警告：配置文件权限不安全！当前权限为 $PERMISSIONS，建议设置为600"
    read -p "是否立即修复权限？(y/n): " FIX_PERM
    if [ "$FIX_PERM" = "y" ] || [ "$FIX_PERM" = "Y" ]; then
        chmod 600 "$CONFIG_FILE"
        echo "权限已修复"
    fi
fi

# 显示可用用户
echo "\n可用的自动登录用户："
awk -F: '{print NR ". " $1}' "$CONFIG_FILE"

# 获取用户选择
read -p "请选择要自动登录的用户编号: " USER_CHOICE

# 验证选择是否有效
USER_COUNT=$(wc -l < "$CONFIG_FILE")
if ! [[ "$USER_CHOICE" =~ ^[0-9]+$ ]] || [ "$USER_CHOICE" -lt 1 ] || [ "$USER_CHOICE" -gt "$USER_COUNT" ]; then
    echo "错误：无效的用户选择！"
    exit 1
fi

# 获取目标用户名和密码
TARGET_USER=$(awk -F: -v idx="$USER_CHOICE" 'NR==idx {print $1}' "$CONFIG_FILE")
PASSWORD=$(awk -F: -v idx="$USER_CHOICE" 'NR==idx {print $2}' "$CONFIG_FILE")

# 显示警告信息
echo "\n警告：自动登录功能可能带来严重的安全风险！"
echo "仅在受控环境中使用此功能。"
read -p "确认继续？(y/n): " CONFIRM

if [ "$CONFIRM" != "y" ] && [ "$CONFIRM" != "Y" ]; then
    echo "已取消操作"
    exit 0
fi

# 执行自动su登录
# 使用expect工具实现自动输入密码
echo "正在自动登录到 $TARGET_USER 用户..."

expect -c "
    spawn su - $TARGET_USER
    expect \"Password: \"
    send \"$PASSWORD\n\"
    interact
" 2>/dev/null

# 检查是否登录成功
if [ $? -ne 0 ]; then
    echo "自动登录失败，请检查用户名和密码是否正确"
    exit 1
fi

# 脚本结束
echo "已退出自动登录会话"
```

保存脚本为`auto_su_login.sh`，然后运行：
```bash
# 安装expect工具（如果尚未安装）
sudo apt-get install expect  # Debian/Ubuntu
sudo yum install expect      # CentOS/RHEL

sudo chmod +x auto_su_login.sh
sudo ./auto_su_login.sh
```

## 6. 实用技巧与应用场景

### 6.1 系统维护与故障排查

在系统维护和故障排查过程中，`su`命令是一个强大的工具，可以帮助管理员快速切换到不同用户身份进行测试和诊断。以下是一些实用技巧：

1. **以普通用户身份测试服务访问权限**

```bash
# 以普通用户身份测试Web服务访问
su - user1 -c 'curl http://localhost:8080'

# 以普通用户身份测试数据库连接
su - user1 -c 'mysql -u test_user -p -h localhost test_db -e "SELECT 1;"'

# 以普通用户身份检查文件访问权限
su - user1 -c 'ls -la /var/shared'
```

2. **模拟用户环境进行应用程序测试**

```bash
# 以应用程序用户身份运行程序
su - app_user -c '/opt/application/bin/start.sh'

# 查看应用程序日志
su - app_user -c 'tail -f /var/log/application.log'

# 检查应用程序进程
su - app_user -c 'ps -ef | grep application'
```

3. **排查权限相关问题**

```bash
# 以不同用户身份测试命令执行，排查权限问题
for USER in user1 user2 user3; do
    echo "\n测试用户: $USER"
    su - $USER -c 'id && ls -la /path/to/problematic/directory'
    echo "退出代码: $?"
done
```

### 6.2 多用户环境下的协作工作

在多用户环境中，`su`命令可以帮助用户之间进行协作工作，特别是在需要共享文件和资源的情况下。以下是一些实用场景：

1. **文件所有权临时切换**

```bash
# 创建一个需要多个用户访问的项目目录
sudo mkdir -p /var/projects/shared_project
sudo chown -R project_lead:project_team /var/projects/shared_project
sudo chmod -R 770 /var/projects/shared_project

# 以项目负责人身份管理项目文件
su - project_lead
cd /var/projects/shared_project
# 进行项目管理操作
exit

# 以团队成员身份访问项目文件
su - team_member
cd /var/projects/shared_project
# 进行团队协作操作
exit
```

2. **跨用户调试与问题解决**

```bash
# 系统管理员帮助用户解决问题
# 首先以用户身份重现问题
su - user1
# 用户重现问题的操作
exit

# 然后以root身份进行诊断和修复
su -
# 进行系统诊断和修复
exit
```

3. **临时切换到特定角色执行任务**

```bash
# 定义一些常用角色的快捷切换命令
echo "alias su-admin='su - admin'" >> ~/.bashrc
echo "alias su-developer='su - developer'" >> ~/.bashrc
echo "alias su-analyst='su - analyst'" >> ~/.bashrc
source ~/.bashrc

# 现在可以使用快捷命令快速切换角色
su-admin
# 执行管理员任务
exit

su-developer
# 执行开发任务
exit
```

### 6.3 自动化脚本中的用户切换

在自动化脚本中，`su`命令可以帮助实现以不同用户身份执行特定任务的需求。以下是一些实用技巧：

1. **在脚本中安全地切换用户**

```bash
#!/bin/bash

# 一个在脚本中安全切换用户的示例

# 定义日志函数
log() {
    echo "[$(date)] $1" >> /var/log/automation.log
}

# 检查root权限
if [ "$(id -u)" -ne 0 ]; then
    log "错误：脚本需要以root用户身份运行"
    echo "错误：脚本需要以root用户身份运行" >&2
    exit 1
fi

# 以web用户身份部署网站
deploy_website() {
    log "开始部署网站"
    su - webuser -c 'cd /var/www/html && git pull origin master && chmod -R 755 .'
    if [ $? -eq 0 ]; then
        log "网站部署成功"
    else
        log "错误：网站部署失败"
        return 1
    fi
    return 0
}

# 以db用户身份备份数据库
backup_database() {
    log "开始备份数据库"
    su - dbuser -c 'mkdir -p /backup/db && mysqldump -u dbuser -pPassword123! mydatabase > /backup/db/$(date +%Y%m%d_%H%M%S).sql'
    if [ $? -eq 0 ]; then
        log "数据库备份成功"
    else
        log "错误：数据库备份失败"
        return 1
    fi
    return 0
}

# 以root用户身份重启服务
restart_services() {
    log "开始重启服务"
    systemctl restart apache2
    systemctl restart mysql
    if [ $? -eq 0 ]; then
        log "服务重启成功"
    else
        log "错误：服务重启失败"
        return 1
    fi
    return 0
}

# 主流程
log "自动化任务开始执行"

# 执行网站部署
deploy_website
if [ $? -ne 0 ]; then
    log "任务失败：网站部署过程出错"
    exit 1
fi

# 执行数据库备份
backup_database
if [ $? -ne 0 ]; then
    log "任务警告：数据库备份过程出错，但继续执行"
fi

# 重启服务
restart_services
if [ $? -ne 0 ]; then
    log "任务失败：服务重启过程出错"
    exit 1
fi

log "自动化任务执行完成"
exit 0
```

2. **在cron任务中使用su**

```bash
# 在root的crontab中添加任务，以不同用户身份执行
# 每天凌晨2点以webuser身份备份网站数据
0 2 * * * su - webuser -c '/usr/local/bin/backup_website.sh'

# 每天凌晨3点以dbuser身份备份数据库
0 3 * * * su - dbuser -c '/usr/local/bin/backup_database.sh'

# 每周日凌晨4点以adminuser身份执行系统维护
0 4 * * 0 su - adminuser -c '/usr/local/bin/system_maintenance.sh'