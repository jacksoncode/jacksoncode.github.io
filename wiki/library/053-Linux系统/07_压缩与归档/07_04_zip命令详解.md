# 7.4 zip命令详解

## 1. 命令概述

zip是一种广泛使用的压缩工具，用于创建和管理ZIP格式的压缩文件。与gzip不同，zip不仅可以压缩单个文件，还可以将多个文件和目录压缩成一个归档文件，同时保留文件结构和属性。zip命令支持多种压缩算法和选项，是跨平台文件传输和备份的理想选择。

### 1.1 功能特点
- 创建ZIP格式的压缩文件
- 支持压缩多个文件和目录，保留目录结构
- 提供多种压缩级别，平衡压缩率和速度
- 支持文件加密和密码保护
- 可以向已有的ZIP文件添加新文件
- 支持跨平台（Windows、Linux、macOS等）

### 1.2 应用场景
- 创建软件分发包
- 备份重要文件和目录
- 减少文件大小以节省存储空间
- 跨平台传输多个文件
- 创建自解压归档
- 对敏感数据进行加密保护

## 2. 语法格式

zip命令的基本语法格式如下：

```bash
# 基本语法
$ zip [选项] [压缩文件名] [要压缩的文件或目录...]
```

### 2.1 语法说明
- **zip**：命令名称，用于创建和管理ZIP格式压缩文件
- **选项**：控制命令行为的参数（可选）
- **压缩文件名**：要创建的ZIP文件的名称
- **要压缩的文件或目录**：需要添加到ZIP文件中的文件和目录列表

> **注意**：通常ZIP文件使用`.zip`作为扩展名，但这不是必需的。

## 3. 选项说明

zip命令提供了丰富的选项来控制压缩过程，以下是最常用的选项：

| 选项 | 简写 | 功能说明 |
|------|------|----------|
| `--recurse-paths` | `-r` | 递归地压缩目录及其内容 |
| `--quiet` | `-q` | 静默模式，不显示压缩过程信息 |
| `--verbose` | `-v` | 详细模式，显示压缩过程的详细信息 |
| `--compression-level <1-9>` | `-<1-9>` | 设置压缩级别（1最快，9压缩率最高） |
| `--encrypt` | `-e` | 创建加密的ZIP文件，需要输入密码 |
| `--password <密码>` | `-P <密码>` | 使用指定的密码加密文件（不推荐在命令行使用） |
| `--update` | `-u` | 只添加比ZIP文件中已存在的版本更新的文件，或添加新文件 |
| `--delete` | `-d` | 从ZIP文件中删除指定的文件 |
| `--move` | `-m` | 压缩文件后删除源文件 |
| `--split-size <大小>` | `-s <大小>` | 创建分卷压缩文件，大小可以是k、m、g等单位 |
| `--test` | `-T` | 测试ZIP文件的完整性 |
| `--list` | `-l` | 列出ZIP文件的内容但不解压 |
| `--exclude <模式>` | `-x <模式>` | 排除符合指定模式的文件 |
| `--include <模式>` | `-i <模式>` | 仅包含符合指定模式的文件 |
| `--junk-paths` | `-j` | 仅存储文件内容，不保留目录结构 |
| `--show-files` | `-f` | 更新ZIP文件，只添加修改时间晚于指定时间的文件 |
| `--no-dir-entries` | `-D` | 不创建目录条目，只存储文件 |
| `--symlinks` | `-y` | 保留符号链接，而不是跟随它们 |
| `--quiet` | `-q` | 静默模式，不显示任何信息 |
| `--help` | `-h` | 显示帮助信息 |

### 3.1 选项详细解释

- **`-r`**: 递归压缩，包含指定目录下的所有文件和子目录。在压缩目录时必须使用此选项。

- **`-<1-9>`**: 设置压缩级别，1表示最快压缩（最小压缩率），9表示最高压缩率（最慢）。默认级别通常是6。

- **`-e`**: 创建加密的ZIP文件。执行此命令后，系统会提示用户输入和确认密码。

- **`-P`**: 直接在命令行中指定加密密码。由于密码会出现在命令历史中，因此不推荐使用此选项。

- **`-u`**: 更新ZIP文件，只添加比ZIP文件中已存在的版本更新的文件，或添加新文件。

- **`-d`**: 从ZIP文件中删除指定的文件。

- **`-m`**: 压缩文件后删除源文件。这对于释放空间很有用，但请谨慎使用。

- **`-s`**: 创建分卷压缩文件，适用于需要将大文件分割成多个小文件的情况。大小参数可以使用k（KB）、m（MB）、g（GB）等单位。

- **`-T`**: 测试ZIP文件的完整性，确保文件可以被正确解压。

- **`-l`**: 列出ZIP文件的内容，但不执行解压操作。

- **`-x`**: 排除符合指定模式的文件。这对于排除临时文件或缓存文件非常有用。

- **`-i`**: 仅包含符合指定模式的文件。这对于选择性压缩非常有用。

- **`-j`**: 仅存储文件内容，不保留目录结构。所有文件都会被放置在ZIP文件的根目录下。

- **`-f`**: 更新ZIP文件，只添加修改时间晚于指定时间的文件。可以与日期参数一起使用。

- **`-D`**: 不创建目录条目，只存储文件。这与`-j`不同，`-D`会保留文件的相对路径，但不会创建空目录。

- **`-y`**: 保留符号链接，而不是跟随它们。这在备份系统文件时特别有用。

- **`-q`**: 静默模式，不显示压缩过程的任何信息。

- **`-v`**: 详细模式，显示压缩过程的详细信息，包括每个文件的压缩率等。

## 4. 基本用法示例

### 4.1 创建基本的ZIP文件

**示例1: 压缩单个文件**

```bash
# 压缩单个文件
touch example.txt
zip archive.zip example.txt
```

**示例2: 压缩多个文件**

```bash
# 压缩多个文件
touch file1.txt file2.txt file3.txt
zip archive.zip file1.txt file2.txt file3.txt
```

**示例3: 压缩目录及其内容**

```bash
# 递归压缩目录
mkdir -p mydir/subdir
touch mydir/file1.txt mydir/subdir/file2.txt
zip -r archive.zip mydir
```

### 4.2 设置压缩级别

**示例4: 使用最快压缩**

```bash
# 使用最快压缩（级别1）
zip -1 fast_compression.zip large_file.txt
```

**示例5: 使用最高压缩率**

```bash
# 使用最高压缩率（级别9）
zip -9 best_compression.zip document.txt
```

### 4.3 创建加密ZIP文件

**示例6: 创建密码保护的ZIP文件**

```bash
# 创建需要密码的加密ZIP文件
zip -e secure_archive.zip sensitive_data.txt
# 系统会提示输入和确认密码
```

**示例7: 在脚本中创建加密ZIP文件（不推荐在命令行直接使用）**

```bash
# 在自动化脚本中使用预设密码（注意安全风险）
zip -P secret_password -r backup.zip important_files/
```

### 4.4 更新和管理ZIP文件

**示例8: 向现有ZIP文件添加新文件**

```bash
# 向现有的ZIP文件添加新文件
zip -u archive.zip new_file.txt
```

**示例9: 从ZIP文件中删除文件**

```bash
# 从ZIP文件中删除特定文件
zip -d archive.zip obsolete_file.txt
```

**示例10: 压缩文件后删除源文件**

```bash
# 压缩文件后删除原始文件
zip -m archive.zip old_files/
```

### 4.5 查看和测试ZIP文件

**示例11: 列出ZIP文件内容**

```bash
# 查看ZIP文件中的内容，但不解压
zip -l archive.zip
```

**示例12: 测试ZIP文件完整性**

```bash
# 测试ZIP文件是否可以正常解压
zip -T archive.zip
```

### 4.6 选择性压缩

**示例13: 排除特定文件**

```bash
# 压缩目录但排除临时文件和备份文件
zip -r project.zip project_dir/ -x "*.tmp" "*.bak" "*/.git/*"
```

**示例14: 仅包含特定类型的文件**

```bash
# 仅压缩PDF和DOCX文件
zip -r documents.zip docs/ -i "*.pdf" "*.docx"
```

**示例15: 不保留目录结构**

```bash
# 压缩文件但不保留目录结构
zip -j flat_archive.zip docs/reports/*.pdf
```

## 5. 高级用法

### 5.1 创建分卷压缩文件

**示例16: 创建大小受限的分卷压缩文件**

```bash
# 创建每个分卷不超过100MB的压缩文件
zip -r -s 100m split_archive.zip large_directory/
# 生成的文件将是: split_archive.z01, split_archive.z02, ..., split_archive.zip
```

**示例17: 创建可用于电子邮件附件的分卷**

```bash
# 创建每个分卷不超过25MB的压缩文件（适合电子邮件附件）
zip -r -s 25m email_archive.zip documents/
```

### 5.2 定时备份和增量备份

**示例18: 创建每日增量备份**

```bash
# 创建每日增量备份脚本
#!/bin/bash
BACKUP_DIR="/data/backup"
SOURCE_DIR="/home/user/docs"
DATE="$(date +%Y%m%d)"

# 创建备份目录（如果不存在）
mkdir -p "$BACKUP_DIR"

# 创建增量备份（只添加今天修改的文件）
zip -r -u "$BACKUP_DIR/docs_backup_$DATE.zip" "$SOURCE_DIR" --include="*"

# 记录备份完成信息
echo "备份完成: docs_backup_$DATE.zip" >> "$BACKUP_DIR/backup_log.txt"
echo "完成时间: $(date)" >> "$BACKUP_DIR/backup_log.txt"
echo "----------------------" >> "$BACKUP_DIR/backup_log.txt"
```

**示例19: 自动备份并按日期归档**

```bash
# 自动备份系统并按日期归档
#!/bin/bash
BACKUP_ROOT="/backup"
SOURCE_DIRS="/etc /home /var/www"
EXCLUDE_PATTERNS="/proc/* /sys/* /dev/* /tmp/* /var/tmp/*"
DATE="$(date +%Y%m%d_%H%M%S)"
BACKUP_FILE="$BACKUP_ROOT/system_backup_$DATE.zip"

# 创建备份目录
mkdir -p "$BACKUP_ROOT"

# 构建排除选项字符串
exclude_opts=""
for pattern in $EXCLUDE_PATTERNS; do
    exclude_opts="$exclude_opts -x $pattern"
done

# 执行备份
zip -r -9 -q "$BACKUP_FILE" $SOURCE_DIRS $exclude_opts

# 验证备份
if zip -T "$BACKUP_FILE" >/dev/null 2>&1; then
    echo "系统备份成功: $BACKUP_FILE"
    # 可选：删除7天前的备份
    find "$BACKUP_ROOT" -name "system_backup_*.zip" -mtime +7 -delete
else
    echo "错误：系统备份失败!" >&2
    exit 1
fi
```

### 5.3 与其他命令结合使用

**示例20: 压缩并加密日志文件**

```bash
# 压缩并加密系统日志文件
#!/bin/bash
LOG_DIR="/var/log"
BACKUP_DIR="/var/backups/logs"
DATE="$(date +%Y%m%d)"

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 压缩并加密日志文件
cat /etc/zip_pass.txt | zip -e -P "$(cat /etc/zip_pass.txt)" -r "$BACKUP_DIR/logs_backup_$DATE.zip" "$LOG_DIR" --include="*.log" "*.gz"

# 清理：删除30天前的日志备份
find "$BACKUP_DIR" -name "logs_backup_*.zip" -mtime +30 -delete
```

**示例21: 使用find和xargs创建大型归档**

```bash
# 使用find和xargs高效创建大型归档
#!/bin/bash
# 此方法适合处理大量文件

TARGET_DIR="/data/files"
OUTPUT_FILE="/backup/large_archive.zip"
TEMP_LIST="/tmp/file_list.txt"

# 创建文件列表
find "$TARGET_DIR" -type f -name "*.dat" > "$TEMP_LIST"

# 使用xargs传递文件列表给zip
echo "开始创建大型归档..."
cat "$TEMP_LIST" | xargs zip -9 "$OUTPUT_FILE"

# 清理临时文件
rm -f "$TEMP_LIST"

# 验证归档
zip -T "$OUTPUT_FILE"
if [ $? -eq 0 ]; then
    echo "大型归档创建成功: $OUTPUT_FILE"
else
    echo "错误：大型归档创建失败!" >&2
    exit 1
fi
```

### 5.4 创建自解压归档

**示例22: 创建Linux自解压归档**

```bash
# 创建Linux下的自解压归档
#!/bin/bash
SOURCE_DIR="/path/to/application"
OUTPUT_FILE="installer.run"

# 1. 创建普通ZIP归档
zip -r "$OUTPUT_FILE.zip" "$SOURCE_DIR"

# 2. 创建自解压脚本头部
cat > self_extract_header.sh << 'EOF'
#!/bin/sh
# 自解压脚本头部
MYSELF="$0"
ARCHIVE=`awk '/^__ARCHIVE_BELOW__/ {print NR+1; exit 0;}' "$MYSELF"`

# 创建临时目录
TMPDIR=`mktemp -d`

# 解压归档到临时目录
tail -n+$ARCHIVE "$MYSELF" | unzip -q -d "$TMPDIR"

# 执行安装脚本（假设应用程序目录中包含install.sh）
cd "$TMPDIR"
./application/install.sh

# 清理临时目录
cd /
rm -rf "$TMPDIR"

# 退出
exit 0
__ARCHIVE_BELOW__
EOF

# 3. 合并脚本头部和ZIP归档
cat self_extract_header.sh "$OUTPUT_FILE.zip" > "$OUTPUT_FILE"

# 4. 设置执行权限
chmod +x "$OUTPUT_FILE"

# 5. 清理临时文件
rm -f self_extract_header.sh "$OUTPUT_FILE.zip"

# 完成提示
echo "自解压安装程序已创建: $OUTPUT_FILE"
echo "运行 ./$OUTPUT_FILE 开始安装"
```

**示例23: 创建跨平台的ZIP归档**

```bash
# 创建跨平台兼容的ZIP归档
#!/bin/bash
# 确保创建的ZIP文件在Windows和Linux上都能正确解压

SOURCE_DIR="/path/to/project"
OUTPUT_FILE="project_crossplatform.zip"

# 使用-D选项不创建空目录条目，使用-y保留符号链接（如果需要）
zip -r -D "$OUTPUT_FILE" "$SOURCE_DIR"

# 添加说明文件
cat > README.txt << 'EOF'
跨平台项目归档说明

在Windows上：
- 右键点击ZIP文件，选择"全部提取"

在Linux/Mac上：
- 使用命令：unzip $OUTPUT_FILE
EOF

# 将说明文件添加到ZIP归档
zip -u "$OUTPUT_FILE" README.txt

# 完成提示
echo "跨平台ZIP归档已创建: $OUTPUT_FILE"
rm -f README.txt
```

## 6. 实用技巧

### 6.1 系统管理中的应用

**技巧1: 自动备份系统配置文件**

```bash
#!/bin/bash
# 系统配置备份脚本
BACKUP_DIR="/root/backups/configs"
DATE="$(date +%Y%m%d)"
CONFIG_DIRS="/etc /usr/local/etc /root/.ssh"
EXCLUDE_FILES="*.swp *.bak *.tmp"

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 构建排除选项
EXCLUDE_OPTS=""
for file in $EXCLUDE_FILES; do
    EXCLUDE_OPTS="$EXCLUDE_OPTS -x $file"
done

# 备份配置文件
echo "开始备份系统配置文件..."
zip -r -9 -v "$BACKUP_DIR/config_backup_$DATE.zip" $CONFIG_DIRS $EXCLUDE_OPTS

# 验证备份
if zip -T "$BACKUP_DIR/config_backup_$DATE.zip" >/dev/null 2>&1; then
    echo "配置文件备份成功！"
    echo "备份文件: $BACKUP_DIR/config_backup_$DATE.zip"
    
    # 可选：将备份复制到远程服务器
    # scp "$BACKUP_DIR/config_backup_$DATE.zip" user@remote_server:/backup/
else
    echo "错误：配置文件备份失败！" >&2
    exit 1
fi
```

**技巧2: 批量处理和压缩日志文件**

```bash
#!/bin/bash
# 日志文件压缩和归档脚本
LOG_DIR="/var/log"
ARCHIVE_DIR="/var/archives/logs"
RETENTION_DAYS=30
DATE="$(date +%Y%m%d)"

# 创建归档目录
mkdir -p "$ARCHIVE_DIR"

# 压缩超过7天的日志文件
echo "开始压缩和归档过期日志文件..."
find "$LOG_DIR" -name "*.log" -type f -mtime +7 -print0 | xargs -0 -I {} zip -m -9 "$ARCHIVE_DIR/log_archive_$DATE.zip" "{}"

# 压缩gz格式的旧日志
find "$LOG_DIR" -name "*.gz" -type f -mtime +7 -print0 | xargs -0 -I {} zip -m -9 "$ARCHIVE_DIR/log_archive_$DATE.zip" "{}"

# 清理超过保留期的归档
find "$ARCHIVE_DIR" -name "log_archive_*.zip" -mtime +$RETENTION_DAYS -delete

# 显示结果
ARCHIVED_FILES=$(unzip -l "$ARCHIVE_DIR/log_archive_$DATE.zip" 2>/dev/null | grep -c "regular file")
if [ $ARCHIVED_FILES -gt 0 ]; then
    echo "日志归档完成！"
    echo "归档文件: $ARCHIVE_DIR/log_archive_$DATE.zip"
    echo "共归档 $ARCHIVED_FILES 个文件"
else
    echo "没有需要归档的日志文件"
    rm -f "$ARCHIVE_DIR/log_archive_$DATE.zip" 2>/dev/null
fi
```

### 6.2 软件开发与部署中的应用

**技巧3: 创建软件发布包**

```bash
#!/bin/bash
# 软件发布包创建脚本
PROJECT_DIR="/path/to/project"
VERSION="1.0.0"
OUTPUT_DIR="/path/to/releases"
BUILD_DIR="/tmp/build"

# 创建输出目录
mkdir -p "$OUTPUT_DIR"

# 清理并创建构建目录
rm -rf "$BUILD_DIR"
mkdir -p "$BUILD_DIR"

# 复制项目文件到构建目录
echo "准备构建文件..."
cp -r "$PROJECT_DIR/src" "$BUILD_DIR/"
cp -r "$PROJECT_DIR/docs" "$BUILD_DIR/"
cp "$PROJECT_DIR/README.md" "$BUILD_DIR/"
cp "$PROJECT_DIR/LICENSE" "$BUILD_DIR/"

# 创建版本信息文件
echo "VERSION=$VERSION" > "$BUILD_DIR/version.txt"
echo "BUILD_DATE=$(date)" >> "$BUILD_DIR/version.txt"

# 压缩发布包
echo "创建发布包..."
cd "$BUILD_DIR"
zip -r -9 "$OUTPUT_DIR/myapp_v$VERSION.zip" *

# 创建源码包（包含所有文件）
echo "创建源码包..."
cd "$PROJECT_DIR"
zip -r -9 "$OUTPUT_DIR/myapp_v$VERSION-src.zip" * -x "*.git/*" "*/node_modules/*" "$BUILD_DIR/*"

# 清理构建目录
rm -rf "$BUILD_DIR"

# 验证发布包
echo "验证发布包..."
if zip -T "$OUTPUT_DIR/myapp_v$VERSION.zip" && zip -T "$OUTPUT_DIR/myapp_v$VERSION-src.zip"; then
    echo "发布包创建成功！"
    echo "发布包: $OUTPUT_DIR/myapp_v$VERSION.zip"
    echo "源码包: $OUTPUT_DIR/myapp_v$VERSION-src.zip"
else
    echo "错误：发布包创建失败！" >&2
    exit 1
fi
```

**技巧4: 部署Web应用程序**

```bash
#!/bin/bash
# Web应用部署脚本
APP_NAME="mywebapp"
VERSION="2.3.1"
DEPLOY_DIR="/var/www/$APP_NAME"
BACKUP_DIR="/var/backups/webapps"
TEMP_DIR="/tmp/deploy"

# 创建必要目录
mkdir -p "$BACKUP_DIR" "$TEMP_DIR"

# 备份当前部署（如果存在）
if [ -d "$DEPLOY_DIR" ]; then
    echo "正在备份当前部署..."
    zip -r -9 "$BACKUP_DIR/${APP_NAME}_backup_$(date +%Y%m%d_%H%M%S).zip" "$DEPLOY_DIR"
    rm -rf "$DEPLOY_DIR"
mkdir -p "$DEPLOY_DIR"
fi

# 解压新应用程序
echo "正在部署新版本 $VERSION..."
if [ -f "$TEMP_DIR/${APP_NAME}_v$VERSION.zip" ]; then
    unzip -q "$TEMP_DIR/${APP_NAME}_v$VERSION.zip" -d "$DEPLOY_DIR"
else
    echo "错误：未找到应用程序包！" >&2
    exit 1
fi

# 设置权限
echo "设置文件权限..."
chown -R www-data:www-data "$DEPLOY_DIR"
chmod -R 755 "$DEPLOY_DIR/public"
chmod 644 "$DEPLOY_DIR/config/*.php"

# 重启Web服务器
echo "重启Web服务器..."
systemctl restart apache2

# 验证部署
sleep 5
if curl -s -o /dev/null -w "%{http_code}" http://localhost/$APP_NAME >/dev/null 2>&1; then
    echo "应用程序 $APP_NAME v$VERSION 部署成功！"
else
    echo "警告：部署完成，但应用程序可能无法正常访问，请检查日志。" >&2
fi
```

## 7. 常见问题与解决方案

### 7.1 压缩和解压错误

**问题1: 无法创建ZIP文件，提示"permission denied"**

**解决方案:**
- 检查是否有足够的权限写入目标目录
- 使用sudo或root权限执行命令
- 确保目标磁盘有足够的可用空间

```bash
# 使用sudo创建ZIP文件
sudo zip -r archive.zip protected_directory/

# 检查磁盘空间
df -h
```

**问题2: ZIP文件在Windows上解压时乱码**

**解决方案:**
- Linux和Windows使用不同的默认字符编码
- 使用`-UN=UTF8`选项创建UTF-8编码的ZIP文件

```bash
# 创建UTF-8编码的ZIP文件，在Windows上也能正确显示中文等非ASCII字符
zip -r -UN=UTF8 archive.zip directory_with_utf8_filenames/
```

**问题3: 压缩大型目录时内存不足**

**解决方案:**
- 使用分卷压缩
- 增加系统的交换空间
- 分批压缩大目录

```bash
# 使用分卷压缩处理大型目录
zip -r -s 500m large_archive.zip huge_directory/

# 或分批压缩
dirs=$(find huge_directory -maxdepth 1 -type d | grep -v "^huge_directory$")
for dir in $dirs; do
    zip -r "${dir##*/}.zip" "$dir"
done
```

### 7.2 性能优化

**问题4: 压缩大量小文件时速度慢**

**解决方案:**
- 使用更快的压缩级别
- 减少I/O操作，先将文件复制到临时目录再压缩
- 使用多线程压缩工具如pigz（如果系统支持）

```bash
# 使用最快压缩级别
gzip -1 archive.zip files/

# 或使用多线程工具（假设已安装）
pigz -r -1 archive.zip files/
```

**问题5: 压缩率不理想**

**解决方案:**
- 使用最高压缩级别
- 对于特定类型的文件，考虑使用专门的压缩工具
- 检查文件是否已经被压缩过（如图片、视频等）

```bash
# 使用最高压缩级别
zip -9 best_compression.zip documents/

# 检查文件类型，避免压缩已经压缩过的文件
file *
zip -r archive.zip --exclude="*.jpg" --exclude="*.png" --exclude="*.mp3" directory/
```

### 7.3 安全性问题

**问题6: 命令行中的密码可见**

**解决方案:**
- 避免使用`-P`选项，改为使用`-e`选项交互式输入密码
- 在脚本中使用安全的方式存储密码，如从文件读取

```bash
# 交互式输入密码
zip -e secure.zip sensitive_data/

# 从安全文件中读取密码（在脚本中使用）
# 确保/etc/zip_password文件的权限为600
zip_password=$(cat /etc/zip_password)
zip -e -P "$zip_password" secure.zip sensitive_data/
```

**问题7: ZIP文件密码安全性不足**

**解决方案:**
- 注意传统ZIP加密的安全性有限
- 对于敏感数据，考虑使用更安全的加密工具，如GPG
- 结合文件系统加密和访问控制

```bash
# 使用GPG创建更安全的加密归档
zip -r -0 temp.zip sensitive_data/
gpg -c --cipher-algo AES256 temp.zip
rm -f temp.zip
```

### 7.4 其他常见问题

**问题8: 无法更新或删除ZIP文件中的文件**

**解决方案:**
- 检查ZIP文件是否为只读
- 确保有足够的磁盘空间进行操作
- 对于损坏的ZIP文件，尝试修复或重建

```bash
# 检查并修改文件权限
chmod +w archive.zip

# 检查磁盘空间
df -h

# 尝试修复损坏的ZIP文件
zip -F archive.zip --out repaired.zip
```

**问题9: 符号链接在压缩后丢失或变为普通文件**

**解决方案:**
- 使用`-y`选项保留符号链接
- 注意Windows上不支持符号链接，跨平台压缩时需要考虑这点

```bash
# 保留符号链接
gzip -r -y archive.zip directory_with_symlinks/
```

## 8. 相关命令对比

下表比较了zip与其他常用压缩工具的特点和适用场景：

| 命令 | 功能描述 | 适用文件格式 | 优势 | 劣势 |
|------|----------|--------------|------|------|
| zip | 创建ZIP格式归档文件 | .zip | 跨平台兼容，支持目录和加密 | 压缩率一般，传统加密安全性有限 |
| tar | 创建归档文件，常与压缩工具配合 | .tar, .tar.gz, .tar.bz2, .tar.xz | 保留文件权限，支持增量备份 | 单独使用不压缩，需要配合其他工具 |
| gzip | 压缩单个文件 | .gz | 速度快，资源占用少 | 不支持目录和多文件压缩 |
| bzip2 | 更高压缩率的压缩工具 | .bz2 | 压缩率高于gzip | 压缩和解压速度较慢 |
| xz | 最高压缩率的主流压缩工具 | .xz | 最高压缩率 | 压缩和解压速度最慢，资源占用高 |
| 7z | 多功能压缩解压工具 | .7z及多种格式 | 极高压缩率，支持强加密 | 需要额外安装，命令较复杂 |

### 8.1 工具选择建议

- **对于跨平台文件传输**：使用`zip`命令创建ZIP格式文件
- **对于Linux系统备份**：使用`tar`结合`gzip`、`bzip2`或`xz`
- **对于需要最高压缩率的场景**：考虑使用`7z`或`xz`
- **对于需要加密保护的场景**：使用`zip -e`或更安全的`gpg`结合压缩工具
- **对于大量小文件**：先使用`tar`归档，再使用压缩工具
- **对于单个大文件**：直接使用`gzip`、`bzip2`或`xz`

## 9. 实践练习

### 9.1 基础练习

**练习1: 基本的文件和目录压缩**

1. 创建一个测试目录结构
2. 压缩单个文件
3. 压缩多个文件
4. 递归压缩整个目录
5. 查看压缩文件内容

**参考实现：**
```bash
# 创建测试目录结构
mkdir -p test_dir/subdir
touch test_dir/file1.txt test_dir/file2.txt test_dir/subdir/file3.txt

# 压缩单个文件
zip single.zip test_dir/file1.txt

# 压缩多个文件
zip multiple.zip test_dir/file1.txt test_dir/file2.txt

# 递归压缩整个目录
zip -r directory.zip test_dir/

# 查看压缩文件内容
zip -l directory.zip
```

**练习2: 创建加密和分卷压缩文件**

1. 创建一个包含敏感信息的测试文件
2. 创建加密的ZIP文件
3. 创建分卷压缩文件
4. 验证压缩文件的完整性

**参考实现：**
```bash
# 创建包含敏感信息的测试文件
echo "这是敏感信息" > sensitive.txt
for i in {1..10}; do
    echo "测试数据行 $i" >> large_file.txt
done

# 创建加密的ZIP文件
zip -e secure.zip sensitive.txt

# 创建分卷压缩文件
zip -s 100b split.zip large_file.txt

# 验证压缩文件的完整性
zip -T secure.zip
zip -T split.z01
```

### 9.2 进阶练习

**练习3: 实现系统配置自动备份**

1. 创建一个脚本，自动备份系统关键配置目录
2. 排除不必要的临时文件和缓存
3. 设置加密保护
4. 添加日志记录和验证功能

**参考实现：**
```bash
#!/bin/bash
# 系统配置自动备份脚本

# 配置参数
BACKUP_DIR="$HOME/system_backups"
CONFIG_DIRS="/etc /home/$USER/.config /etc/network /etc/fstab"
EXCLUDE_FILES="*.swp *.bak *.cache *.tmp /etc/ssh/ssh_host_*"
DATE="$(date +%Y%m%d_%H%M%S)"
BACKUP_FILE="$BACKUP_DIR/system_config_$DATE.zip"
LOG_FILE="$BACKUP_DIR/backup.log"
ENCRYPT=1  # 设置为0禁用加密

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 记录开始时间
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 开始系统配置备份..." >> "$LOG_FILE"

# 构建排除选项
exclude_opts=""
for file in $EXCLUDE_FILES; do
    exclude_opts="$exclude_opts -x $file"
done

# 执行备份
if [ $ENCRYPT -eq 1 ]; then
    echo "创建加密备份..." >> "$LOG_FILE"
    zip_cmd="zip -r -9 -e $exclude_opts \"$BACKUP_FILE\" $CONFIG_DIRS"
else
    echo "创建非加密备份..." >> "$LOG_FILE"
    zip_cmd="zip -r -9 $exclude_opts \"$BACKUP_FILE\" $CONFIG_DIRS"
fi

# 执行备份命令
eval $zip_cmd

# 检查备份是否成功
if [ $? -eq 0 ]; then
    # 验证备份完整性
    if zip -T "$BACKUP_FILE" >/dev/null 2>&1; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] 备份成功: $BACKUP_FILE" >> "$LOG_FILE"
        echo "备份文件大小: $(du -h "$BACKUP_FILE" | cut -f1)" >> "$LOG_FILE"
        echo "备份完成！" >&2
    else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] 备份文件验证失败: $BACKUP_FILE" >> "$LOG_FILE"
        echo "错误：备份文件损坏！" >&2
        exit 1
    fi
else
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] 备份失败" >> "$LOG_FILE"
    echo "错误：备份过程中出现问题！" >&2
    exit 1
fi

# 清理超过30天的旧备份
find "$BACKUP_DIR" -name "system_config_*.zip" -mtime +30 -delete

# 记录完成时间
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 备份过程完成" >> "$LOG_FILE"
echo "----------------------" >> "$LOG_FILE"

# 显示备份信息
echo "系统配置备份信息："
echo "- 备份文件: $BACKUP_FILE"
echo "- 备份内容: $CONFIG_DIRS"
echo "- 日志文件: $LOG_FILE"
```

**练习4: 批量处理和优化图片文件**

1. 编写一个脚本，批量压缩目录中的图片文件
2. 根据图片类型选择适当的压缩级别
3. 创建Web优化版本和原始版本的归档
4. 生成压缩统计报告

**参考实现：**
```bash
#!/bin/bash
# 图片批量压缩和归档脚本

# 配置参数
SOURCE_DIR="$HOME/Pictures"
OUTPUT_DIR="$HOME/Optimized_Pictures"
BACKUP_DIR="$HOME/Picture_Backups"
DATE="$(date +%Y%m%d)"
WEBP_QUALITY=85  # WebP压缩质量
JPEG_QUALITY=80  # JPEG压缩质量

# 创建必要目录
mkdir -p "$OUTPUT_DIR" "$BACKUP_DIR"

# 创建原始图片备份
echo "正在备份原始图片..."
zip -r -9 "$BACKUP_DIR/original_pictures_$DATE.zip" "$SOURCE_DIR" -x "*.zip" "*.tar.gz"

# 优化并归档JPEG图片
echo "正在优化JPEG图片..."
find "$SOURCE_DIR" -name "*.jpg" -o -name "*.jpeg" | while read -r img; do
    img_name=$(basename "$img")
    # 复制原始图片到输出目录
    cp "$img" "$OUTPUT_DIR/$img_name"
    # 优化图片（需要安装jpegoptim）
    jpegoptim --max=$JPEG_QUALITY --strip-all "$OUTPUT_DIR/$img_name" 2>/dev/null
    # 转换为WebP格式（需要安装cwebp）
    cwebp -q $WEBP_QUALITY "$img" -o "$OUTPUT_DIR/${img_name%.*}.webp" 2>/dev/null
done

# 优化并归档PNG图片
echo "正在优化PNG图片..."
find "$SOURCE_DIR" -name "*.png" | while read -r img; do
    img_name=$(basename "$img")
    # 复制原始图片到输出目录
    cp "$img" "$OUTPUT_DIR/$img_name"
    # 优化PNG图片（需要安装optipng）
    optipng -o2 "$OUTPUT_DIR/$img_name" 2>/dev/null
    # 转换为WebP格式
    cwebp -lossless "$img" -o "$OUTPUT_DIR/${img_name%.*}.webp" 2>/dev/null
done

# 创建优化后图片的归档
echo "正在创建优化后图片的归档..."
zip -r -9 "$OUTPUT_DIR/optimized_pictures_$DATE.zip" "$OUTPUT_DIR" -x "*.zip"

# 生成压缩统计报告
REPORT_FILE="$OUTPUT_DIR/compression_report_$DATE.txt"

# 计算原始大小
ORIG_SIZE=$(du -sb "$SOURCE_DIR" | cut -f1)

# 计算优化后大小
OPT_SIZE=$(du -sb "$OUTPUT_DIR" | cut -f1)

# 计算压缩率
COMPRESSION_RATIO=$(echo "scale=2; (1 - $OPT_SIZE / $ORIG_SIZE) * 100" | bc)

# 生成报告
echo "图片压缩报告 - $DATE" > "$REPORT_FILE"
echo "=====================" >> "$REPORT_FILE"
echo "原始文件总大小: $(numfmt --to=iec $ORIG_SIZE)" >> "$REPORT_FILE"
echo "优化后总大小: $(numfmt --to=iec $OPT_SIZE)" >> "$REPORT_FILE"
echo "空间节省: $(numfmt --to=iec $((ORIG_SIZE - OPT_SIZE))) ($COMPRESSION_RATIO%)" >> "$REPORT_FILE"
echo "=====================" >> "$REPORT_FILE"
echo "优化的JPEG图片数量: $(find "$OUTPUT_DIR" -name "*.jpg" -o -name "*.jpeg" | wc -l)" >> "$REPORT_FILE"
echo "优化的PNG图片数量: $(find "$OUTPUT_DIR" -name "*.png" | wc -l)" >> "$REPORT_FILE"
echo "生成的WebP图片数量: $(find "$OUTPUT_DIR" -name "*.webp" | wc -l)" >> "$REPORT_FILE"

# 显示完成信息
echo "图片优化和归档完成！"
echo "- 原始图片备份: $BACKUP_DIR/original_pictures_$DATE.zip"
echo "- 优化后图片: $OUTPUT_DIR"
echo "- 优化后归档: $OUTPUT_DIR/optimized_pictures_$DATE.zip"
echo "- 压缩报告: $REPORT_FILE"
echo "空间节省: $(numfmt --to=iec $((ORIG_SIZE - OPT_SIZE))) ($COMPRESSION_RATIO%)"
```

**练习7: 开发自动压缩策略系统**

1. 创建一个脚本，根据文件类型、大小和用途自动选择最佳压缩策略
2. 实现批量文件处理功能
3. 添加压缩效果分析和优化建议
4. 集成日志记录和报表生成功能

**参考实现：**
```bash
#!/bin/bash
# 自动压缩策略系统

# 配置参数
CONFIG_FILE="$HOME/.auto_compress_config"
LOG_FILE="$HOME/compress_log.log"
REPORT_DIR="$HOME/compress_reports"

# 默认配置
default_config() {
    cat > "$CONFIG_FILE" << 'EOF'
# 自动压缩策略配置文件

# 压缩策略配置（按文件类型）
# 格式: 文件类型:压缩工具:压缩级别:是否递归:排除模式
# 压缩工具: zip, gzip, bzip2, xz, 7z
# 压缩级别: 1-9 (1最快，9最高压缩率)
# 是否递归: true/false (仅对目录有效)

COMPRESSION_STRATEGIES=(
    "txt:zip:9:false"
    "log:gzip:6:false"
    "pdf:zip:0:false"
    "jpg:zip:0:false"
    "png:zip:0:false"
    "mp3:zip:0:false"
    "mp4:zip:0:false"
    "doc:zip:9:false"
    "docx:zip:9:false"
    "xls:zip:9:false"
    "xlsx:zip:9:false"
    "ppt:zip:9:false"
    "pptx:zip:9:false"
    "py:zip:9:false"
    "sh:zip:9:false"
    "c:zip:9:false"
    "cpp:zip:9:false"
    "java:zip:9:false"
    "php:zip:9:false"
    "js:zip:9:false"
    "css:zip:9:false"
    "html:zip:9:false"
    "xml:zip:9:false"
    "json:zip:9:false"
    "csv:zip:9:false"
    "db:tar:9:true:*.tmp"
    "sql:tar:9:true"
    "dir:tar:6:true:*.git/*,*.svn/*,*.tmp,*.cache"
)

# 默认压缩策略（当未匹配到特定文件类型时使用）
DEFAULT_STRATEGY="zip:6:false"

# 临时工作目录
TEMP_DIR="/tmp/auto_compress"

# 报告生成设置
GENERATE_REPORTS=true
REPORT_FORMAT=txt  # txt, csv, html
KEEP_REPORTS_DAYS=30

# 性能监控设置
MONITOR_PERFORMANCE=true
PERFORMANCE_LOG_INTERVAL=60  # 秒

# 压缩后删除源文件（谨慎使用）
DELETE_SOURCE=false

# 备份原始文件（在删除源文件前）
BACKUP_BEFORE_DELETE=false
BACKUP_DIR="$HOME/compress_backups"
EOF
}

# 加载配置
load_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "配置文件不存在，创建默认配置..."
        default_config
    fi
    source "$CONFIG_FILE"
}

# 日志函数
log() {
    local LEVEL="$1"
    local MESSAGE="$2"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$LEVEL] $MESSAGE" >> "$LOG_FILE"
    if [ "$LEVEL" = "ERROR" ] || [ "$LEVEL" = "WARNING" ]; then
        echo "[$LEVEL] $MESSAGE" >&2
    else
        echo "[$LEVEL] $MESSAGE"
    fi
}

# 获取文件类型
get_file_type() {
    local FILE_PATH="$1"
    
    if [ -d "$FILE_PATH" ]; then
        echo "dir"
        return
    fi
    
    local EXTENSION="${FILE_PATH##*.}"
    local LOWER_EXTENSION=$(echo "$EXTENSION" | tr '[:upper:]' '[:lower:]')
    echo "$LOWER_EXTENSION"
}

# 获取文件大小（字节）
get_file_size() {
    local FILE_PATH="$1"
    stat -c %s "$FILE_PATH"
}

# 选择压缩策略
select_compression_strategy() {
    local FILE_TYPE="$1"
    
    for strategy in "${COMPRESSION_STRATEGIES[@]}"; do
        IFS=":" read -r ext tool level recursive exclude <<< "$strategy"
        if [ "$ext" = "$FILE_TYPE" ]; then
            echo "$tool:$level:$recursive:$exclude"
            return
        fi
    done
    
    # 如果没有匹配的特定策略，使用默认策略
    echo "$DEFAULT_STRATEGY:"  # 最后加上冒号作为标记，表示使用的是默认策略
}

# 执行压缩操作
compress_file() {
    local FILE_PATH="$1"
    local OUTPUT_DIR="$2"
    
    # 创建输出目录（如果不存在）
    mkdir -p "$OUTPUT_DIR"
    
    # 获取文件信息
    local FILE_NAME=$(basename "$FILE_PATH")
    local FILE_TYPE=$(get_file_type "$FILE_PATH")
    local FILE_SIZE=$(get_file_size "$FILE_PATH")
    
    # 选择压缩策略
    local STRATEGY=$(select_compression_strategy "$FILE_TYPE")
    local IS_DEFAULT=false
    
    # 解析策略
    IFS=":" read -r TOOL LEVEL RECURSIVE EXCLUDE_PATTERNS <<< "$STRATEGY"
    
    # 检查是否使用默认策略
    if [ -z "$EXCLUDE_PATTERNS" ] && [[ "$STRATEGY" == *":" ]]; then
        IS_DEFAULT=true
    fi
    
    log INFO "处理文件: $FILE_NAME (类型: $FILE_TYPE, 大小: $(numfmt --to=iec $FILE_SIZE))"
    log INFO "选择压缩策略: 工具=$TOOL, 级别=$LEVEL, 递归=$RECURSIVE, 排除=$EXCLUDE_PATTERNS"
    if [ "$IS_DEFAULT" = true ]; then
        log INFO "（使用默认压缩策略）"
    fi
    
    # 构建输出文件名
    local OUTPUT_FILE
    case "$TOOL" in
        zip)
            OUTPUT_FILE="$OUTPUT_DIR/${FILE_NAME%.*}.zip"
            if [ -d "$FILE_PATH" ]; then
                OUTPUT_FILE="$OUTPUT_DIR/$FILE_NAME.zip"
            fi
            ;;
        gzip)
            OUTPUT_FILE="$OUTPUT_DIR/${FILE_NAME}.gz"
            ;;
        bzip2)
            OUTPUT_FILE="$OUTPUT_DIR/${FILE_NAME}.bz2"
            ;;
        xz)
            OUTPUT_FILE="$OUTPUT_DIR/${FILE_NAME}.xz"
            ;;
        tar)
            OUTPUT_FILE="$OUTPUT_DIR/${FILE_NAME}.tar.gz"
            if [ "$LEVEL" -eq 0 ]; then
                OUTPUT_FILE="$OUTPUT_DIR/${FILE_NAME}.tar"
            elif [ "$LEVEL" -gt 6 ]; then
                OUTPUT_FILE="$OUTPUT_DIR/${FILE_NAME}.tar.xz"
            fi
            ;;
        7z)
            OUTPUT_FILE="$OUTPUT_DIR/${FILE_NAME}.7z"
            ;;
        *)
            log ERROR "不支持的压缩工具: $TOOL"
            return 1
            ;;
    esac
    
    # 记录开始时间
    local START_TIME=$(date +%s)
    
    # 构建排除选项
    local EXCLUDE_OPTS=""
    if [ -n "$EXCLUDE_PATTERNS" ]; then
        IFS="," read -ra PATTERNS <<< "$EXCLUDE_PATTERNS"
        for PATTERN in "${PATTERNS[@]}"; do
            case "$TOOL" in
                zip)
                    EXCLUDE_OPTS="$EXCLUDE_OPTS -x $PATTERN"
                    ;;
                tar)
                    EXCLUDE_OPTS="$EXCLUDE_OPTS --exclude=$PATTERN"
                    ;;
            esac
        done
    fi
    
    # 执行压缩
    local COMPRESS_CMD
    local SUCCESS=false
    
    case "$TOOL" in
        zip)
            if [ "$RECURSIVE" = "true" ] || [ -d "$FILE_PATH" ]; then
                COMPRESS_CMD="zip -r -$LEVEL $EXCLUDE_OPTS \"$OUTPUT_FILE\" \"$FILE_PATH\""
            else
                COMPRESS_CMD="zip -$LEVEL $EXCLUDE_OPTS \"$OUTPUT_FILE\" \"$FILE_PATH\""
            fi
            ;;
        gzip)
            COMPRESS_CMD="gzip -$LEVEL -c \"$FILE_PATH\" > \"$OUTPUT_FILE\""
            ;;
        bzip2)
            COMPRESS_CMD="bzip2 -$LEVEL -c \"$FILE_PATH\" > \"$OUTPUT_FILE\""
            ;;
        xz)
            COMPRESS_CMD="xz -$LEVEL -c \"$FILE_PATH\" > \"$OUTPUT_FILE\""
            ;;
        tar)
            if [ "$LEVEL" -eq 0 ]; then
                # 仅归档不压缩
                if [ "$RECURSIVE" = "true" ] || [ -d "$FILE_PATH" ]; then
                    COMPRESS_CMD="tar -cf \"$OUTPUT_FILE\" $EXCLUDE_OPTS \"$FILE_PATH\""
                else
                    COMPRESS_CMD="tar -cf \"$OUTPUT_FILE\" $EXCLUDE_OPTS \"$FILE_PATH\""
                fi
            elif [ "$LEVEL" -le 6 ]; then
                # 使用gzip压缩
                if [ "$RECURSIVE" = "true" ] || [ -d "$FILE_PATH" ]; then
                    COMPRESS_CMD="tar -czf \"$OUTPUT_FILE\" $EXCLUDE_OPTS \"$FILE_PATH\""
                else
                    COMPRESS_CMD="tar -czf \"$OUTPUT_FILE\" $EXCLUDE_OPTS \"$FILE_PATH\""
                fi
            else
                # 使用xz压缩
                if [ "$RECURSIVE" = "true" ] || [ -d "$FILE_PATH" ]; then
                    COMPRESS_CMD="tar -cJf \"$OUTPUT_FILE\" $EXCLUDE_OPTS \"$FILE_PATH\""
                else
                    COMPRESS_CMD="tar -cJf \"$OUTPUT_FILE\" $EXCLUDE_OPTS \"$FILE_PATH\""
                fi
            fi
            ;;
        7z)
            if [ "$RECURSIVE" = "true" ] || [ -d "$FILE_PATH" ]; then
                COMPRESS_CMD="7z a -mx$LEVEL $EXCLUDE_OPTS \"$OUTPUT_FILE\" \"$FILE_PATH\""
            else
                COMPRESS_CMD="7z a -mx$LEVEL $EXCLUDE_OPTS \"$OUTPUT_FILE\" \"$FILE_PATH\""
            fi
            ;;
    esac
    
    # 执行压缩命令
    log INFO "执行压缩命令: $COMPRESS_CMD"
    eval $COMPRESS_CMD
    if [ $? -eq 0 ]; then
        SUCCESS=true
        log INFO "压缩成功: $OUTPUT_FILE"
    else
        log ERROR "压缩失败: $FILE_NAME"
        return 1
    fi
    
    # 记录完成时间
    local END_TIME=$(date +%s)
    local DURATION=$((END_TIME - START_TIME))
    
    # 获取压缩后文件大小
    local COMPRESSED_SIZE=$(get_file_size "$OUTPUT_FILE")
    
    # 计算压缩率
    local COMPRESSION_RATIO=0
    if [ $FILE_SIZE -gt 0 ]; then
        COMPRESSION_RATIO=$(echo "scale=2; (1 - $COMPRESSED_SIZE / $FILE_SIZE) * 100" | bc)
    fi
    
    # 计算压缩速度
    local COMPRESSION_SPEED=0
    if [ $DURATION -gt 0 ]; then
        COMPRESSION_SPEED=$((FILE_SIZE / DURATION))
    fi
    
    log INFO "压缩统计: 原始大小=$(numfmt --to=iec $FILE_SIZE), 压缩后=$(numfmt --to=iec $COMPRESSED_SIZE), 节省=$(numfmt --to=iec $((FILE_SIZE - COMPRESSED_SIZE))) (${COMPRESSION_RATIO}%), 耗时=${DURATION}秒, 速度=$(numfmt --to=iec $COMPRESSION_SPEED)/s"
    
    # 如果配置了删除源文件
    if [ "$DELETE_SOURCE" = "true" ]; then
        if [ "$BACKUP_BEFORE_DELETE" = "true" ]; then
            # 创建备份目录
            mkdir -p "$BACKUP_DIR"
            
            # 备份文件
            local BACKUP_FILE="$BACKUP_DIR/$(basename "$FILE_PATH")_$(date +%Y%m%d_%H%M%S)"
            if [ -d "$FILE_PATH" ]; then
                cp -r "$FILE_PATH" "$BACKUP_FILE"
            else
                cp "$FILE_PATH" "$BACKUP_FILE"
            fi
            
            log INFO "已备份源文件到: $BACKUP_FILE"
        fi
        
        # 删除源文件
        if [ -d "$FILE_PATH" ]; then
            rm -rf "$FILE_PATH"
        else
            rm -f "$FILE_PATH"
        fi
        
        log INFO "已删除源文件: $FILE_PATH"
    fi
    
    # 返回压缩信息
    echo "$FILE_NAME,$FILE_TYPE,$(numfmt --to=iec $FILE_SIZE),$(numfmt --to=iec $COMPRESSED_SIZE),${COMPRESSION_RATIO}%,$DURATION,$(numfmt --to=iec $COMPRESSION_SPEED)/s,$TOOL,$LEVEL,$SUCCESS"
    
    return 0
}

# 批量处理文件
batch_compress() {
    local SOURCE_PATH="$1"
    local OUTPUT_DIR="$2"
    
    if [ -z "$SOURCE_PATH" ]; then
        log ERROR "源路径是必需的"
        echo "用法: $0 compress <source_path> [output_dir]" >&2
        return 1
    fi
    
    # 使用当前目录作为默认输出目录
    if [ -z "$OUTPUT_DIR" ]; then
        OUTPUT_DIR="."
    fi
    
    # 创建输出目录（如果不存在）
    mkdir -p "$OUTPUT_DIR"
    
    # 创建报告目录（如果不存在）
    if [ "$GENERATE_REPORTS" = "true" ]; then
        mkdir -p "$REPORT_DIR"
    fi
    
    # 记录开始时间
    local BATCH_START_TIME=$(date +%s)
    log INFO "开始批量压缩处理: $SOURCE_PATH -> $OUTPUT_DIR"
    
    # 创建临时目录
    local TEMP_DIR="$TEMP_DIR/$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$TEMP_DIR"
    
    # 创建报告文件
    local REPORT_FILE
    if [ "$GENERATE_REPORTS" = "true" ]; then
        REPORT_FILE="$REPORT_DIR/compress_report_$(date +%Y%m%d_%H%M%S)"
        case "$REPORT_FORMAT" in
            csv)
                REPORT_FILE="${REPORT_FILE}.csv"
                echo "文件名,文件类型,原始大小,压缩后大小,节省空间,耗时(秒),速度,压缩工具,压缩级别,成功状态" > "$REPORT_FILE"
                ;;
            html)
                REPORT_FILE="${REPORT_FILE}.html"
                cat > "$REPORT_FILE" << 'EOF'
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>压缩报告</title>
    <style>
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .success { color: green; }
        .error { color: red; }
        .summary { margin-top: 20px; padding: 10px; background-color: #f9f9f9; border: 1px solid #ddd; }
    </style>
</head>
<body>
    <h1>压缩报告 - $(date)</h1>
    <table>
        <tr>
            <th>文件名</th>
            <th>文件类型</th>
            <th>原始大小</th>
            <th>压缩后大小</th>
            <th>节省空间</th>
            <th>耗时(秒)</th>
            <th>速度</th>
            <th>压缩工具</th>
            <th>压缩级别</th>
            <th>状态</th>
        </tr>
EOF
                ;;
            *)
                REPORT_FILE="${REPORT_FILE}.txt"
                  echo "===== 压缩报告 - $(date) =====" >> "$REPORT_FILE"
                  echo "源路径: $SOURCE_PATH" >> "$REPORT_FILE"
                  echo "输出目录: $OUTPUT_DIR" >> "$REPORT_FILE"
                  echo "==============================" >> "$REPORT_FILE"
                  echo "" >> "$REPORT_FILE"