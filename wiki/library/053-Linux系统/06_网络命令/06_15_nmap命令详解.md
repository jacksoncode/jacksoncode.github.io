# 06_15_nmap命令详解

## 1. 命令概述

`nmap`（Network Mapper）是一个强大的网络发现和安全审计工具，被广泛应用于网络扫描、服务发现、安全评估和漏洞检测。它可以帮助网络管理员和安全专业人员发现网络上的主机、开放的端口、运行的服务以及潜在的安全漏洞。

**主要功能和用途：**
- 主机发现：识别网络上活跃的主机
- 端口扫描：检测目标主机上开放的端口和服务
- 版本检测：识别运行在特定端口上的服务版本
- 操作系统检测：识别目标主机运行的操作系统类型和版本
- 脚本扫描：使用NSE（Nmap Scripting Engine）执行自定义的脚本，进行更深入的安全检查
- 网络拓扑映射：创建网络拓扑图
- 漏洞检测：识别目标系统上的安全漏洞

**典型应用场景：**
- 网络安全审计
- 系统漏洞评估
- 网络映射和资产管理
- 渗透测试
- 网络故障排查
- 合规性检查

## 2. 语法格式

`nmap`命令的基本语法格式如下：

```bash
nmap [扫描类型] [选项] [扫描目标]
```

其中，扫描目标可以是单个IP地址、IP地址范围、主机名、域名或包含目标列表的文件。`nmap`命令支持多种扫描类型和选项，可以根据不同的需求进行组合使用。

## 3. 选项说明

### 3.1 扫描类型

| 选项 | 说明 |
|------|------|
| `-sS`, `--syn-scan` | TCP SYN扫描（半开放扫描），最快最常用的扫描方式 |
| `-sT`, `--tcp-connect` | TCP连接扫描，完成完整的TCP三次握手 |
| `-sU`, `--udp-scan` | UDP扫描，检测UDP端口 |
| `-sI`, `--idle-scan` | 空闲扫描，使用第三方主机进行隐蔽扫描 |
| `-sO`, `--ip-protocol-scan` | IP协议扫描，检测支持的IP协议类型 |
| `-sN`, `-sF`, `-sX` | TCP Null、FIN、Xmas扫描，用于绕过某些防火墙规则 |
| `-sA`, `--ack-scan` | TCP ACK扫描，用于检测防火墙规则 |
| `-sW`, `--window-scan` | TCP窗口扫描，类似于ACK扫描但能区分过滤和非过滤状态 |
| `-sM`, `--maimon-scan` | Maimon扫描，发送FIN/ACK探测包 |
| `-sZ`, `--sctp-scan` | SCTP INIT扫描 |
| `-sY`, `--sctp-cookie-echo-scan` | SCTP Cookie Echo扫描 |
| `-sO`, `--ip-protocol-scan` | IP协议扫描 |

### 3.2 主机发现选项

| 选项 | 说明 |
|------|------|
| `-sL`, `--list-scan` | 简单列表扫描，不进行实际扫描 |
| `-sn`, `--ping-scan` | 仅进行主机发现，不进行端口扫描 |
| `-Pn`, `--disable-ping` | 跳过主机发现，将所有目标视为活跃 |
| `-PS`, `--tcp-syn-ping` | 使用TCP SYN ping进行主机发现 |
| `-PA`, `--tcp-ack-ping` | 使用TCP ACK ping进行主机发现 |
| `-PU`, `--udp-ping` | 使用UDP ping进行主机发现 |
| `-PE`, `-PP`, `-PM` | 使用ICMP Echo、Timestamp、Netmask请求进行主机发现 |
| `-PO`, `--protocol-ping` | 使用IP协议ping进行主机发现 |
| `-n`, `-R` | `-n`: 不进行DNS解析；`-R`: 总是进行DNS解析 |
| `--dns-servers` | 指定自定义DNS服务器 |
| `--system-dns` | 使用系统默认DNS服务器 |
| `--traceroute` | 为每个主机进行traceroute |

### 3.3 端口扫描选项

| 选项 | 说明 |
|------|------|
| `-p` `<port ranges>` | 指定要扫描的端口范围 |
| `-F`, `--fast` | 快速扫描模式，只扫描最常用的100个端口 |
| `-r`, `--randomize-hosts` | 不按顺序扫描端口 |
| `--top-ports` `<number>` | 扫描最常用的`<number>`个端口 |
| `--port-ratio` `<ratio>` | 扫描端口使用率高于指定比例的端口 |

### 3.4 服务和版本检测选项

| 选项 | 说明 |
|------|------|
| `-sV`, `--version-all` | 启用版本检测 |
| `--version-intensity` `<level>` | 设置版本检测的强度（0-9），默认为7 |
| `--version-light` | 使用轻量级版本检测（强度2） |
| `--version-all` | 使用最全面的版本检测（强度9） |
| `--version-trace` | 显示版本检测的详细过程 |

### 3.5 操作系统检测选项

| 选项 | 说明 |
|------|------|
| `-O`, `--os-detection` | 启用操作系统检测 |
| `--osscan-limit` | 限制操作系统检测只对有希望的目标进行 |
| `--osscan-guess` | 尝试猜测操作系统类型 |
| `--max-os-tries` `<number>` | 设置操作系统检测的最大尝试次数 |

### 3.6 时间和性能选项

| 选项 | 说明 |
|------|------|
| `-T<0-5>` | 设置时间模板（paranoid, sneaky, polite, normal, aggressive, insane） |
| `--min-hostgroup`, `--max-hostgroup` | 设置并行扫描的主机组大小 |
| `--min-parallelism`, `--max-parallelism` | 设置并行扫描的探测包数量 |
| `--min-rtt-timeout`, `--max-rtt-timeout`, `--initial-rtt-timeout` | 设置探测超时时间 |
| `--host-timeout` | 设置扫描单个主机的最大时间 |
| `--scan-delay`, `--max-scan-delay` | 设置探测之间的延迟时间 |
| `--min-rate`, `--max-rate` | 设置发送数据包的最小/最大速率 |

### 3.7 输出选项

| 选项 | 说明 |
|------|------|
| `-oN` `<file>` | 保存正常格式的输出到文件 |
| `-oX` `<file>` | 保存XML格式的输出到文件 |
| `-oS` `<file>` | 保存脚本 kiddie格式的输出到文件 |
| `-oG` `<file>` | 保存grepable格式的输出到文件 |
| `-oA` `<basename>` | 同时保存所有格式的输出，使用指定的基本文件名 |
| `-v` | 提高输出详细程度 |
| `-d` | 提高调试输出详细程度 |
| `--reason` | 显示端口处于特定状态的原因 |
| `--open` | 只显示开放的（或可能开放的）端口 |
| `--packet-trace` | 显示发送和接收的数据包 |
| `--iflist` | 显示主机的网络接口和路由信息 |
| `--append-output` | 追加到指定的输出文件，而不是覆盖 |
| `--resume` `<filename>` | 恢复已停止的扫描 |
| `--stylesheet` `<path/URL>` | 为XML输出指定XSL样式表 |
| `--webxml` | 从Nmap.org获取参考XSL样式表 |
| `--no-stylesheet` | 不将XSL样式表引用包含在XML输出中 |

### 3.8 脚本扫描选项

| 选项 | 说明 |
|------|------|
| `-sC`, `--script`=`default` | 使用默认的脚本集合进行扫描 |
| `--script`=`"<script_name>,..."` | 指定要运行的脚本或脚本类别 |
| `--script-args`=`n1=v1,[n2=v2,...]` | 为脚本提供参数 |
| `--script-args-file`=`filename` | 从文件中加载脚本参数 |
| `--script-trace` | 显示脚本执行的详细过程 |
| `--script-updatedb` | 更新脚本数据库 |
| `--script-help`=`"<script_name>,..."` | 显示脚本的帮助信息 |

### 3.9 防火墙/IDS规避和欺骗选项

| 选项 | 说明 |
|------|------|
| `-f`, `--mtu` | 使用分段数据包进行扫描 |
| `-D` `<decoy1,decoy2,...>` | 使用诱饵扫描技术 |
| `-S` `<IP_Address>` | 源地址欺骗 |
| `-e` `<iface>` | 使用指定的网络接口 |
| `-g`/`--source-port` `<portnum>` | 使用指定的源端口 |
| `--proxies` `<url1,[url2],...>` | 使用HTTP/SOCKS4代理进行扫描 |
| `--data` `<hex string>` | 在发送的数据包中附加自定义负载 |
| `--data-string` `<string>` | 在发送的数据包中附加自定义ASCII字符串 |
| `--data-length` `<num>` | 在发送的数据包中附加随机数据 |
| `--ip-options` `<options>` | 设置IP选项 |
| `--ttl` `<value>` | 设置数据包的TTL值 |
| `--randomize-hosts` | 随机化目标主机顺序 |
| `--spoof-mac` `<mac address/prefix/vendor name>` | 欺骗MAC地址 |
| `--badsum` | 发送具有错误校验和的数据包 |

## 4. 基本用法示例

### 4.1 简单扫描

最简单的nmap扫描形式是指定一个目标主机：

```bash
nmap 192.168.1.1
```

**功能说明：**
对目标IP地址192.168.1.1进行基本的端口扫描，默认情况下，nmap会扫描最常用的1000个TCP端口。

**参数说明：**
- 192.168.1.1: 目标IP地址

**常见问题与解决方案：**
- 如果扫描过程较慢，可以尝试使用`-T4`或`-T5`选项提高扫描速度
- 如果遇到防火墙拦截，可以尝试使用`-sS`（SYN扫描）或`-f`（分段数据包）选项

### 4.2 扫描多个目标

可以同时扫描多个目标，使用空格分隔：

```bash
nmap 192.168.1.1 192.168.1.100 192.168.1.200
```

**功能说明：**
同时对多个目标IP地址进行端口扫描。

**参数说明：**
- 192.168.1.1, 192.168.1.100, 192.168.1.200: 多个目标IP地址

**常见问题与解决方案：**
- 对于大量目标，可以将目标列表保存到文件中，使用`-iL`选项加载
- 可以使用CIDR表示法扫描整个子网：`nmap 192.168.1.0/24`

### 4.3 扫描整个子网

使用CIDR表示法可以扫描整个子网：

```bash
nmap 192.168.1.0/24
```

**功能说明：**
扫描192.168.1.0/24子网中的所有主机，包括主机发现和端口扫描。

**参数说明：**
- 192.168.1.0/24: CIDR表示法的子网范围

**常见问题与解决方案：**
- 整个子网扫描可能需要较长时间，可以使用`-sn`选项只进行主机发现，不进行端口扫描
- 可以使用`--exclude`选项排除特定主机或子网

### 4.4 仅进行主机发现

如果只需要识别网络上的活跃主机，可以使用`-sn`选项：

```bash
nmap -sn 192.168.1.0/24
```

**功能说明：**
对192.168.1.0/24子网进行主机发现，不进行端口扫描，类似于ping扫描。

**参数说明：**
- -sn: 仅进行主机发现
- 192.168.1.0/24: 目标子网

**常见问题与解决方案：**
- 某些主机可能禁用了ping响应，可以尝试使用其他主机发现方法，如`-PS`（TCP SYN ping）或`-PA`（TCP ACK ping）
- 如果需要更快的扫描，可以结合使用`-T4`或`-T5`选项

### 4.5 指定端口扫描

可以使用`-p`选项指定要扫描的端口：

```bash
nmap -p 22,80,443 192.168.1.1
```

**功能说明：**
仅扫描目标主机上的特定端口（22、80和443），而不是默认的1000个端口。

**参数说明：**
- -p 22,80,443: 指定要扫描的端口，多个端口用逗号分隔
- 192.168.1.1: 目标IP地址

**常见问题与解决方案：**
- 可以指定端口范围：`-p 1-1000`
- 可以扫描所有端口：`-p-`
- 可以扫描常用端口：`--top-ports 100`

### 4.6 服务版本检测

使用`-sV`选项可以检测目标主机上运行的服务版本：

```bash
nmap -sV 192.168.1.1
```

**功能说明：**
不仅扫描目标主机上的开放端口，还尝试识别每个端口上运行的具体服务和版本。

**参数说明：**
- -sV: 启用服务版本检测
- 192.168.1.1: 目标IP地址

**常见问题与解决方案：**
- 服务版本检测会增加扫描时间，可以使用`--version-light`选项加快速度
- 对于更详细的版本检测，可以使用`--version-all`选项

### 4.7 操作系统检测

使用`-O`选项可以尝试检测目标主机的操作系统：

```bash
nmap -O 192.168.1.1
```

**功能说明：**
通过分析网络响应的特征，尝试识别目标主机运行的操作系统类型和版本。

**参数说明：**
- -O: 启用操作系统检测
- 192.168.1.1: 目标IP地址

**常见问题与解决方案：**
- 操作系统检测可能不准确，特别是对于配置了防火墙或使用了伪装技术的系统
- 可以使用`--osscan-guess`选项让nmap尝试猜测操作系统类型
- 可以结合`-sV`选项同时进行服务版本检测：`nmap -sV -O 192.168.1.1`

### 4.8 快速扫描

使用`-F`选项可以进行快速扫描，只扫描最常用的100个端口：

```bash
nmap -F 192.168.1.0/24
```

**功能说明：**
对192.168.1.0/24子网进行快速扫描，只扫描最常用的100个端口，以节省时间。

**参数说明：**
- -F: 快速扫描模式
- 192.168.1.0/24: 目标子网

**常见问题与解决方案：**
- 对于更快速的扫描，可以结合使用`-T4`或`-T5`选项
- 快速扫描可能会遗漏一些不常用但重要的端口

### 4.9 输出保存

使用`-oN`、`-oX`等选项可以将扫描结果保存到文件中：

```bash
nmap -oN scan_results.txt 192.168.1.1
```

**功能说明：**
将扫描结果保存到文本文件中，便于后续分析和报告。

**参数说明：**
- -oN scan_results.txt: 以正常格式保存扫描结果到指定文件
- 192.168.1.1: 目标IP地址

**常见问题与解决方案：**
- 可以同时保存多种格式：`nmap -oA scan_results 192.168.1.1`
- 可以使用`--append-output`选项追加到现有文件，而不是覆盖

### 4.10 扫描特定主机列表

可以从文件中加载目标主机列表进行扫描：

```bash
nmap -iL targets.txt
```

**功能说明：**
从指定文件中读取目标主机列表并进行扫描，适用于大规模扫描。

**参数说明：**
- -iL targets.txt: 从文件中加载目标列表

**常见问题与解决方案：**
- 文件中的每行可以包含一个IP地址、主机名或CIDR范围
- 可以使用`--exclude`选项排除特定主机
- 对于大量目标，建议调整扫描性能参数以提高效率

## 5. 高级用法与技巧

### 5.1 组合扫描选项

nmap的强大之处在于可以组合使用各种扫描选项，以满足不同的需求：

```bash
# 全面扫描：主机发现、端口扫描、服务版本检测、操作系统检测
nmap -A 192.168.1.1

# 快速全面扫描：使用-A选项但加快速度
nmap -A -T4 192.168.1.1

# 隐蔽扫描：使用SYN扫描、诱饵和分段数据包
nmap -sS -D 192.168.1.10,192.168.1.11,192.168.1.12 -f 192.168.1.1

# 详细扫描：启用详细输出、显示原因、跟踪数据包
nmap -v --reason --packet-trace 192.168.1.1

# 自定义端口范围扫描
nmap -p 1-1000,2000-3000,8080,8443 192.168.1.1

# 扫描特定协议和服务
nmap -sV -sU -p T:22,80,443,U:53,161 192.168.1.1

# 分段数据包扫描以绕过防火墙
nmap -f 192.168.1.1

# 使用自定义源端口
nmap --source-port 53 192.168.1.1

# 欺骗MAC地址
nmap --spoof-mac 00:11:22:33:44:55 192.168.1.1

# 同时扫描多个目标列表文件
nmap -iL targets1.txt,targets2.txt
```

**功能说明：**
通过组合不同的选项，可以执行更复杂、更有针对性的扫描任务，适应各种网络环境和安全要求。

**常见问题与解决方案：**
- 选项组合可能会影响扫描速度，需要根据实际情况进行权衡
- 某些选项组合可能不兼容，需要查看nmap的文档以了解详细信息
- 在高安全环境中，某些扫描选项可能会触发入侵检测系统

### 5.2 Nmap脚本引擎（NSE）使用

Nmap脚本引擎（NSE）是nmap最强大的功能之一，可以执行各种自定义脚本进行更深入的安全检查：

```bash
# 使用默认脚本集
nmap -sC 192.168.1.1

# 使用特定脚本
nmap --script=http-enum,http-title 192.168.1.1

# 使用脚本类别
nmap --script=discovery,vuln 192.168.1.1

# 使用多个脚本和类别
nmap --script=default,vuln,http* 192.168.1.1

# 查看脚本帮助信息
nmap --script-help=http-enum

# 为脚本提供参数
nmap --script=smb-brute --script-args=userdb=users.txt,passdb=passwords.txt 192.168.1.1

# 显示脚本执行过程
nmap --script-trace --script=http-enum 192.168.1.1

# 更新脚本数据库
nmap --script-updatedb

# 常用安全扫描脚本
nmap --script=vuln 192.168.1.1

# 常用漏洞检测脚本
nmap --script=smb-vuln*,http-vuln* 192.168.1.1

# 常用弱密码检测脚本
nmap --script=brute 192.168.1.1

# 常用信息收集脚本
nmap --script=discovery 192.168.1.1
```

**功能说明：**
NSE脚本可以执行各种任务，包括漏洞检测、服务枚举、弱密码测试、指纹识别等，大大扩展了nmap的功能。

**常见问题与解决方案：**
- NSE脚本可能会增加扫描时间，特别是大量使用时
- 某些脚本可能会对目标系统产生影响，使用前应了解脚本的功能和可能的风险
- 可以编写自定义NSE脚本以满足特定需求

### 5.3 性能优化技巧

在进行大规模扫描时，性能优化非常重要：

```bash
# 使用时间模板设置扫描速度
nmap -T4 192.168.1.0/24

# 设置并行扫描的主机组大小
nmap --min-hostgroup 100 --max-hostgroup 200 192.168.1.0/24

# 设置并行扫描的探测包数量
nmap --min-parallelism 100 --max-parallelism 200 192.168.1.0/24

# 设置探测超时时间
nmap --min-rtt-timeout 100ms --max-rtt-timeout 3000ms --initial-rtt-timeout 300ms 192.168.1.0/24

# 设置扫描单个主机的最大时间
nmap --host-timeout 30m 192.168.1.0/24

# 设置探测之间的延迟时间
nmap --scan-delay 10ms --max-scan-delay 100ms 192.168.1.0/24

# 设置发送数据包的速率
nmap --min-rate 1000 --max-rate 2000 192.168.1.0/24

# 随机化目标主机顺序以分散负载
nmap --randomize-hosts 192.168.1.0/24

# 跳过DNS解析以加快扫描速度
nmap -n 192.168.1.0/24

# 只扫描最常用的端口
nmap --top-ports 1000 192.168.1.0/24
```

**功能说明：**
通过调整各种性能参数，可以显著提高nmap在大规模网络环境中的扫描效率，减少扫描时间。

**常见问题与解决方案：**
- 提高扫描速度可能会增加网络负载和被目标系统检测到的风险
- 在带宽受限的网络环境中，应适当降低扫描速率
- 不同的网络环境可能需要不同的性能优化参数，需要根据实际情况进行调整

### 5.4 防火墙规避技巧

在面对有防火墙保护的目标时，可以使用各种规避技巧：

```bash
# 使用SYN扫描（半开放扫描）
map -sS 192.168.1.1

# 使用分段数据包
nmap -f 192.168.1.1

# 使用自定义MTU值
nmap --mtu 16 192.168.1.1

# 使用诱饵扫描
nmap -D 192.168.1.10,192.168.1.11,192.168.1.12 192.168.1.1

# 源地址欺骗
nmap -S 192.168.1.50 192.168.1.1

# 使用特定源端口
nmap --source-port 53 192.168.1.1

# 使用IP选项
nmap --ip-options "RR" 192.168.1.1

# 设置TTL值
nmap --ttl 128 192.168.1.1

# 使用ACK扫描检测防火墙规则
nmap -sA 192.168.1.1

# 发送具有错误校验和的数据包
nmap --badsum 192.168.1.1

# 结合多种规避技术
nmap -sS -f -D 192.168.1.10,192.168.1.11 --source-port 53 192.168.1.1
```

**功能说明：**
这些技巧可以帮助绕过防火墙的检测和过滤，增加扫描的成功率，但同时也可能被视为攻击性扫描。

**常见问题与解决方案：**
- 使用规避技术可能会触发入侵检测系统的警报
- 某些规避技术可能不适用于所有类型的防火墙
- 在进行安全测试前，应确保获得适当的授权

### 5.5 自动化扫描与报告生成

nmap可以与其他工具结合，实现自动化扫描和报告生成：

```bash
# 使用bash脚本进行批量扫描
#!/bin/bash

# 定义扫描参数
TARGETS="192.168.1.0/24"
OUTPUT_DIR="/var/nmap/scans"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建输出目录
mkdir -p "$OUTPUT_DIR"

# 执行全面扫描
nmap -A -T4 -oA "$OUTPUT_DIR/full_scan_$DATE" "$TARGETS"

# 执行漏洞扫描
nmap --script=vuln -T4 -oA "$OUTPUT_DIR/vuln_scan_$DATE" "$TARGETS"

# 生成简单报告
echo "Nmap扫描报告 - $DATE" > "$OUTPUT_DIR/report_$DATE.txt"
echo "=======================================" >> "$OUTPUT_DIR/report_$DATE.txt"
echo "\n扫描目标: $TARGETS" >> "$OUTPUT_DIR/report_$DATE.txt"
echo "\n发现的主机数: $(grep -c 'Host is up' "$OUTPUT_DIR/full_scan_$DATE.nmap")" >> "$OUTPUT_DIR/report_$DATE.txt"
echo "\n发现的开放端口: $(grep -c '/tcp' "$OUTPUT_DIR/full_scan_$DATE.nmap")" >> "$OUTPUT_DIR/report_$DATE.txt"
echo "\n发现的服务数: $(grep -c 'open' "$OUTPUT_DIR/full_scan_$DATE.nmap" | grep -v 'filtered')" >> "$OUTPUT_DIR/report_$DATE.txt"
echo "\n发现的漏洞数: $(grep -c 'VULNERABLE' "$OUTPUT_DIR/vuln_scan_$DATE.nmap")" >> "$OUTPUT_DIR/report_$DATE.txt"
echo "\n详细报告请查看: $OUTPUT_DIR/full_scan_$DATE.nmap 和 $OUTPUT_DIR/vuln_scan_$DATE.nmap" >> "$OUTPUT_DIR/report_$DATE.txt"

# 发送邮件通知（可选）
# echo "Nmap扫描完成，请查看报告" | mail -s "Nmap扫描报告 - $DATE" admin@example.com

# 使用XML输出进行进一步处理
# xsltproc "$OUTPUT_DIR/full_scan_$DATE.xml" -o "$OUTPUT_DIR/full_scan_$DATE.html"
```

**功能说明：**
这个脚本实现了自动化的nmap扫描，可以定期执行并生成扫描报告，适用于网络安全审计和定期漏洞评估。

**常见问题与解决方案：**
- 可以使用crontab设置定期执行扫描任务
- 可以结合其他工具如Zenmap、OpenVAS等进行更全面的安全评估
- 可以使用nmap的XML输出格式与其他安全工具集成

## 6. 实用技巧与应用场景

### 6.1 网络安全审计

nmap是网络安全审计的重要工具，可以帮助识别网络中的安全风险和漏洞：

```bash
# 企业网络安全审计脚本
#!/bin/bash

# 配置参数
NETWORK_RANGE="192.168.1.0/24 10.0.0.0/24"
SCAN_DIR="/var/audit/nmap_scans"
REPORT_DIR="/var/audit/reports"
DATE=$(date +%Y%m%d)
ADMIN_EMAIL="security@example.com"

# 创建目录
mkdir -p "$SCAN_DIR" "$REPORT_DIR"

# 函数：执行主机发现
function discover_hosts() {
    echo "[*] 开始主机发现..."
    nmap -sn -T4 $NETWORK_RANGE -oA "$SCAN_DIR/host_discovery_$DATE"
    echo "[*] 主机发现完成！"
}

# 函数：执行端口扫描
function port_scan() {
    echo "[*] 开始端口扫描..."
    nmap -p- -T4 -oA "$SCAN_DIR/port_scan_$DATE" -iL <(grep 'Nmap scan report' "$SCAN_DIR/host_discovery_$DATE.nmap" | awk '{print $5}')
    echo "[*] 端口扫描完成！"
}

# 函数：执行服务版本检测
function version_scan() {
    echo "[*] 开始服务版本检测..."
    nmap -sV -T4 -oA "$SCAN_DIR/version_scan_$DATE" --open -iL <(grep '^[0-9]' "$SCAN_DIR/port_scan_$DATE.gnmap" | cut -d' ' -f2)
    echo "[*] 服务版本检测完成！"
}

# 函数：执行操作系统检测
function os_scan() {
    echo "[*] 开始操作系统检测..."
    nmap -O --osscan-guess -T4 -oA "$SCAN_DIR/os_scan_$DATE" -iL <(grep 'Nmap scan report' "$SCAN_DIR/host_discovery_$DATE.nmap" | awk '{print $5}')
    echo "[*] 操作系统检测完成！"
}

# 函数：执行漏洞扫描
function vuln_scan() {
    echo "[*] 开始漏洞扫描..."
    nmap --script=vuln,exploit,auth -T4 -oA "$SCAN_DIR/vuln_scan_$DATE" --open -iL <(grep '^[0-9]' "$SCAN_DIR/port_scan_$DATE.gnmap" | cut -d' ' -f2)
    echo "[*] 漏洞扫描完成！"
}

# 函数：执行Web应用扫描
function web_scan() {
    echo "[*] 开始Web应用扫描..."
    # 提取Web服务主机和端口
    WEB_HOSTS=$(grep -E '80/tcp|443/tcp|8080/tcp|8443/tcp' "$SCAN_DIR/port_scan_$DATE.gnmap" | grep 'open' | cut -d' ' -f2)
    if [ ! -z "$WEB_HOSTS" ]; then
        nmap --script=http*,ssl* -T4 -oA "$SCAN_DIR/web_scan_$DATE" $WEB_HOSTS
    fi
    echo "[*] Web应用扫描完成！"
}

# 函数：生成审计报告
function generate_report() {
    echo "[*] 生成审计报告..."
    REPORT_FILE="$REPORT_DIR/network_security_audit_$DATE.txt"
    
    echo "企业网络安全审计报告" > "$REPORT_FILE"
    echo "生成日期: $(date)" >> "$REPORT_FILE"
    echo "=============================" >> "$REPORT_FILE"
    echo "\n1. 网络概述" >> "$REPORT_FILE"
    echo "扫描网络范围: $NETWORK_RANGE" >> "$REPORT_FILE"
    
    # 统计信息
    echo "\n2. 扫描统计" >> "$REPORT_FILE"
    TOTAL_HOSTS=$(grep -c 'Nmap scan report' "$SCAN_DIR/host_discovery_$DATE.nmap")
    echo "发现的主机总数: $TOTAL_HOSTS" >> "$REPORT_FILE"
    
    OPEN_PORTS=$(grep -c '/tcp.*open' "$SCAN_DIR/port_scan_$DATE.nmap")
    echo "发现的开放端口数: $OPEN_PORTS" >> "$REPORT_FILE"
    
    VULNERABILITIES=$(grep -c 'VULNERABLE' "$SCAN_DIR/vuln_scan_$DATE.nmap")
    echo "发现的漏洞数: $VULNERABILITIES" >> "$REPORT_FILE"
    
    # 详细发现
    echo "\n3. 详细发现" >> "$REPORT_FILE"
    echo "\n3.1 活跃主机列表:" >> "$REPORT_FILE"
    grep 'Nmap scan report' "$SCAN_DIR/host_discovery_$DATE.nmap" | awk '{print $5}' >> "$REPORT_FILE"
    
    echo "\n3.2 高风险发现:" >> "$REPORT_FILE"
    grep -A 3 'VULNERABLE' "$SCAN_DIR/vuln_scan_$DATE.nmap" | grep -v '^--$' | head -20 >> "$REPORT_FILE"
    
    # 安全建议
    echo "\n4. 安全建议" >> "$REPORT_FILE"
    if [ $VULNERABILITIES -gt 0 ]; then
        echo "- 及时修补所有发现的漏洞"
    fi
    echo "- 关闭不必要的开放端口和服务"
    echo "- 确保所有服务使用最新的稳定版本"
    echo "- 实施强访问控制策略"
    echo "- 定期进行安全审计和漏洞扫描"
    
    echo "[*] 审计报告生成完成: $REPORT_FILE"
}

# 函数：发送报告邮件
function send_report() {
    echo "[*] 发送审计报告..."
    # echo "网络安全审计已完成，请查看附件中的报告" | mail -s "企业网络安全审计报告 - $DATE" -a "$REPORT_DIR/network_security_audit_$DATE.txt" "$ADMIN_EMAIL"
    echo "[*] 报告发送完成！"
}

# 主函数
function main() {
    echo "====== 企业网络安全审计开始 ======"
    discover_hosts
    port_scan
    version_scan
    os_scan
    vuln_scan
    web_scan
    generate_report
    send_report
    echo "====== 企业网络安全审计完成 ======"
}

# 执行主函数
main
```

**功能说明：**
这个脚本实现了全面的企业网络安全审计流程，包括主机发现、端口扫描、服务版本检测、操作系统检测、漏洞扫描和Web应用扫描，并生成详细的审计报告。

**使用场景：**
- 企业网络定期安全审计
- 新系统上线前的安全评估
- 安全事件后的全面检查
- 合规性验证
- 网络资产梳理

### 6.2 网络拓扑发现

nmap可以用于发现和绘制网络拓扑：

```bash
# 网络拓扑发现脚本
#!/bin/bash

# 配置参数
NETWORK="192.168.1.0/24"
OUTPUT_DIR="/var/topology"
DATE=$(date +%Y%m%d)

# 创建输出目录
mkdir -p "$OUTPUT_DIR"

# 执行主机发现和OS检测
nmap -sn -O --osscan-guess -T4 "$NETWORK" -oA "$OUTPUT_DIR/topology_discovery_$DATE"

# 提取主机信息并生成简单拓扑图数据
HOSTS_FILE="$OUTPUT_DIR/hosts_$DATE.txt"
rm -f "$HOSTS_FILE"

# 提取活跃主机的IP、MAC和操作系统信息
echo "# IP地址,MAC地址,操作系统" > "$HOSTS_FILE"

# 解析nmap输出
CURRENT_IP=""
CURRENT_MAC=""
CURRENT_OS=""

while read -r line; do
    if [[ $line == *"Nmap scan report for"* ]]; then
        # 保存前一个主机的信息（如果有）
        if [ ! -z "$CURRENT_IP" ]; then
            echo "$CURRENT_IP,$CURRENT_MAC,$CURRENT_OS" >> "$HOSTS_FILE"
            CURRENT_IP=""
            CURRENT_MAC=""
            CURRENT_OS=""
        fi
        # 提取IP地址
        CURRENT_IP=$(echo "$line" | awk '{print $5}')
    elif [[ $line == *"MAC Address:"* ]]; then
        # 提取MAC地址
        CURRENT_MAC=$(echo "$line" | awk '{print $3}')
    elif [[ $line == *"Running:"* ]]; then
        # 提取操作系统信息
        CURRENT_OS=$(echo "$line" | cut -d: -f2- | xargs)
    fi
done < "$OUTPUT_DIR/topology_discovery_$DATE.nmap"

# 保存最后一个主机的信息（如果有）
if [ ! -z "$CURRENT_IP" ]; then
    echo "$CURRENT_IP,$CURRENT_MAC,$CURRENT_OS" >> "$HOSTS_FILE"
fi

# 执行端口扫描以识别服务和设备类型
nmap -p 22,23,80,443,445,3389,8080 -sV -T4 --open -iL <(grep -v '^#' "$HOSTS_FILE" | cut -d, -f1) -oA "$OUTPUT_DIR/services_discovery_$DATE"

# 生成拓扑报告
REPORT_FILE="$OUTPUT_DIR/network_topology_report_$DATE.txt"
echo "网络拓扑发现报告" > "$REPORT_FILE"
echo "生成日期: $(date)" >> "$REPORT_FILE"
echo "扫描网络: $NETWORK" >> "$REPORT_FILE"
echo "================================" >> "$REPORT_FILE"

echo "\n1. 活跃主机列表:" >> "$REPORT_FILE"
cat "$HOSTS_FILE" >> "$REPORT_FILE"

# 识别网络设备类型
echo "\n2. 网络设备类型识别:" >> "$REPORT_FILE"

# 提取开放端口和服务信息
SERVICES_INFO=$(grep -E 'open|running' "$OUTPUT_DIR/services_discovery_$DATE.nmap" | grep -v 'filtered')

# 简单识别设备类型
WEB_SERVERS=$(echo "$SERVICES_INFO" | grep -E 'http|https' | awk '{print $2}' | sort | uniq)
SSH_SERVERS=$(echo "$SERVICES_INFO" | grep 'ssh' | awk '{print $2}' | sort | uniq)
SMB_SERVERS=$(echo "$SERVICES_INFO" | grep 'microsoft-ds' | awk '{print $2}' | sort | uniq)
RDP_SERVERS=$(echo "$SERVICES_INFO" | grep 'ms-wbt-server' | awk '{print $2}' | sort | uniq)

if [ ! -z "$WEB_SERVERS" ]; then
    echo "\nWeb服务器 ($(echo "$WEB_SERVERS" | wc -w)):" >> "$REPORT_FILE"
    echo "$WEB_SERVERS" >> "$REPORT_FILE"
fi

if [ ! -z "$SSH_SERVERS" ]; then
    echo "\nSSH服务器 ($(echo "$SSH_SERVERS" | wc -w)):" >> "$REPORT_FILE"
    echo "$SSH_SERVERS" >> "$REPORT_FILE"
fi

if [ ! -z "$SMB_SERVERS" ]; then
    echo "\nSMB服务器 ($(echo "$SMB_SERVERS" | wc -w)):" >> "$REPORT_FILE"
    echo "$SMB_SERVERS" >> "$REPORT_FILE"
fi

if [ ! -z "$RDP_SERVERS" ]; then
    echo "\nRDP服务器 ($(echo "$RDP_SERVERS" | wc -w)):" >> "$REPORT_FILE"
    echo "$RDP_SERVERS" >> "$REPORT_FILE"
fi

# 生成简单的网络拓扑图数据（可以导入到绘图工具中）
TOPOLOGY_DATA="$OUTPUT_DIR/topology_data_$DATE.csv"
echo "Source,Target,Type" > "$TOPOLOGY_DATA"

# 添加网关连接（假设网关是192.168.1.1）
GATEWAY="192.168.1.1"
grep -v '^#' "$HOSTS_FILE" | cut -d, -f1 | grep -v "$GATEWAY" | while read -r host; do
    echo "$GATEWAY,$host,ETHERNET"
    echo "$host,$GATEWAY,ETHERNET"
done >> "$TOPOLOGY_DATA"

# 添加相同子网内的可能连接（简化版）
# 实际应用中可能需要更复杂的分析

# 输出完成信息
echo "\n网络拓扑发现完成！"
echo "- 主机信息保存在: $HOSTS_FILE"
echo "- 拓扑报告保存在: $REPORT_FILE"
echo "- 拓扑图数据保存在: $TOPOLOGY_DATA"
echo "\n提示: 可以使用Gephi、Visio等工具导入拓扑图数据进行可视化"
```

**功能说明：**
这个脚本使用nmap进行网络拓扑发现，包括识别活跃主机、操作系统类型、开放端口和服务，并生成拓扑报告和可导入绘图工具的拓扑数据。

**使用场景：**
- 企业网络拓扑梳理
- 网络资产识别和管理
- 网络变更跟踪
- 网络架构文档更新
- 网络规划和设计

### 6.3 漏洞评估与管理

nmap结合其脚本引擎，可以进行基本的漏洞评估：

```bash
# 漏洞评估与管理脚本
#!/bin/bash

# 配置参数
TARGETS="192.168.1.0/24"
OUTPUT_DIR="/var/vulnerability_assessment"
DATABASE_FILE="$OUTPUT_DIR/vulnerability_database.csv"
DATE=$(date +%Y%m%d_%H%M%S)
ADMIN_EMAIL="security@example.com"

# 创建输出目录
mkdir -p "$OUTPUT_DIR"

# 初始化漏洞数据库（如果不存在）
if [ ! -f "$DATABASE_FILE" ]; then
    echo "Date,IP Address,Port,Service,Vulnerability,Severity,Description,Remediation" > "$DATABASE_FILE"
fi

# 函数：执行漏洞扫描
function run_vulnerability_scan() {
    echo "[*] 开始漏洞扫描..."
    
    # 第一步：主机发现
    nmap -sn -T4 "$TARGETS" -oA "$OUTPUT_DIR/host_discovery_$DATE"
    
    # 第二步：端口扫描
    nmap -p- -T4 -oA "$OUTPUT_DIR/port_scan_$DATE" -iL <(grep 'Nmap scan report' "$OUTPUT_DIR/host_discovery_$DATE.nmap" | awk '{print $5}')
    
    # 第三步：服务版本检测
    nmap -sV -T4 -oA "$OUTPUT_DIR/version_scan_$DATE" --open -iL <(grep '^[0-9]' "$OUTPUT_DIR/port_scan_$DATE.gnmap" | cut -d' ' -f2)
    
    # 第四步：执行漏洞扫描
    nmap --script=vuln,exploit -T4 -oA "$OUTPUT_DIR/vulnerability_scan_$DATE" --open -iL <(grep '^[0-9]' "$OUTPUT_DIR/port_scan_$DATE.gnmap" | cut -d' ' -f2)
    
    echo "[*] 漏洞扫描完成！"
}

# 函数：分析漏洞扫描结果
function analyze_vulnerability_results() {
    echo "[*] 分析漏洞扫描结果..."
    
    # 解析漏洞扫描结果
    SCAN_RESULT="$OUTPUT_DIR/vulnerability_scan_$DATE.nmap"
    TEMP_VULNS="$OUTPUT_DIR/temp_vulnerabilities_$DATE.txt"
    
    rm -f "$TEMP_VULNS"
    
    # 提取漏洞信息
    CURRENT_IP=""
    CURRENT_PORT=""
    CURRENT_SERVICE=""
    
    while read -r line; do
        # 提取IP地址
        if [[ $line == *"Nmap scan report for"* ]]; then
            CURRENT_IP=$(echo "$line" | awk '{print $5}')
        fi
        
        # 提取端口和服务信息
        if [[ $line == *"open"* ]]; then
            CURRENT_PORT=$(echo "$line" | cut -d'/' -f1)
            CURRENT_SERVICE=$(echo "$line" | awk '{print $3}' | cut -d'/' -f1)
        fi
        
        # 提取漏洞信息
        if [[ $line == *"VULNERABLE"* ]]; then
            VULN_NAME=$(echo "$line" | cut -d: -f2 | xargs)
            
            # 读取漏洞描述（下一行）
            read -r next_line
            VULN_DESC=$(echo "$next_line" | xargs)
            
            # 简单判断漏洞严重性
            if [[ $VULN_NAME == *"critical"* || $VULN_DESC == *"critical"* ]]; then
                SEVERITY="Critical"
            elif [[ $VULN_NAME == *"high"* || $VULN_DESC == *"high"* ]]; then
                SEVERITY="High"
            elif [[ $VULN_NAME == *"medium"* || $VULN_DESC == *"medium"* ]]; then
                SEVERITY="Medium"
            elif [[ $VULN_NAME == *"low"* || $VULN_DESC == *"low"* ]]; then
                SEVERITY="Low"
            else
                SEVERITY="Unknown"
            fi
            
            # 生成修复建议（简单示例）
            REMEDIATION="更新到最新版本或应用安全补丁"
            
            # 保存漏洞信息
            echo "$DATE,$CURRENT_IP,$CURRENT_PORT,$CURRENT_SERVICE,$VULN_NAME,$SEVERITY,$VULN_DESC,$REMEDIATION" >> "$TEMP_VULNS"
        fi
    done < "$SCAN_RESULT"
    
    echo "[*] 漏洞分析完成！"
}

# 函数：更新漏洞数据库
function update_vulnerability_database() {
    echo "[*] 更新漏洞数据库..."
    
    if [ -f "$TEMP_VULNS" ]; then
        cat "$TEMP_VULNS" >> "$DATABASE_FILE"
        echo "[*] 已添加 $(wc -l < "$TEMP_VULNS") 个新漏洞到数据库！"
    else
        echo "[*] 未发现新漏洞！"
    fi
}

# 函数：生成漏洞报告
function generate_vulnerability_report() {
    echo "[*] 生成漏洞报告..."
    
    REPORT_FILE="$OUTPUT_DIR/vulnerability_report_$DATE.txt"
    
    echo "漏洞评估报告" > "$REPORT_FILE"
    echo "生成日期: $(date)" >> "$REPORT_FILE"
    echo "扫描目标: $TARGETS" >> "$REPORT_FILE"
    echo "=======================================" >> "$REPORT_FILE"
    
    # 统计信息
    echo "\n1. 扫描统计"
    echo "\n1. 扫描统计" >> "$REPORT_FILE"
    
    TOTAL_HOSTS=$(grep 'Nmap scan report' "$OUTPUT_DIR/host_discovery_$DATE.nmap" | wc -l)
    echo "发现的主机总数: $TOTAL_HOSTS" >> "$REPORT_FILE"
    
    if [ -f "$TEMP_VULNS" ]; then
        TOTAL_VULNS=$(wc -l < "$TEMP_VULNS")
        CRITICAL_VULNS=$(grep ',Critical,' "$TEMP_VULNS" | wc -l)
        HIGH_VULNS=$(grep ',High,' "$TEMP_VULNS" | wc -l)
        MEDIUM_VULNS=$(grep ',Medium,' "$TEMP_VULNS" | wc -l)
        LOW_VULNS=$(grep ',Low,' "$TEMP_VULNS" | wc -l)
        
        echo "发现的漏洞总数: $TOTAL_VULNS" >> "$REPORT_FILE"
        echo "  - 严重漏洞: $CRITICAL_VULNS" >> "$REPORT_FILE"
        echo "  - 高风险漏洞: $HIGH_VULNS" >> "$REPORT_FILE"
        echo "  - 中风险漏洞: $MEDIUM_VULNS" >> "$REPORT_FILE"
        echo "  - 低风险漏洞: $LOW_VULNS" >> "$REPORT_FILE"
    else
        echo "发现的漏洞总数: 0" >> "$REPORT_FILE"
    fi
    
    # 漏洞详情
    echo "\n2. 漏洞详情" >> "$REPORT_FILE"
    
    if [ -f "$TEMP_VULNS" ]; then
        # 按严重性排序显示漏洞
        echo "\n2.1 严重漏洞:" >> "$REPORT_FILE"
        grep ',Critical,' "$TEMP_VULNS" | while IFS=, read -r date ip port service vuln severity desc remediation; do
            echo "- IP: $ip, 端口: $port, 服务: $service, 漏洞: $vuln" >> "$REPORT_FILE"
            echo "  描述: $desc" >> "$REPORT_FILE"
            echo "  修复建议: $remediation" >> "$REPORT_FILE"
        done
        
        echo "\n2.2 高风险漏洞:" >> "$REPORT_FILE"
        grep ',High,' "$TEMP_VULNS" | while IFS=, read -r date ip port service vuln severity desc remediation; do
            echo "- IP: $ip, 端口: $port, 服务: $service, 漏洞: $vuln" >> "$REPORT_FILE"
            echo "  描述: $desc" >> "$REPORT_FILE"
            echo "  修复建议: $remediation" >> "$REPORT_FILE"
        done
    else
        echo "未发现漏洞！" >> "$REPORT_FILE"
    fi
    
    # 修复建议摘要
    echo "\n3. 修复建议摘要" >> "$REPORT_FILE"
    echo "- 定期更新系统和软件到最新版本"
    echo "- 及时应用安全补丁"
    echo "- 关闭不必要的服务和端口"
    echo "- 实施最小权限原则"
    echo "- 加强网络访问控制"
    echo "- 定期进行漏洞扫描和安全审计"
    
    echo "[*] 漏洞报告生成完成: $REPORT_FILE"
}

# 函数：发送漏洞告警
function send_vulnerability_alert() {
    echo "[*] 发送漏洞告警..."
    
    if [ -f "$TEMP_VULNS" ]; then
        CRITICAL_VULNS=$(grep ',Critical,' "$TEMP_VULNS" | wc -l)
        HIGH_VULNS=$(grep ',High,' "$TEMP_VULNS" | wc -l)
        
        if [ $CRITICAL_VULNS -gt 0 ] || [ $HIGH_VULNS -gt 0 ]; then
            echo "发现严重和高风险漏洞，已发送告警邮件！"
            # echo "漏洞扫描发现 $CRITICAL_VULNS 个严重漏洞和 $HIGH_VULNS 个高风险漏洞，请及时处理！" | mail -s "漏洞告警 - $DATE" "$ADMIN_EMAIL"
        else
            echo "未发现严重或高风险漏洞，无需发送告警！"
        fi
    fi
    
    echo "[*] 漏洞告警处理完成！"
}

# 主函数
function main() {
    echo "====== 漏洞评估与管理开始 ======"
    run_vulnerability_scan
    analyze_vulnerability_results
    update_vulnerability_database
    generate_vulnerability_report
    send_vulnerability_alert
    echo "====== 漏洞评估与管理完成 ======"
}

# 执行主函数
main
```

**功能说明：**
这个脚本实现了完整的漏洞评估流程，包括漏洞扫描、结果分析、数据库更新、报告生成和告警发送，适用于企业网络的漏洞管理工作。

**使用场景：**
- 定期漏洞扫描和评估
- 安全漏洞跟踪和管理
- 漏洞修复优先级确定
- 安全合规性验证
- 安全事件响应准备

### 6.4 渗透测试辅助工具

nmap是渗透测试过程中的重要工具，可以帮助识别攻击面和潜在的漏洞：

```bash
# 渗透测试前的信息收集脚本
#!/bin/bash

# 配置参数
TARGET=$1
OUTPUT_DIR="/var/pentest/"$TARGET
DATE=$(date +%Y%m%d_%H%M%S)

# 检查参数
if [ -z "$TARGET" ]; then
    echo "用法: $0 <目标IP或域名>"
    exit 1
fi

# 创建输出目录
mkdir -p "$OUTPUT_DIR"

# 函数：执行DNS信息收集
function dns_enum() {
    echo "[*] 开始DNS信息收集..."
    nmap -p 53 --script=dns-brute,dns-nsid,dns-cache-snoop,dns-check-zone -T4 "$TARGET" -oA "$OUTPUT_DIR/dns_enum_$DATE"
    echo "[*] DNS信息收集完成！"
}

# 函数：执行主机发现
function host_discovery() {
    echo "[*] 开始主机发现..."
    # 如果目标是域名，先解析IP
    if [[ $TARGET != *.*.*.* ]]; then
        TARGET_IP=$(nslookup "$TARGET" | grep -A1 'Name:' | tail -1 | awk '{print $2}')
        if [ ! -z "$TARGET_IP" ]; then
            # 发现同一网段的主机
            NETWORK=$(echo "$TARGET_IP" | cut -d'.' -f1-3).0/24
            nmap -sn -T4 "$NETWORK" -oA "$OUTPUT_DIR/network_discovery_$DATE"
        fi
    else
        # 发现目标所在网段的主机
        NETWORK=$(echo "$TARGET" | cut -d'.' -f1-3).0/24
        nmap -sn -T4 "$NETWORK" -oA "$OUTPUT_DIR/network_discovery_$DATE"
    fi
    echo "[*] 主机发现完成！"
}

# 函数：执行全面端口扫描
function full_port_scan() {
    echo "[*] 开始全面端口扫描..."
    nmap -p- -T4 -oA "$OUTPUT_DIR/full_port_scan_$DATE" "$TARGET"
    echo "[*] 全面端口扫描完成！"
}

# 函数：执行服务版本检测
function service_version_detection() {
    echo "[*] 开始服务版本检测..."
    nmap -sV -O --osscan-guess -T4 -oA "$OUTPUT_DIR/service_version_detection_$DATE" "$TARGET"
    echo "[*] 服务版本检测完成！"
}

# 函数：执行漏洞扫描
function vulnerability_scanning() {
    echo "[*] 开始漏洞扫描..."
    # 基本漏洞扫描
    nmap --script=vuln -T4 -oA "$OUTPUT_DIR/vulnerability_scan_$DATE" "$TARGET"
    
    # 针对Web服务的漏洞扫描
    WEB_PORTS=$(grep -E '80/tcp|443/tcp|8080/tcp|8443/tcp' "$OUTPUT_DIR/full_port_scan_$DATE.nmap" | grep 'open' | cut -d'/' -f1)
    if [ ! -z "$WEB_PORTS" ]; then
        for port in $WEB_PORTS; do
            nmap --script=http-* -p $port -T4 -oA "$OUTPUT_DIR/web_vulnerability_scan_${DATE}_port$port" "$TARGET"
        done
    fi
    
    # 针对SMB服务的漏洞扫描
    SMB_PORTS=$(grep -E '445/tcp|139/tcp' "$OUTPUT_DIR/full_port_scan_$DATE.nmap" | grep 'open' | cut -d'/' -f1)
    if [ ! -z "$SMB_PORTS" ]; then
        for port in $SMB_PORTS; do
            nmap --script=smb-* -p $port -T4 -oA "$OUTPUT_DIR/smb_vulnerability_scan_${DATE}_port$port" "$TARGET"
        done
    fi
    
    echo "[*] 漏洞扫描完成！"
}

# 函数：执行弱密码检测
function brute_force_test() {
    echo "[*] 开始弱密码检测..."
    
    # SSH弱密码检测
    SSH_PORTS=$(grep 'ssh' "$OUTPUT_DIR/full_port_scan_$DATE.nmap" | grep 'open' | cut -d'/' -f1)
    if [ ! -z "$SSH_PORTS" ]; then
        for port in $SSH_PORTS; do
            nmap --script=ssh-brute -p $port -T4 -oA "$OUTPUT_DIR/ssh_brute_${DATE}_port$port" "$TARGET"
        done
    fi
    
    # FTP弱密码检测
    FTP_PORTS=$(grep 'ftp' "$OUTPUT_DIR/full_port_scan_$DATE.nmap" | grep 'open' | cut -d'/' -f1)
    if [ ! -z "$FTP_PORTS" ]; then
        for port in $FTP_PORTS; do
            nmap --script=ftp-brute -p $port -T4 -oA "$OUTPUT_DIR/ftp_brute_${DATE}_port$port" "$TARGET"
        done
    fi
    
    # HTTP认证弱密码检测
    HTTP_AUTH_PORTS=$(grep -E 'http.*auth' "$OUTPUT_DIR/service_version_detection_$DATE.nmap" | grep 'open' | cut -d'/' -f1)
    if [ ! -z "$HTTP_AUTH_PORTS" ]; then
        for port in $HTTP_AUTH_PORTS; do
            nmap --script=http-brute -p $port -T4 -oA "$OUTPUT_DIR/http_brute_${DATE}_port$port" "$TARGET"
        done
    fi
    
    echo "[*] 弱密码检测完成！"
}

# 函数：生成信息收集报告
function generate_report() {
    echo "[*] 生成信息收集报告..."
    
    REPORT_FILE="$OUTPUT_DIR/information_gathering_report_$DATE.txt"
    
    echo "渗透测试信息收集报告" > "$REPORT_FILE"
    echo "生成日期: $(date)" >> "$REPORT_FILE"
    echo "目标: $TARGET" >> "$REPORT_FILE"
    echo "================================" >> "$REPORT_FILE"
    
    # 基本信息
    echo "\n1. 基本信息" >> "$REPORT_FILE"
    if [[ $TARGET != *.*.*.* ]]; then
        echo "域名: $TARGET" >> "$REPORT_FILE"
        TARGET_IP=$(nslookup "$TARGET" | grep -A1 'Name:' | tail -1 | awk '{print $2}')
        if [ ! -z "$TARGET_IP" ]; then
            echo "IP地址: $TARGET_IP" >> "$REPORT_FILE"
        fi
    else
        echo "IP地址: $TARGET" >> "$REPORT_FILE"
        REVERSE_DNS=$(nslookup "$TARGET" | grep 'name =' | awk '{print $4}')
        if [ ! -z "$REVERSE_DNS" ]; then
            echo "反向DNS: $REVERSE_DNS" >> "$REPORT_FILE"
        fi
    fi
    
    # 开放端口和服务
    echo "\n2. 开放端口和服务" >> "$REPORT_FILE"
    grep -E '^[0-9]' "$OUTPUT_DIR/full_port_scan_$DATE.gnmap" | cut -d' ' -f2- >> "$REPORT_FILE"
    
    # 操作系统信息
    echo "\n3. 操作系统信息" >> "$REPORT_FILE"
    grep -A 3 'Running:' "$OUTPUT_DIR/service_version_detection_$DATE.nmap" | grep -v '^--$' >> "$REPORT_FILE"
    
    # 发现的漏洞
    echo "\n4. 发现的漏洞" >> "$REPORT_FILE"
    grep -A 3 'VULNERABLE' "$OUTPUT_DIR/vulnerability_scan_$DATE.nmap" | grep -v '^--$' | head -20 >> "$REPORT_FILE"
    
    # 攻击面总结
    echo "\n5. 攻击面总结" >> "$REPORT_FILE"
    echo "- 开放端口数量: $(grep -c '/tcp' "$OUTPUT_DIR/full_port_scan_$DATE.nmap" | grep -v 'filtered')" >> "$REPORT_FILE"
    echo "- 发现的漏洞数量: $(grep -c 'VULNERABLE' "$OUTPUT_DIR/vulnerability_scan_$DATE.nmap")" >> "$REPORT_FILE"
    
    # 推荐的渗透测试方向
    echo "\n6. 推荐的渗透测试方向" >> "$REPORT_FILE"
    
    # 根据发现的服务推荐测试方向
    if grep 'ssh' "$OUTPUT_DIR/full_port_scan_$DATE.nmap" | grep -q 'open'; then
        echo "- SSH服务：尝试弱密码、版本漏洞利用"
    fi
    
    if grep -E 'http|https' "$OUTPUT_DIR/full_port_scan_$DATE.nmap" | grep -q 'open'; then
        echo "- Web服务：尝试目录遍历、SQL注入、XSS、CSRF等Web漏洞"
    fi
    
    if grep -E 'smb|microsoft-ds' "$OUTPUT_DIR/full_port_scan_$DATE.nmap" | grep -q 'open'; then
        echo "- SMB服务：尝试SMB漏洞利用、枚举共享、弱密码"
    fi
    
    echo "\n详细扫描结果请查看目录: $OUTPUT_DIR" >> "$REPORT_FILE"
    
    echo "[*] 报告生成完成: $REPORT_FILE"
}

# 主函数
function main() {
    echo "====== 渗透测试信息收集开始 ======"
    echo "目标: $TARGET"
    echo "输出目录: $OUTPUT_DIR"
    
    dns_enum
    host_discovery
    full_port_scan
    service_version_detection
    vulnerability_scanning
    brute_force_test
    generate_report
    
    echo "====== 渗透测试信息收集完成 ======"
    echo "信息收集报告已生成，请查看: $OUTPUT_DIR/information_gathering_report_$DATE.txt"
}

# 执行主函数
main
```

**功能说明：**