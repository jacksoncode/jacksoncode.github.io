# 网络连接问题

## 1 网络配置问题

### 1.1 网络接口配置

#### 1.1.1 网络接口状态检查

```bash
#!/bin/bash
# 网络接口状态检查

# 查看网络接口
ip addr show

# 查看网络接口状态
ip link show

# 查看路由表
ip route show

# 网络接口诊断脚本
NETWORK_INTERFACE_DIAG() {
    local interface="$1"
    
    echo "=== 网络接口诊断 ==="
    echo "接口: ${interface:-所有接口}"
    echo "检查时间: $(date)"
    echo ""
    
    # 检查网络接口
    echo "1. 网络接口状态:"
    if [ -n "$interface" ]; then
        ip link show "$interface" 2>/dev/null || {
            echo "❌ 接口 $interface 不存在"
            return 1
        }
    else
        ip link show | grep -E "^[0-9]+:" | head -10
    fi
    echo ""
    
    # 检查IP地址
    echo "2. IP地址配置:"
    if [ -n "$interface" ]; then
        ip addr show "$interface" 2>/dev/null | grep -E "inet[6]? " || echo "❌ 无IP地址配置"
    else
        ip addr show | grep -E "inet[6]? " | head -5
    fi
    echo ""
    
    # 检查路由
    echo "3. 路由表:"
    ip route show | head -5
    echo ""
    
    # 检查DNS
    echo "4. DNS配置:"
    if [ -f /etc/resolv.conf ]; then
        grep "nameserver" /etc/resolv.conf || echo "❌ 无DNS配置"
    else
        echo "❌ /etc/resolv.conf 不存在"
    fi
    echo ""
    
    # 网络连通性测试
    echo "5. 网络连通性测试:"
    if ping -c 1 8.8.8.8 >/dev/null 2>&1; then
        echo "✅ 外网连接正常"
    else
        echo "❌ 外网连接失败"
    fi
    
    if ping -c 1 127.0.0.1 >/dev/null 2>&1; then
        echo "✅ 本地回环正常"
    else
        echo "❌ 本地回环失败"
    fi
}

# 网络接口配置修复
NETWORK_INTERFACE_FIX() {
    local interface="$1"
    local ip_addr="$2"
    local gateway="$3"
    
    if [ -z "$interface" ]; then
        echo "用法: $0 <接口> [IP地址] [网关]"
        echo "示例: $0 eth0 192.168.1.100/24 192.168.1.1"
        return 1
    fi
    
    echo "=== 网络接口配置修复 ==="
    echo "接口: $interface"
    echo "IP地址: $ip_addr"
    echo "网关: $gateway"
    echo ""
    
    # 检查接口是否存在
    if ! ip link show "$interface" >/dev/null 2>&1; then
        echo "❌ 接口 $interface 不存在"
        echo "可用接口:"
        ip link show | grep -E "^[0-9]+:" | awk '{print $2}' | sed 's/://'
        return 1
    fi
    
    # 启用接口
    echo "启用接口..."
    sudo ip link set "$interface" up
    
    if [ $? -ne 0 ]; then
        echo "❌ 无法启用接口"
        return 1
    fi
    
    # 配置IP地址
    if [ -n "$ip_addr" ]; then
        echo "配置IP地址..."
        sudo ip addr flush dev "$interface"
        sudo ip addr add "$ip_addr" dev "$interface"
        
        if [ $? -eq 0 ]; then
            echo "✅ IP地址配置成功"
        else
            echo "❌ IP地址配置失败"
            return 1
        fi
    fi
    
    # 配置默认网关
    if [ -n "$gateway" ]; then
        echo "配置默认网关..."
        sudo ip route add default via "$gateway"
        
        if [ $? -eq 0 ]; then
            echo "✅ 网关配置成功"
        else
            echo "❌ 网关配置失败"
        fi
    fi
    
    # 验证配置
    echo ""
    echo "验证配置:"
    ip addr show "$interface"
    ip route show | grep default
}

# 使用示例
# NETWORK_INTERFACE_DIAG eth0
# NETWORK_INTERFACE_FIX eth0 192.168.1.100/24 192.168.1.1
```

#### 1.1.2 DHCP客户端问题

```bash
#!/bin/bash
# DHCP客户端问题排查

# 检查DHCP客户端状态
DHCP_CLIENT_STATUS() {
    local interface="$1"
    
    echo "=== DHCP客户端状态 ==="
    echo "接口: ${interface:-所有接口}"
    echo ""
    
    # 检查DHCP客户端进程
    echo "1. DHCP客户端进程:"
    if pgrep -f dhcp >/dev/null 2>&1; then
        echo "✅ DHCP客户端运行中"
        ps aux | grep -E "(dhcp|dhclient)" | grep -v grep
    else
        echo "❌ DHCP客户端未运行"
    fi
    echo ""
    
    # 检查DHCP租约
    echo "2. DHCP租约信息:"
    if [ -f /var/lib/dhcp/dhclient.leases ]; then
        echo "租约文件: /var/lib/dhcp/dhclient.leases"
        tail -5 /var/lib/dhcp/dhclient.leases 2>/dev/null | grep -E "(lease|interface)" || echo "无有效租约"
    elif [ -f /var/lib/dhclient/dhclient.leases ]; then
        echo "租约文件: /var/lib/dhclient/dhclient.leases"
        tail -5 /var/lib/dhclient/dhclient.leases 2>/dev/null | grep -E "(lease|interface)" || echo "无有效租约"
    else
        echo "❌ 未找到DHCP租约文件"
    fi
    echo ""
    
    # 检查网络配置
    if [ -n "$interface" ]; then
        echo "3. 接口 $interface 配置:"
        ip addr show "$interface" 2>/dev/null | grep -E "inet " || echo "❌ 无IP地址"
    fi
}

# DHCP客户端修复
DHCP_CLIENT_FIX() {
    local interface="$1"
    
    if [ -z "$interface" ]; then
        echo "用法: $0 <接口>"
        echo "示例: $0 eth0"
        return 1
    fi
    
    echo "=== DHCP客户端修复 ==="
    echo "接口: $interface"
    echo ""
    
    # 停止现有DHCP客户端
    echo "停止现有DHCP客户端..."
    sudo pkill -f "dhclient.*$interface" 2>/dev/null || true
    
    # 释放IP地址
    echo "释放IP地址..."
    sudo dhclient -r "$interface" 2>/dev/null || true
    
    # 清除租约
    echo "清除租约..."
    sudo rm -f /var/lib/dhcp/dhclient.*"$interface"*.leases 2>/dev/null || true
    sudo rm -f /var/lib/dhclient/dhclient.*"$interface"*.leases 2>/dev/null || true
    
    # 重新获取IP地址
    echo "重新获取IP地址..."
    sudo dhclient "$interface"
    
    if [ $? -eq 0 ]; then
        echo "✅ DHCP客户端修复成功"
        echo "新配置:"
        ip addr show "$interface" | grep -E "inet "
    else
        echo "❌ DHCP客户端修复失败"
        return 1
    fi
}

# 使用示例
# DHCP_CLIENT_STATUS eth0
# DHCP_CLIENT_FIX eth0
```

### 1.2 DNS解析问题

#### 1.2.1 DNS诊断工具

```bash
#!/bin/bash
# DNS诊断工具

# DNS解析测试
DNS_DIAGNOSTIC() {
    local domain="${1:-google.com}"
    
    echo "=== DNS诊断 ==="
    echo "域名: $domain"
    echo "检查时间: $(date)"
    echo ""
    
    # 检查DNS配置
    echo "1. DNS配置:"
    if [ -f /etc/resolv.conf ]; then
        echo "DNS服务器:"
        grep "nameserver" /etc/resolv.conf || echo "❌ 无DNS配置"
        echo ""
        echo "搜索域:"
        grep "search" /etc/resolv.conf || echo "无搜索域配置"
    else
        echo "❌ /etc/resolv.conf 不存在"
    fi
    echo ""
    
    # DNS解析测试
    echo "2. DNS解析测试:"
    echo "使用系统DNS:"
    if nslookup "$domain" >/dev/null 2>&1; then
        nslookup "$domain" 2>/dev/null | grep -A5 "Name:" | head -5
    else
        echo "❌ DNS解析失败"
    fi
    echo ""
    
    # 测试公共DNS
    echo "3. 公共DNS测试:"
    local public_dns=("8.8.8.8" "1.1.1.1" "9.9.9.9")
    
    for dns in "${public_dns[@]}"; do
        echo "DNS $dns:"
        if nslookup "$domain" "$dns" >/dev/null 2>&1; then
            nslookup "$domain" "$dns" 2>/dev/null | grep -E "(Address|Name):" | tail -2
        else
            echo "❌ 无法连接"
        fi
    done
    echo ""
    
    # 检查DNS缓存
    echo "4. DNS缓存:"
    if command -v systemd-resolve >/dev/null 2>&1; then
        echo "systemd-resolve 缓存:"
        systemd-resolve --statistics 2>/dev/null | grep -E "(Cache|Transactions)" || echo "无缓存信息"
    elif command -v nscd >/dev/null 2>&1; then
        echo "NSCD 缓存:"
        sudo nscd -g 2>/dev/null | grep -E "(hosts cache|hosts hits)" || echo "无缓存信息"
    else
        echo "未找到DNS缓存服务"
    fi
}

# DNS缓存清理
DNS_CACHE_FLUSH() {
    echo "=== DNS缓存清理 ==="
    echo ""
    
    # systemd-resolve
    if command -v systemd-resolve >/dev/null 2>&1; then
        echo "清理systemd-resolve缓存..."
        sudo systemd-resolve --flush-caches
        echo "✅ systemd-resolve缓存已清理"
    fi
    
    # NSCD
    if command -v nscd >/dev/null 2>&1; then
        echo "重启NSCD服务..."
        sudo systemctl restart nscd
        echo "✅ NSCD缓存已清理"
    fi
    
    # dnsmasq
    if command -v dnsmasq >/dev/null 2>&1; then
        echo "重启dnsmasq服务..."
        sudo systemctl restart dnsmasq
        echo "✅ dnsmasq缓存已清理"
    fi
    
    # 清理本地DNS缓存文件
    echo "清理本地DNS缓存文件..."
    sudo rm -f /var/cache/nscd/hosts 2>/dev/null || true
    sudo rm -f /var/lib/dhcp/dhclient.leases 2>/dev/null || true
    
    echo "✅ DNS缓存清理完成"
}

# DNS配置修复
DNS_CONFIG_FIX() {
    local primary_dns="${1:-8.8.8.8}"
    local secondary_dns="${2:-1.1.1.1}"
    
    echo "=== DNS配置修复 ==="
    echo "主DNS: $primary_dns"
    echo "备DNS: $secondary_dns"
    echo ""
    
    # 备份现有配置
    if [ -f /etc/resolv.conf ]; then
        sudo cp /etc/resolv.conf /etc/resolv.conf.backup.$(date +%Y%m%d)
        echo "✅ 已备份现有配置"
    fi
    
    # 创建新的DNS配置
    echo "创建新的DNS配置..."
    cat << EOF | sudo tee /etc/resolv.conf
# Generated by NetworkManager
nameserver $primary_dns
nameserver $secondary_dns
search localdomain
EOF
    
    if [ $? -eq 0 ]; then
        echo "✅ DNS配置已更新"
        echo "新配置:"
        cat /etc/resolv.conf
    else
        echo "❌ DNS配置更新失败"
        return 1
    fi
    
    # 测试新配置
    echo ""
    echo "测试新配置..."
    if nslookup google.com >/dev/null 2>&1; then
        echo "✅ DNS配置测试通过"
    else
        echo "❌ DNS配置测试失败"
        return 1
    fi
}

# 使用示例
# DNS_DIAGNOSTIC example.com
# DNS_CACHE_FLUSH
# DNS_CONFIG_FIX 8.8.8.8 1.1.1.1
```

## 2 网络连接故障

### 2.1 网络连通性测试

#### 2.1.1 分层网络诊断

```bash
#!/bin/bash
# 分层网络诊断

# OSI模型分层诊断
LAYER_DIAGNOSTIC() {
    local target="${1:-8.8.8.8}"
    
    echo "=== 分层网络诊断 ==="
    echo "目标: $target"
    echo "诊断时间: $(date)"
    echo ""
    
    # 物理层 - 检查接口状态
    echo "1. 物理层 (Layer 1):"
    echo "检查网络接口状态..."
    ip link show | grep -E "^[0-9]+:" | while read line; do
        if echo "$line" | grep -q "state UP"; then
            echo "✅ $line"
        else
            echo "❌ $line"
        fi
    done
    echo ""
    
    # 数据链路层 - ARP检查
    echo "2. 数据链路层 (Layer 2):"
    echo "ARP表检查..."
    ip neigh show | head -5
    echo ""
    
    # 网络层 - IP连通性
    echo "3. 网络层 (Layer 3):"
    echo "IP配置检查..."
    ip addr show | grep -E "inet " | head -3
    echo ""
    echo "路由表检查..."
    ip route show | head -3
    echo ""
    
    # 测试网络层连通性
    echo "网络层连通性测试..."
    if ping -c 1 -W 2 "$target" >/dev/null 2>&1; then
        echo "✅ 网络层连通性正常"
        ping -c 3 "$target" | tail -2
    else
        echo "❌ 网络层连通性失败"
    fi
    echo ""
    
    # 传输层 - 端口测试
    echo "4. 传输层 (Layer 4):"
    echo "常用端口测试..."
    local ports=("80" "443" "22" "53")
    
    for port in "${ports[@]}"; do
        if timeout 2 bash -c "echo >/dev/tcp/$target/$port" 2>/dev/null; then
            echo "✅ 端口 $port 开放"
        else
            echo "❌ 端口 $port 关闭或超时"
        fi
    done
    echo ""
    
    # 应用层 - DNS测试
    echo "5. 应用层 (Layer 7):"
    echo "DNS解析测试..."
    if nslookup google.com >/dev/null 2>&1; then
        echo "✅ DNS解析正常"
    else
        echo "❌ DNS解析失败"
    fi
    
    # HTTP测试
    echo "HTTP连接测试..."
    if curl -s -I http://httpbin.org/status/200 | head -1 | grep -q "200"; then
        echo "✅ HTTP连接正常"
    else
        echo "❌ HTTP连接失败"
    fi
}

# 网络路径追踪
NETWORK_PATH_TRACE() {
    local target="$1"
    
    if [ -z "$target" ]; then
        echo "用法: $0 <目标IP或域名>"
        return 1
    fi
    
    echo "=== 网络路径追踪 ==="
    echo "目标: $target"
    echo ""
    
    # traceroute
    echo "1. traceroute 结果:"
    if command -v traceroute >/dev/null 2>&1; then
        traceroute -n -m 15 "$target" 2>/dev/null | head -10
    else
        echo "traceroute 命令未安装"
    fi
    echo ""
    
    # mtr
    echo "2. mtr 结果 (5次):"
    if command -v mtr >/dev/null 2>&1; then
        mtr -r -c 5 -n "$target" 2>/dev/null | tail -10
    else
        echo "mtr 命令未安装"
    fi
    echo ""
    
    # 检查网络跳数
    echo "3. 网络跳数分析:"
    local hops=$(traceroute -n "$target" 2>/dev/null | wc -l)
    echo "总跳数: $hops"
    
    if [ "$hops" -gt 20 ]; then
        echo "⚠️  跳数过多，可能存在网络问题"
    elif [ "$hops" -gt 10 ]; then
        echo "✅ 跳数正常"
    else
        echo "✅ 跳数较少，网络路径较短"
    fi
}

# 使用示例
# LAYER_DIAGNOSTIC google.com
# NETWORK_PATH_TRACE 8.8.8.8
```

#### 2.1.2 网络性能测试

```bash
#!/bin/bash
# 网络性能测试

# 网络速度测试
NETWORK_SPEED_TEST() {
    local server="${1:-speedtest.selectel.ru}"
    
    echo "=== 网络速度测试 ==="
    echo "服务器: $server"
    echo "测试时间: $(date)"
    echo ""
    
    # 检查speedtest-cli
    if ! command -v speedtest-cli >/dev/null 2>&1; then
        echo "安装speedtest-cli..."
        if command -v pip3 >/dev/null 2>&1; then
            pip3 install speedtest-cli
        else
            echo "❌ 无法安装speedtest-cli"
            return 1
        fi
    fi
    
    # 运行速度测试
    echo "运行速度测试..."
    speedtest-cli --server "$server" --simple
    
    if [ $? -eq 0 ]; then
        echo "✅ 速度测试完成"
    else
        echo "❌ 速度测试失败"
    fi
}

# 网络延迟测试
NETWORK_LATENCY_TEST() {
    local target="${1:-8.8.8.8}"
    local count="${2:-10}"
    
    echo "=== 网络延迟测试 ==="
    echo "目标: $target"
    echo "测试次数: $count"
    echo ""
    
    # ping测试
    echo "1. ICMP延迟测试:"
    ping -c "$count" "$target" | tail -3
    echo ""
    
    # TCP延迟测试
    echo "2. TCP延迟测试 (端口80):"
    local start_time=$(date +%s%N)
    if timeout 5 bash -c "echo >/dev/tcp/$target/80" 2>/dev/null; then
        local end_time=$(date +%s%N)
        local latency=$(( (end_time - start_time) / 1000000 ))
        echo "TCP连接延迟: ${latency}ms"
    else
        echo "❌ TCP连接失败或超时"
    fi
    echo ""
    
    # DNS延迟测试
    echo "3. DNS延迟测试:"
    local dns_start=$(date +%s%N)
    if nslookup google.com "$target" >/dev/null 2>&1; then
        local dns_end=$(date +%s%N)
        local dns_latency=$(( (dns_end - dns_start) / 1000000 ))
        echo "DNS查询延迟: ${dns_latency}ms"
    else
        echo "❌ DNS查询失败"
    fi
}

# 网络带宽测试
NETWORK_BANDWIDTH_TEST() {
    local target="$1"
    local port="${2:-5201}"
    
    if [ -z "$target" ]; then
        echo "用法: $0 <目标IP> [端口]"
        echo "示例: $0 192.168.1.100"
        return 1
    fi
    
    echo "=== 网络带宽测试 ==="
    echo "目标: $target:$port"
    echo ""
    
    # 检查iperf3
    if ! command -v iperf3 >/dev/null 2>&1; then
        echo "安装iperf3..."
        sudo apt update && sudo apt install -y iperf3
    fi
    
    # 测试上传带宽
    echo "1. 上传带宽测试 (10秒):"
    iperf3 -c "$target" -p "$port" -t 10 -f m
    echo ""
    
    # 测试下载带宽
    echo "2. 下载带宽测试 (10秒):"
    iperf3 -c "$target" -p "$port" -t 10 -R -f m
    echo ""
    
    # 测试双向带宽
    echo "3. 双向带宽测试 (10秒):"
    iperf3 -c "$target" -p "$port" -t 10 --bidir -f m
}

# 使用示例
# NETWORK_SPEED_TEST
# NETWORK_LATENCY_TEST 8.8.8.8 20
# NETWORK_BANDWIDTH_TEST 192.168.1.100
```

### 2.2 网络服务问题

#### 2.2.1 端口连接问题

```bash
#!/bin/bash
# 端口连接问题排查

# 端口状态检查
PORT_STATUS_CHECK() {
    local target="$1"
    local port="$2"
    
    if [ -z "$target" ] || [ -z "$port" ]; then
        echo "用法: $0 <目标IP> <端口>"
        return 1
    fi
    
    echo "=== 端口状态检查 ==="
    echo "目标: $target:$port"
    echo "检查时间: $(date)"
    echo ""
    
    # 检查本地端口监听
    echo "1. 本地端口监听状态:"
    if command -v netstat >/dev/null 2>&1; then
        netstat -tuln | grep ":$port " || echo "❌ 本地未监听端口 $port"
    elif command -v ss >/dev/null 2>&1; then
        ss -tuln | grep ":$port " || echo "❌ 本地未监听端口 $port"
    else
        echo "未找到netstat或ss命令"
    fi
    echo ""
    
    # 检查远程端口可达性
    echo "2. 远程端口可达性:"
    local start_time=$(date +%s%N)
    
    if timeout 5 bash -c "echo >/dev/tcp/$target/$port" 2>/dev/null; then
        local end_time=$(date +%s%N)
        local connect_time=$(( (end_time - start_time) / 1000000 ))
        echo "✅ 端口 $port 可达 (连接时间: ${connect_time}ms)"
    else
        echo "❌ 端口 $port 不可达或超时"
    fi
    echo ""
    
    # 使用nmap进行详细扫描
    if command -v nmap >/dev/null 2>&1; then
        echo "3. nmap端口扫描:"
        nmap -p "$port" --host-timeout 10s "$target" 2>/dev/null | grep -E "(PORT|STATE|SERVICE)" | tail -3
    fi
    echo ""
    
    # 检查防火墙
    echo "4. 防火墙状态:"
    if sudo ufw status | grep -q "Status: active"; then
        echo "防火墙状态: 活跃"
        sudo ufw status numbered | grep "$port" || echo "端口 $port 未在防火墙规则中"
    else
        echo "防火墙状态: 不活跃"
    fi
}

# 端口连接故障修复
PORT_CONNECTION_FIX() {
    local target="$1"
    local port="$2"
    
    if [ -z "$target" ] || [ -z "$port" ]; then
        echo "用法: $0 <目标IP> <端口>"
        return 1
    fi
    
    echo "=== 端口连接故障修复 ==="
    echo "目标: $target:$port"
    echo ""
    
    # 检查服务是否运行
    echo "1. 检查服务状态..."
    local service_name=$(sudo lsof -i ":$port" 2>/dev/null | tail -1 | awk '{print $1}' || echo "unknown")
    echo "监听服务: $service_name"
    
    # 检查防火墙规则
    echo "2. 检查防火墙规则..."
    if sudo ufw status | grep -q "Status: active"; then
        if sudo ufw status | grep -q "$port"; then
            echo "✅ 端口 $port 已在防火墙规则中"
        else
            echo "添加防火墙规则..."
            sudo ufw allow "$port/tcp"
            echo "✅ 防火墙规则已添加"
        fi
    else
        echo "防火墙未启用"
    fi
    
    # 检查SELinux
    echo "3. 检查SELinux..."
    if command -v getenforce >/dev/null 2>&1; then
        local selinux_status=$(getenforce)
        echo "SELinux状态: $selinux_status"
        if [ "$selinux_status" = "Enforcing" ]; then
            echo "检查SELinux端口策略..."
            sudo semanage port -l | grep "$port" || echo "端口 $port 未在SELinux策略中"
        fi
    else
        echo "SELinux未安装"
    fi
    
    # 测试连接
    echo "4. 测试连接..."
    if timeout 3 bash -c "echo >/dev/tcp/$target/$port" 2>/dev/null; then
        echo "✅ 端口连接成功"
    else
        echo "❌ 端口连接仍然失败"
        echo "建议检查:"
        echo "  - 服务是否正常运行"
        echo "  - 网络配置是否正确"
        echo "  - 是否有其他防火墙软件"
    fi
}

# 常用服务端口检查
COMMON_SERVICES_CHECK() {
    local target="${1:-localhost}"
    
    echo "=== 常用服务端口检查 ==="
    echo "目标: $target"
    echo ""
    
    # 常用服务端口
    declare -A services=(
        ["SSH"]=22
        ["HTTP"]=80
        ["HTTPS"]=443
        ["FTP"]=21
        ["SMTP"]=25
        ["DNS"]=53
        ["MySQL"]=3306
        ["PostgreSQL"]=5432
        ["Redis"]=6379
        ["MongoDB"]=27017
    )
    
    echo "服务端口状态:"
    for service in "${!services[@]}"; do
        local port="${services[$service]}"
        if timeout 2 bash -c "echo >/dev/tcp/$target/$port" 2>/dev/null; then
            echo "✅ $service ($port): 开放"
        else
            echo "❌ $service ($port): 关闭"
        fi
    done
}

# 使用示例
# PORT_STATUS_CHECK 192.168.1.100 80
# PORT_CONNECTION_FIX 192.168.1.100 3306
# COMMON_SERVICES_CHECK localhost
```

#### 2.2.2 网络服务重启

```bash
#!/bin/bash
# 网络服务重启与恢复

# 网络服务状态检查
NETWORK_SERVICES_STATUS() {
    echo "=== 网络服务状态 ==="
    echo "检查时间: $(date)"
    echo ""
    
    # 常用网络服务
    local services=(
        "NetworkManager"
        "networking"
        "systemd-networkd"
        "systemd-resolved"
        "dnsmasq"
        "nscd"
        "firewalld"
        "ufw"
    )
    
    for service in "${services[@]}"; do
        if systemctl list-unit-files | grep -q "$service"; then
            local status=$(systemctl is-active "$service" 2>/dev/null || echo "unknown")
            local enabled=$(systemctl is-enabled "$service" 2>/dev/null || echo "unknown")
            
            case "$status" in
                "active")
                    echo "✅ $service: 运行中 (开机启动: $enabled)"
                    ;;
                "inactive")
                    echo "❌ $service: 停止 (开机启动: $enabled)"
                    ;;
                *)
                    echo "⚠️  $service: 状态未知 ($status)"
                    ;;
            esac
        fi
    done
}

# 网络服务重启
NETWORK_SERVICES_RESTART() {
    local service="$1"
    
    if [ -n "$service" ]; then
        echo "=== 重启网络服务: $service ==="
        
        # 停止服务
        echo "停止服务..."
        sudo systemctl stop "$service"
        
        # 等待服务完全停止
        sleep 2
        
        # 启动服务
        echo "启动服务..."
        sudo systemctl start "$service"
        
        if [ $? -eq 0 ]; then
            echo "✅ 服务 $service 重启成功"
            
            # 检查服务状态
            sleep 2
            local status=$(systemctl is-active "$service")
            if [ "$status" = "active" ]; then
                echo "✅ 服务运行正常"
            else
                echo "❌ 服务运行异常"
                return 1
            fi
        else
            echo "❌ 服务 $service 重启失败"
            return 1
        fi
    else
        echo "=== 重启所有网络服务 ==="
        
        # 常用网络服务列表
        local services=(
            "systemd-resolved"
            "NetworkManager"
            "networking"
        )
        
        for svc in "${services[@]}"; do
            if systemctl list-unit-files | grep -q "$svc"; then
                echo "重启 $svc..."
                sudo systemctl restart "$svc"
                
                if [ $? -eq 0 ]; then
                    echo "✅ $svc 重启成功"
                else
                    echo "❌ $svc 重启失败"
                fi
                
                # 等待服务启动
                sleep 2
            fi
        done
        
        echo "✅ 网络服务重启完成"
    fi
}

# 网络配置重置
NETWORK_CONFIG_RESET() {
    echo "=== 网络配置重置 ==="
    echo "警告: 这将重置网络配置到默认状态"
    echo ""
    
    read -p "确认重置网络配置? (y/N): " -n 1 -r
    echo
    
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "操作已取消"
        return 1
    fi
    
    # 备份当前配置
    echo "备份当前配置..."
    sudo cp /etc/network/interfaces /etc/network/interfaces.backup.$(date +%Y%m%d) 2>/dev/null || true
    sudo cp /etc/netplan/*.yaml /etc/netplan/backup/ 2>/dev/null || true
    echo "✅ 配置已备份"
    
    # 重置网络配置
    echo "重置网络配置..."
    
    # Ubuntu/Debian netplan
    if [ -d /etc/netplan ]; then
        sudo netplan apply
        echo "✅ netplan配置已应用"
    fi
    
    # 传统网络配置
    if [ -f /etc/network/interfaces ]; then
        sudo systemctl restart networking
        echo "✅ 传统网络配置已重启"
    fi
    
    # 重启NetworkManager
    if systemctl list-unit-files | grep -q NetworkManager; then
        sudo systemctl restart NetworkManager
        echo "✅ NetworkManager已重启"
    fi
    
    # 等待网络恢复
    echo "等待网络恢复..."
    sleep 5
    
    # 验证网络连接
    echo "验证网络连接..."
    if ping -c 1 8.8.8.8 >/dev/null 2>&1; then
        echo "✅ 网络连接已恢复"
    else
        echo "⚠️  网络连接可能仍有问题"
        echo "请手动检查网络配置"
    fi
}

# 使用示例
# NETWORK_SERVICES_STATUS
# NETWORK_SERVICES_RESTART NetworkManager
# NETWORK_CONFIG_RESET
```

这些网络连接问题的诊断和解决方案涵盖了从基础的网络接口配置到复杂的网络服务故障排查，为系统管理员提供了全面的网络问题处理工具集。