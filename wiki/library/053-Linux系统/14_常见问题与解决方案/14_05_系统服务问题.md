# 系统服务问题

## 1 systemd服务管理问题

### 1.1 服务状态诊断

#### 1.1.1 systemd服务状态检查

```bash
#!/bin/bash
# systemd服务状态检查

# systemd服务状态检查
SYSTEMD_STATUS_CHECK() {
    echo "=== systemd服务状态检查 ==="
    echo "检查时间: $(date)"
    echo ""
    
    # 检查systemd版本
    echo "1. systemd版本:"
    systemctl --version | head -1
    echo ""
    
    # 检查系统状态
    echo "2. 系统状态:"
    systemctl is-system-running
    if [ $? -ne 0 ]; then
        echo "⚠️  系统状态异常，检查失败的服务:"
        systemctl --failed
    fi
    echo ""
    
    # 检查失败的服务
    echo "3. 失败的服务:"
    local failed_services=$(systemctl --failed --no-pager --plain | wc -l)
    if [ "$failed_services" -gt 0 ]; then
        echo "发现 $failed_services 个失败的服务:"
        systemctl --failed --no-pager --plain
    else
        echo "✅ 无失败的服务"
    fi
    echo ""
    
    # 检查服务状态统计
    echo "4. 服务状态统计:"
    systemctl list-units --type=service --no-pager --plain | awk '
    NR>1 {
        status = $3
        count[status]++
    }
    END {
        for (s in count) {
            printf "%s: %d\n", s, count[s]
        }
    }'
    echo ""
    
    # 检查服务启动时间
    echo "5. 服务启动时间分析:"
    systemd-analyze blame | head -10
    echo ""
    
    # 检查关键服务
    echo "6. 关键服务状态:"
    local critical_services=("sshd" "networking" "NetworkManager" "firewalld" "cron" "systemd-journald")
    for service in "${critical_services[@]}"; do
        if systemctl list-unit-files | grep -q "$service"; then
            local status=$(systemctl is-active "$service" 2>/dev/null || echo "unknown")
            local enabled=$(systemctl is-enabled "$service" 2>/dev/null || echo "unknown")
            printf "%-20s 状态: %-10s 启用: %s\n" "$service" "$status" "$enabled"
        fi
    done
}

# 服务依赖关系分析
SERVICE_DEPENDENCY_ANALYSIS() {
    local service_name="$1"
    
    echo "=== 服务依赖关系分析 ==="
    echo "分析时间: $(date)"
    echo ""
    
    if [ -n "$service_name" ]; then
        echo "分析服务: $service_name"
        echo ""
        
        # 检查服务是否存在
        if ! systemctl list-unit-files | grep -q "$service_name"; then
            echo "❌ 服务不存在: $service_name"
            return 1
        fi
        
        # 服务状态
        echo "1. 服务状态:"
        systemctl status "$service_name" --no-pager -l
        echo ""
        
        # 服务依赖关系
        echo "2. 服务依赖关系:"
        echo "依赖的服务:"
        systemctl list-dependencies "$service_name" --no-pager | grep -E "^[^│].*service" | head -10
        echo ""
        
        echo "被依赖的服务:"
        systemctl list-dependencies --reverse "$service_name" --no-pager | grep -E "^[^│].*service" | head -10
        echo ""
        
        # 服务日志
        echo "3. 服务日志 (最近10条):"
        journalctl -u "$service_name" -n 10 --no-pager
        echo ""
        
        # 服务配置
        echo "4. 服务配置:"
        systemctl cat "$service_name" 2>/dev/null | head -20
    else
        # 系统级服务依赖分析
        echo "系统级服务依赖分析:"
        echo ""
        
        # 循环依赖检查
        echo "1. 循环依赖检查:"
        systemd-analyze verify /etc/systemd/system/*.service 2>&1 | grep -i "cycle" | head -5
        echo ""
        
        # 服务启动顺序
        echo "2. 服务启动顺序分析:"
        systemd-analyze critical-chain | head -10
        echo ""
        
        # 服务状态分布
        echo "3. 服务状态分布:"
        systemctl list-units --type=service --no-pager --plain | awk '
        NR>1 {
            if ($3 == "active") active++
            else if ($3 == "inactive") inactive++
            else if ($3 == "failed") failed++
            else other++
        }
        END {
            printf "active: %d, inactive: %d, failed: %d, other: %d\n", active, inactive, failed, other
        }'
    fi
}

# 使用示例
# SYSTEMD_STATUS_CHECK
# SERVICE_DEPENDENCY_ANALYSIS nginx
```

#### 1.1.2 服务启动失败解决

```bash
#!/bin/bash
# systemd服务启动失败解决

# 服务启动失败诊断
SERVICE_START_FAILURE_DIAGNOSIS() {
    local service_name="$1"
    
    echo "=== 服务启动失败诊断 ==="
    echo "诊断时间: $(date)"
    echo ""
    
    if [ -z "$service_name" ]; then
        echo "用法: $0 <服务名称>"
        return 1
    fi
    
    echo "诊断服务: $service_name"
    echo ""
    
    # 检查服务是否存在
    echo "1. 检查服务是否存在:"
    if ! systemctl list-unit-files | grep -q "$service_name"; then
        echo "❌ 服务不存在: $service_name"
        echo "建议: 检查服务名称是否正确，或安装相应软件包"
        return 1
    else
        echo "✅ 服务存在"
    fi
    echo ""
    
    # 检查服务状态
    echo "2. 检查服务状态:"
    local service_status=$(systemctl is-active "$service_name" 2>/dev/null || echo "unknown")
    echo "服务状态: $service_status"
    
    if [ "$service_status" = "failed" ]; then
        echo "⚠️  服务启动失败"
        systemctl status "$service_name" --no-pager -l
    elif [ "$service_status" = "inactive" ]; then
        echo "⚠️  服务未启动"
    elif [ "$service_status" = "active" ]; then
        echo "✅ 服务运行正常"
        return 0
    fi
    echo ""
    
    # 检查服务是否启用
    echo "3. 检查服务是否启用:"
    local enabled_status=$(systemctl is-enabled "$service_name" 2>/dev/null || echo "unknown")
    echo "启用状态: $enabled_status"
    
    if [ "$enabled_status" = "disabled" ]; then
        echo "建议: 启用服务 (systemctl enable $service_name)"
    fi
    echo ""
    
    # 检查服务日志
    echo "4. 检查服务日志:"
    echo "最近20条错误日志:"
    journalctl -u "$service_name" -n 20 --no-pager | grep -i -E "(error|failed|exception)" | tail -10
    echo ""
    
    # 检查依赖服务
    echo "5. 检查依赖服务:"
    local failed_deps=()
    systemctl list-dependencies "$service_name" --no-pager | while read line; do
        if [[ "$line" =~ ([^[:space:]]+\.service) ]]; then
            local dep_service="${BASH_REMATCH[1]}"
            local dep_status=$(systemctl is-active "$dep_service" 2>/dev/null || echo "unknown")
            if [ "$dep_status" != "active" ]; then
                echo "⚠️  依赖服务异常: $dep_service ($dep_status)"
                failed_deps+=("$dep_service")
            fi
        fi
    done
    
    if [ ${#failed_deps[@]} -eq 0 ]; then
        echo "✅ 所有依赖服务正常"
    fi
    echo ""
    
    # 检查端口冲突
    echo "6. 检查端口冲突:"
    systemctl cat "$service_name" 2>/dev/null | grep -i "port" | while read line; do
        if [[ "$line" =~ port.*([0-9]+) ]]; then
            local port="${BASH_REMATCH[1]}"
            if netstat -tlnp 2>/dev/null | grep -q ":$port "; then
                echo "⚠️  端口冲突: $port 已被占用"
                netstat -tlnp | grep ":$port "
            else
                echo "✅ 端口 $port 可用"
            fi
        fi
    done
    echo ""
    
    # 检查配置文件
    echo "7. 检查配置文件:"
    systemctl cat "$service_name" 2>/dev/null | grep -E "(ExecStart|Config|Environment)" | head -5
    echo ""
    
    # 检查文件权限
    echo "8. 检查文件权限:"
    systemctl cat "$service_name" 2>/dev/null | grep -E "(ExecStart|User|Group)" | while read line; do
        if [[ "$line" =~ ExecStart=([^[:space:]]+) ]]; then
            local exec_file="${BASH_REMATCH[1]}"
            if [ -f "$exec_file" ]; then
                local perms=$(stat -c "%a" "$exec_file")
                local owner=$(stat -c "%U:%G" "$exec_file")
                echo "执行文件: $exec_file (权限: $perms, 属主: $owner)"
                if [ "$perms" -lt 755 ]; then
                    echo "⚠️  执行文件权限可能不足"
                fi
            else
                echo "❌ 执行文件不存在: $exec_file"
            fi
        fi
    done
    echo ""
    
    # 提供解决方案
    echo "9. 建议的解决方案:"
    echo "通用解决步骤:"
    echo "1. 检查服务日志获取详细错误信息"
    echo "2. 确保所有依赖服务正常运行"
    echo "3. 检查配置文件语法是否正确"
    echo "4. 验证文件权限和属主设置"
    echo "5. 检查端口是否被其他服务占用"
    echo "6. 检查系统资源是否充足"
    echo ""
    echo "具体命令:"
    echo "  查看详细日志: journalctl -u $service_name -n 50"
    echo "  手动启动服务: systemctl start $service_name"
    echo "  检查服务配置: systemctl cat $service_name"
    echo "  验证配置文件: $service_name -t (如果支持)"
}

# 使用示例
# SERVICE_START_FAILURE_DIAGNOSIS nginx
```

#### 1.1.3 服务自动重启配置

```bash
#!/bin/bash
# systemd服务自动重启配置

# 服务自动重启配置
SERVICE_AUTO_RESTART_CONFIG() {
    local service_name="$1"
    local restart_policy="${2:-always}"
    local restart_delay="${3:-5}"
    
    echo "=== 服务自动重启配置 ==="
    echo "配置时间: $(date)"
    echo "服务: $service_name"
    echo "重启策略: $restart_policy"
    echo "重启延迟: ${restart_delay}秒"
    echo ""
    
    if [ -z "$service_name" ]; then
        echo "用法: $0 <服务名称> [重启策略(always|on-failure|on-success)] [重启延迟(秒)]"
        return 1
    fi
    
    # 检查服务是否存在
    if ! systemctl list-unit-files | grep -q "$service_name"; then
        echo "❌ 服务不存在: $service_name"
        return 1
    fi
    
    # 创建服务覆盖配置
    local override_dir="/etc/systemd/system/${service_name}.service.d"
    if [ ! -d "$override_dir" ]; then
        sudo mkdir -p "$override_dir"
    fi
    
    cat <<EOF | sudo tee "$override_dir/auto-restart.conf" >/dev/null
[Service]
# 重启策略
Restart=$restart_policy

# 重启延迟
RestartSec=$restart_delay

# 重启限制
StartLimitInterval=60
StartLimitBurst=5

# 退出码处理
RestartPreventExitStatus=255

# 重启前的等待时间
TimeoutStartSec=30
TimeoutStopSec=30
EOF
    
    echo "✅ 自动重启配置已创建"
    echo ""
    
    # 重载配置
    echo "重载systemd配置..."
    sudo systemctl daemon-reload
    
    # 重启服务以应用配置
    echo "重启服务以应用配置..."
    sudo systemctl restart "$service_name"
    
    sleep 3
    local status=$(systemctl is-active "$service_name")
    if [ "$status" = "active" ]; then
        echo "✅ 自动重启配置已应用"
    else
        echo "⚠️  服务配置后状态异常"
    fi
}

# 使用示例
# SERVICE_AUTO_RESTART_CONFIG nginx always 10
```

## 2 传统init脚本服务问题

### 2.1 SysV init服务管理

#### 2.1.1 init脚本服务检查

```bash
#!/bin/bash
# SysV init脚本服务检查

# init服务状态检查
INIT_SERVICE_STATUS_CHECK() {
    echo "=== SysV init服务状态检查 ==="
    echo "检查时间: $(date)"
    echo ""
    
    # 检查init系统
    echo "1. init系统检查:"
    if [ -d /etc/init.d ]; then
        echo "✅ SysV init脚本目录存在: /etc/init.d"
        local init_scripts=$(find /etc/init.d -type f -executable | wc -l)
        echo "init脚本数量: $init_scripts"
    else
        echo "❌ SysV init脚本目录不存在"
        return 1
    fi
    echo ""
    
    # 检查服务状态
    echo "2. init服务状态:"
    if command -v service >/dev/null 2>&1; then
        echo "使用service命令管理"
    elif command -v chkconfig >/dev/null 2>&1; then
        echo "使用chkconfig命令管理"
    elif command -v update-rc.d >/dev/null 2>&1; then
        echo "使用update-rc.d命令管理"
    else
        echo "❌ 未找到init服务管理工具"
    fi
    echo ""
    
    # 检查运行级别
    echo "3. 运行级别检查:"
    if command -v runlevel >/dev/null 2>&1; then
        local runlevel=$(runlevel | awk '{print $2}')
        echo "当前运行级别: $runlevel"
    else
        echo "无法获取运行级别信息"
    fi
    echo ""
    
    # 检查服务列表
    echo "4. init服务列表:"
    find /etc/init.d -type f -executable | sort | head -10 | while read script; do
        local script_name=$(basename "$script")
        local status="unknown"
        
        if command -v service >/dev/null 2>&1; then
            status=$(service "$script_name" status 2>&1 | head -1)
        fi
        
        printf "%-20s %s\n" "$script_name" "$status"
    done
}

# 使用示例
# INIT_SERVICE_STATUS_CHECK
```

这些系统服务问题的诊断和解决方案涵盖了现代systemd和传统SysV init两大服务管理系统，从基础状态检查到复杂的故障修复和性能优化，为系统管理员提供了全面的服务管理问题处理工具集。