# 软件包管理问题

## 1 APT包管理问题

### 1.1 包依赖问题解决

#### 1.1.1 依赖关系诊断

```bash
#!/bin/bash
# APT包依赖关系诊断

# APT状态检查
APT_STATUS_CHECK() {
    echo "=== APT状态检查 ==="
    echo "检查时间: $(date)"
    echo ""
    
    # 检查APT锁
    echo "1. 检查APT锁状态:"
    if [ -f /var/lib/dpkg/lock ]; then
        echo "APT锁文件存在"
        if lsof /var/lib/dpkg/lock >/dev/null 2>&1; then
            echo "⚠️  APT锁被占用"
            lsof /var/lib/dpkg/lock
        else
            echo "✅ APT锁未被占用"
        fi
    else
        echo "APT锁文件不存在"
    fi
    echo ""
    
    # 检查APT配置
    echo "2. 检查APT配置:"
    if [ -f /etc/apt/sources.list ]; then
        echo "APT源配置文件存在"
        grep -v "^#" /etc/apt/sources.list | grep -v "^$" | head -5
    else
        echo "❌ APT源配置文件不存在"
    fi
    echo ""
    
    # 检查APT缓存
    echo "3. 检查APT缓存:"
    local cache_size=$(du -sh /var/cache/apt 2>/dev/null | cut -f1)
    echo "APT缓存大小: ${cache_size:-0}"
    
    local cache_files=$(find /var/cache/apt -type f 2>/dev/null | wc -l)
    echo "缓存文件数量: $cache_files"
    echo ""
    
    # 检查未完成的APT操作
    echo "4. 检查未完成的APT操作:"
    if [ -f /var/lib/dpkg/updates/0000 ]; then
        echo "⚠️  存在未完成的dpkg更新"
        ls /var/lib/dpkg/updates/
    else
        echo "✅ 无未完成的dpkg更新"
    fi
    
    if [ -f /var/lib/apt/lists/lock ]; then
        echo "⚠️  存在APT列表锁"
    else
        echo "✅ 无APT列表锁"
    fi
}

# 依赖关系分析
DEPENDENCY_ANALYSIS() {
    local package_name="$1"
    
    echo "=== 依赖关系分析 ==="
    echo "分析时间: $(date)"
    echo ""
    
    if [ -n "$package_name" ]; then
        echo "分析包: $package_name"
        echo ""
        
        # 检查包状态
        echo "1. 包状态检查:"
        dpkg -l | grep -E "^ii.*$package_name" || echo "包未安装"
        echo ""
        
        # 依赖关系检查
        echo "2. 依赖关系检查:"
        apt-cache depends "$package_name" 2>/dev/null | head -10
        echo ""
        
        # 反向依赖关系
        echo "3. 反向依赖关系:"
        apt-cache rdepends "$package_name" 2>/dev/null | head -10
        echo ""
        
        # 包信息
        echo "4. 包详细信息:"
        apt-cache show "$package_name" 2>/dev/null | grep -E "(Package|Version|Depends|Status)" | head -10
    else
        # 系统级依赖关系分析
        echo "系统级依赖关系分析:"
        echo ""
        
        # 检查损坏的包
        echo "1. 损坏的包检查:"
        dpkg -l | grep -E "^[^i][^i]" | head -10
        echo ""
        
        # 检查未满足的依赖
        echo "2. 未满足的依赖检查:"
        apt-get check 2>&1 | grep -E "(Depends|Breaks|Conflicts)" | head -10
        echo ""
        
        # 检查孤立的包
        echo "3. 孤立的包检查:"
        deborphan 2>/dev/null | head -10 || echo "deborphan 未安装"
        echo ""
        
        # 检查建议的包
        echo "4. 建议的包检查:"
        apt-get install --dry-run 2>&1 | grep -E "Recommends|Suggests" | head -10
    fi
}

# 依赖冲突解决
DEPENDENCY_CONFLICT_RESOLUTION() {
    echo "=== 依赖冲突解决 ==="
    echo "解决时间: $(date)"
    echo ""
    
    # 检查冲突的包
    echo "1. 检查冲突的包:"
    dpkg -l | grep -E "^[^i][^i]" > /tmp/conflict_packages.txt
    if [ -s /tmp/conflict_packages.txt ]; then
        echo "发现冲突的包:"
        cat /tmp/conflict_packages.txt
    else
        echo "✅ 未发现冲突的包"
    fi
    echo ""
    
    # 尝试修复依赖
    echo "2. 尝试修复依赖..."
    echo "执行: sudo apt-get install -f"
    sudo apt-get install -f
    echo ""
    
    # 清理包缓存
    echo "3. 清理包缓存..."
    echo "执行: sudo apt-get clean"
    sudo apt-get clean
    echo ""
    
    # 更新包列表
    echo "4. 更新包列表..."
    echo "执行: sudo apt-get update"
    sudo apt-get update
    echo ""
    
    # 升级包
    echo "5. 升级包..."
    echo "执行: sudo apt-get upgrade"
    sudo apt-get upgrade
    echo ""
    
    # 重新配置包
    echo "6. 重新配置包..."
    echo "执行: sudo dpkg --configure -a"
    sudo dpkg --configure -a
    
    echo "✅ 依赖冲突解决完成"
}

# 使用示例
# APT_STATUS_CHECK
# DEPENDENCY_ANALYSIS nginx
# DEPENDENCY_CONFLICT_RESOLUTION
```

#### 1.1.2 APT缓存管理

```bash
#!/bin/bash
# APT缓存管理

# APT缓存分析
APT_CACHE_ANALYSIS() {
    echo "=== APT缓存分析 ==="
    echo "分析时间: $(date)"
    echo ""
    
    # 缓存总体情况
    echo "1. 缓存总体情况:"
    if [ -d /var/cache/apt ]; then
        local cache_size=$(du -sh /var/cache/apt 2>/dev/null | cut -f1)
        echo "APT缓存目录: /var/cache/apt"
        echo "缓存总大小: ${cache_size:-0}"
        
        # 缓存目录结构
        echo ""
        echo "缓存目录结构:"
        du -sh /var/cache/apt/* 2>/dev/null | head -10
    else
        echo "APT缓存目录不存在"
    fi
    echo ""
    
    # 包文件缓存
    echo "2. 包文件缓存:"
    if [ -d /var/cache/apt/archives ]; then
        local archive_size=$(du -sh /var/cache/apt/archives 2>/dev/null | cut -f1)
        local archive_files=$(find /var/cache/apt/archives -name "*.deb" 2>/dev/null | wc -l)
        echo "包文件缓存大小: ${archive_size:-0}"
        echo "包文件数量: $archive_files"
        
        # 最旧的包文件
        echo ""
        echo "最旧的包文件:"
        find /var/cache/apt/archives -name "*.deb" -type f -printf '%T+ %p\n' 2>/dev/null | sort | head -5
    fi
    echo ""
    
    # 包列表缓存
    echo "3. 包列表缓存:"
    if [ -d /var/lib/apt/lists ]; then
        local lists_size=$(du -sh /var/lib/apt/lists 2>/dev/null | cut -f1)
        local lists_files=$(find /var/lib/apt/lists -type f 2>/dev/null | wc -l)
        echo "包列表缓存大小: ${lists_size:-0}"
        echo "包列表文件数量: $lists_files"
    fi
    echo ""
    
    # 已安装包的缓存
    echo "4. 已安装包的缓存:"
    if [ -d /var/lib/dpkg/info ]; then
        local info_size=$(du -sh /var/lib/dpkg/info 2>/dev/null | cut -f1)
        echo "包信息缓存大小: ${info_size:-0}"
    fi
}

# APT缓存清理
APT_CACHE_CLEAN() {
    local clean_type="${1:-all}"
    
    echo "=== APT缓存清理 ==="
    echo "清理类型: $clean_type"
    echo "清理时间: $(date)"
    echo ""
    
    # 清理前状态
    echo "清理前缓存状态:"
    APT_CACHE_ANALYSIS
    echo ""
    
    case "$clean_type" in
        "packages")
            echo "清理包文件缓存..."
            sudo apt-get clean
            echo "✅ 包文件缓存已清理"
            ;;
        "lists")
            echo "清理包列表缓存..."
            sudo apt-get clean
            sudo rm -rf /var/lib/apt/lists/*
            echo "✅ 包列表缓存已清理"
            ;;
        "all")
            echo "清理所有APT缓存..."
            sudo apt-get clean
            sudo apt-get autoclean
            sudo rm -rf /var/lib/apt/lists/*
            sudo apt-get update
            echo "✅ 所有APT缓存已清理"
            ;;
        *)
            echo "未知的清理类型: $clean_type"
            echo "可用类型: packages, lists, all"
            return 1
            ;;
    esac
    
    echo ""
    echo "清理后缓存状态:"
    APT_CACHE_ANALYSIS
}

# APT缓存优化
APT_CACHE_OPTIMIZE() {
    echo "=== APT缓存优化 ==="
    echo "优化时间: $(date)"
    echo ""
    
    # 设置缓存限制
    echo "1. 设置缓存限制..."
    
    # 配置APT缓存限制
    if [ -f /etc/apt/apt.conf ]; then
        echo "APT配置文件已存在"
    else
        echo "创建APT配置文件..."
        sudo touch /etc/apt/apt.conf
    fi
    
    # 添加缓存限制配置
    echo "添加缓存限制配置..."
    cat <<EOF | sudo tee /etc/apt/apt.conf.d/99cache-limit >/dev/null
// APT缓存限制配置
APT::Cache-Limit "100000000";
APT::Cache-Start "20971520";
APT::Cache-Grow "5242880";
EOF
    
    echo "✅ 缓存限制已设置"
    echo ""
    
    # 自动清理配置
    echo "2. 自动清理配置..."
    
    # 创建自动清理脚本
    cat <<'EOF' | sudo tee /etc/cron.daily/apt-cache-cleanup >/dev/null
#!/bin/bash
# APT缓存自动清理脚本

# 清理旧的包文件
find /var/cache/apt/archives -name "*.deb" -mtime +7 -delete

# 清理包列表缓存
find /var/lib/apt/lists -name "*.dep" -mtime +1 -delete

# 记录清理日志
echo "$(date): APT缓存自动清理完成" >> /var/log/apt-cache-cleanup.log
EOF
    
    sudo chmod +x /etc/cron.daily/apt-cache-cleanup
    echo "✅ 自动清理已配置"
    echo ""
    
    # 缓存压缩
    echo "3. 缓存压缩..."
    
    # 压缩包列表文件
    if [ -d /var/lib/apt/lists ]; then
        find /var/lib/apt/lists -name "*.dep" -exec gzip {} \; 2>/dev/null || true
        echo "✅ 包列表文件已压缩"
    fi
    
    echo "✅ APT缓存优化完成"
}

# 使用示例
# APT_CACHE_ANALYSIS
# APT_CACHE_CLEAN packages
# APT_CACHE_OPTIMIZE
```

### 1.2 软件源问题

#### 1.2.1 软件源配置

```bash
#!/bin/bash
# 软件源配置管理

# 软件源状态检查
REPOSITORY_STATUS_CHECK() {
    echo "=== 软件源状态检查 ==="
    echo "检查时间: $(date)"
    echo ""
    
    # 检查软件源文件
    echo "1. 检查软件源文件:"
    if [ -f /etc/apt/sources.list ]; then
        echo "主源文件: /etc/apt/sources.list"
        echo "源条目数量: $(grep -v "^#" /etc/apt/sources.list | grep -v "^$" | wc -l)"
    else
        echo "❌ 主源文件不存在"
    fi
    echo ""
    
    # 检查软件源目录
    echo "2. 检查软件源目录:"
    if [ -d /etc/apt/sources.list.d ]; then
        echo "源目录: /etc/apt/sources.list.d"
        local repo_files=$(find /etc/apt/sources.list.d -name "*.list" 2>/dev/null | wc -l)
        echo "源文件数量: $repo_files"
        
        if [ "$repo_files" -gt 0 ]; then
            echo "源文件列表:"
            ls -la /etc/apt/sources.list.d/*.list 2>/dev/null | head -5
        fi
    else
        echo "❌ 软件源目录不存在"
    fi
    echo ""
    
    # 检查软件源状态
    echo "3. 检查软件源状态:"
    apt-get update --dry-run 2>&1 | grep -E "(Ign|Hit|Get|Err)" | head -10
    echo ""
    
    # 检查软件源响应时间
    echo "4. 检查软件源响应时间:"
    grep -v "^#" /etc/apt/sources.list | grep -v "^$" | while read line; do
        if [[ "$line" =~ http://([^/]+) ]]; then
            local host="${BASH_REMATCH[1]}"
            echo "测试源: $host"
            local response_time=$(ping -c 1 "$host" 2>/dev/null | grep "time=" | cut -d= -f4 | cut -d" " -f1 || echo "超时")
            echo "响应时间: ${response_time}ms"
            echo ""
        fi
    done | head -10
}

# 软件源备份
REPOSITORY_BACKUP() {
    local backup_dir="${1:-/backup/apt}"
    
    echo "=== 软件源备份 ==="
    echo "备份目录: $backup_dir"
    echo "备份时间: $(date)"
    echo ""
    
    # 创建备份目录
    if [ ! -d "$backup_dir" ]; then
        sudo mkdir -p "$backup_dir"
        echo "创建备份目录: $backup_dir"
    fi
    
    # 备份主源文件
    echo "备份主源文件..."
    if [ -f /etc/apt/sources.list ]; then
        sudo cp /etc/apt/sources.list "$backup_dir/sources.list.$(date +%Y%m%d_%H%M%S)"
        echo "✅ 主源文件已备份"
    else
        echo "❌ 主源文件不存在"
    fi
    
    # 备份源目录
    echo "备份源目录..."
    if [ -d /etc/apt/sources.list.d ]; then
        sudo tar -czf "$backup_dir/sources.list.d.$(date +%Y%m%d_%H%M%S).tar.gz" -C /etc/apt sources.list.d
        echo "✅ 源目录已备份"
    else
        echo "❌ 源目录不存在"
    fi
    
    # 备份APT配置
    echo "备份APT配置..."
    if [ -d /etc/apt/apt.conf.d ]; then
        sudo tar -czf "$backup_dir/apt.conf.d.$(date +%Y%m%d_%H%M%S).tar.gz" -C /etc/apt apt.conf.d
        echo "✅ APT配置已备份"
    fi
    
    echo "✅ 软件源备份完成"
}

# 软件源恢复
REPOSITORY_RESTORE() {
    local backup_file="$1"
    
    echo "=== 软件源恢复 ==="
    echo "备份文件: $backup_file"
    echo "恢复时间: $(date)"
    echo ""
    
    if [ -z "$backup_file" ]; then
        echo "用法: $0 <备份文件>"
        return 1
    fi
    
    if [ ! -f "$backup_file" ]; then
        echo "❌ 备份文件不存在: $backup_file"
        return 1
    fi
    
    # 备份当前配置
    echo "备份当前配置..."
    REPOSITORY_BACKUP
    echo ""
    
    # 恢复主源文件
    if [[ "$backup_file" =~ sources\.list ]]; then
        echo "恢复主源文件..."
        sudo cp "$backup_file" /etc/apt/sources.list
        echo "✅ 主源文件已恢复"
    fi
    
    # 恢复源目录
    if [[ "$backup_file" =~ sources\.list\.d ]]; then
        echo "恢复源目录..."
        sudo tar -xzf "$backup_file" -C /etc/apt
        echo "✅ 源目录已恢复"
    fi
    
    # 恢复APT配置
    if [[ "$backup_file" =~ apt\.conf\.d ]]; then
        echo "恢复APT配置..."
        sudo tar -xzf "$backup_file" -C /etc/apt
        echo "✅ APT配置已恢复"
    fi
    
    # 更新软件源
    echo "更新软件源..."
    sudo apt-get update
    
    echo "✅ 软件源恢复完成"
}

# 软件源优化
REPOSITORY_OPTIMIZE() {
    echo "=== 软件源优化 ==="
    echo "优化时间: $(date)"
    echo ""
    
    # 备份当前配置
    echo "备份当前配置..."
    REPOSITORY_BACKUP
    echo ""
    
    # 检测最佳软件源
    echo "1. 检测最佳软件源..."
    
    # 安装netselect-apt
    if ! command -v netselect-apt >/dev/null 2>&1; then
        echo "安装netselect-apt..."
        sudo apt update && sudo apt install -y netselect-apt
    fi
    
    # 检测最快源
    echo "检测最快源..."
    sudo netselect-apt -s stable -o /tmp/sources.list.tmp
    
    if [ -f /tmp/sources.list.tmp ]; then
        echo "检测到最快源:"
        grep -v "^#" /tmp/sources.list.tmp | head -5
        
        # 备份当前配置
        sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup
        
        # 应用新配置
        sudo cp /tmp/sources.list.tmp /etc/apt/sources.list
        rm -f /tmp/sources.list.tmp
        
        echo "✅ 最快源已应用"
    else
        echo "❌ 无法检测最快源"
    fi
    echo ""
    
    # 添加常用软件源
    echo "2. 添加常用软件源..."
    
    # 添加backports源
    if ! grep -q "backports" /etc/apt/sources.list; then
        echo "添加backports源..."
        echo "deb http://deb.debian.org/debian $(lsb_release -cs)-backports main contrib non-free" | sudo tee -a /etc/apt/sources.list
        echo "✅ backports源已添加"
    fi
    
    # 添加security源
    if ! grep -q "security" /etc/apt/sources.list; then
        echo "添加security源..."
        echo "deb http://security.debian.org/debian-security $(lsb_release -cs)/updates main contrib non-free" | sudo tee -a /etc/apt/sources.list
        echo "✅ security源已添加"
    fi
    
    echo ""
    # 更新软件源
    echo "3. 更新软件源..."
    sudo apt-get update
    
    echo "✅ 软件源优化完成"
}

# 使用示例
# REPOSITORY_STATUS_CHECK
# REPOSITORY_BACKUP /backup/apt
# REPOSITORY_RESTORE /backup/apt/sources.list.20231201_120000
# REPOSITORY_OPTIMIZE
```

## 2 YUM/DNF包管理问题

### 2.1 YUM/DNF基础问题

#### 2.1.1 YUM/DNF状态检查

```bash
#!/bin/bash
# YUM/DNF状态检查

# YUM/DNF状态检查
YUM_STATUS_CHECK() {
    echo "=== YUM/DNF状态检查 ==="
    echo "检查时间: $(date)"
    echo ""
    
    # 检查包管理器
    echo "1. 检查包管理器:"
    if command -v dnf >/dev/null 2>&1; then
        echo "使用DNF包管理器"
        local pkg_manager="dnf"
    elif command -v yum >/dev/null 2>&1; then
        echo "使用YUM包管理器"
        local pkg_manager="yum"
    else
        echo "❌ 未找到包管理器"
        return 1
    fi
    echo ""
    
    # 检查包管理器版本
    echo "2. 包管理器版本:"
    $pkg_manager --version | head -1
    echo ""
    
    # 检查软件源
    echo "3. 检查软件源:"
    $pkg_manager repolist | head -10
    echo ""
    
    # 检查缓存
    echo "4. 检查缓存:"
    local cache_dir="/var/cache/$pkg_manager"
    if [ -d "$cache_dir" ]; then
        local cache_size=$(du -sh "$cache_dir" 2>/dev/null | cut -f1)
        echo "缓存目录: $cache_dir"
        echo "缓存大小: ${cache_size:-0}"
    else
        echo "❌ 缓存目录不存在"
    fi
    echo ""
    
    # 检查锁文件
    echo "5. 检查锁文件:"
    local lock_file="/var/run/$pkg_manager.pid"
    if [ -f "$lock_file" ]; then
        echo "锁文件存在: $lock_file"
        if [ -s "$lock_file" ]; then
            local pid=$(cat "$lock_file")
            if ps -p "$pid" >/dev/null 2>&1; then
                echo "⚠️  包管理器正在运行 (PID: $pid)"
            else
                echo "⚠️  锁文件存在但进程未运行"
                echo "建议删除锁文件: sudo rm -f $lock_file"
            fi
        fi
    else
        echo "✅ 无锁文件"
    fi
}

# 依赖关系分析
YUM_DEPENDENCY_ANALYSIS() {
    local package_name="$1"
    local pkg_manager="${2:-yum}"
    
    echo "=== YUM/DNF依赖关系分析 ==="
    echo "分析时间: $(date)"
    echo "包管理器: $pkg_manager"
    echo ""
    
    if [ -n "$package_name" ]; then
        echo "分析包: $package_name"
        echo ""
        
        # 检查包是否安装
        echo "1. 检查包状态:"
        $pkg_manager list installed "$package_name" 2>/dev/null || echo "包未安装"
        echo ""
        
        # 依赖关系检查
        echo "2. 依赖关系检查:"
        $pkg_manager deplist "$package_name" 2>/dev/null | head -20
        echo ""
        
        # 可用版本
        echo "3. 可用版本:"
        $pkg_manager list available "$package_name" 2>/dev/null | head -5
        echo ""
        
        # 包信息
        echo "4. 包详细信息:"
        $pkg_manager info "$package_name" 2>/dev/null | head -10
    else
        # 系统级依赖关系分析
        echo "系统级依赖关系分析:"
        echo ""
        
        # 检查重复的包
        echo "1. 检查重复的包:"
        $pkg_manager list installed | awk '{print $1}' | sort | uniq -d | head -10
        echo ""
        
        # 检查孤立的包
        echo "2. 检查孤立的包:"
        if command -v package-cleanup >/dev/null 2>&1; then
            package-cleanup --orphans
        else
            echo "package-cleanup 未安装"
        fi
        echo ""
        
        # 检查损坏的包
        echo "3. 检查损坏的包:"
        $pkg_manager check 2>&1 | grep -E "(error|failed|broken)" | head -10
    fi
}

# 使用示例
# YUM_STATUS_CHECK
# YUM_DEPENDENCY_ANALYSIS nginx
```

#### 2.1.2 YUM/DNF缓存管理

```bash
#!/bin/bash
# YUM/DNF缓存管理

# YUM/DNF缓存分析
YUM_CACHE_ANALYSIS() {
    local pkg_manager="${1:-yum}"
    
    echo "=== YUM/DNF缓存分析 ==="
    echo "分析时间: $(date)"
    echo "包管理器: $pkg_manager"
    echo ""
    
    # 缓存总体情况
    echo "1. 缓存总体情况:"
    local cache_dir="/var/cache/$pkg_manager"
    if [ -d "$cache_dir" ]; then
        local cache_size=$(du -sh "$cache_dir" 2>/dev/null | cut -f1)
        echo "缓存目录: $cache_dir"
        echo "缓存总大小: ${cache_size:-0}"
        
        # 缓存目录结构
        echo ""
        echo "缓存目录结构:"
        du -sh "$cache_dir"/* 2>/dev/null | head -10
    else
        echo "缓存目录不存在"
    fi
    echo ""
    
    # 元数据缓存
    echo "2. 元数据缓存:"
    if [ -d "$cache_dir" ]; then
        find "$cache_dir" -name "*.xml*" -type f 2>/dev/null | wc -l | while read count; do
            echo "元数据文件数量: $count"
        done
        
        # 最旧的元数据文件
        echo "最旧的元数据文件:"
        find "$cache_dir" -name "*.xml*" -type f -printf '%T+ %p\n' 2>/dev/null | sort | head -5
    fi
    echo ""
    
    # 包缓存
    echo "3. 包缓存:"
    local package_dir="$cache_dir/packages"
    if [ -d "$package_dir" ]; then
        local package_size=$(du -sh "$package_dir" 2>/dev/null | cut -f1)
        local package_files=$(find "$package_dir" -name "*.rpm" 2>/dev/null | wc -l)
        echo "包缓存大小: ${package_size:-0}"
        echo "包文件数量: $package_files"
    else
        echo "包缓存目录不存在"
    fi
}

# YUM/DNF缓存清理
YUM_CACHE_CLEAN() {
    local clean_type="${1:-all}"
    local pkg_manager="${2:-yum}"
    
    echo "=== YUM/DNF缓存清理 ==="
    echo "清理类型: $clean_type"
    echo "包管理器: $pkg_manager"
    echo "清理时间: $(date)"
    echo ""
    
    # 清理前状态
    echo "清理前缓存状态:"
    YUM_CACHE_ANALYSIS "$pkg_manager"
    echo ""
    
    case "$clean_type" in
        "packages")
            echo "清理包缓存..."
            $pkg_manager clean packages
            echo "✅ 包缓存已清理"
            ;;
        "metadata")
            echo "清理元数据缓存..."
            $pkg_manager clean metadata
            echo "✅ 元数据缓存已清理"
            ;;
        "all")
            echo "清理所有缓存..."
            $pkg_manager clean all
            echo "✅ 所有缓存已清理"
            ;;
        *)
            echo "未知的清理类型: $clean_type"
            echo "可用类型: packages, metadata, all"
            return 1
            ;;
    esac
    
    echo ""
    echo "清理后缓存状态:"
    YUM_CACHE_ANALYSIS "$pkg_manager"
}

# 使用示例
# YUM_CACHE_ANALYSIS
# YUM_CACHE_CLEAN all
```

这些软件包管理问题的诊断和解决方案涵盖了APT和YUM/DNF两大主流包管理器，从依赖关系、缓存管理到软件源配置，为系统管理员提供了全面的包管理问题处理工具集。