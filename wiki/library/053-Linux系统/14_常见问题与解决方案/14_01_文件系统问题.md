# 文件系统问题

## 1 磁盘空间问题

### 1.1 磁盘空间监控

#### 1.1.1 基本磁盘检查

```bash
#!/bin/bash
# 磁盘空间监控脚本

# 查看磁盘使用情况
df -h

# 查看inode使用情况
df -i

# 查看目录大小
du -sh /var/log/
du -sh /home/*

# 查找大文件
find / -type f -size +100M -exec ls -lh {} \; 2>/dev/null | head -10

# 磁盘空间监控
DISK_MONITOR() {
    local threshold="${1:-80}"
    
    echo "=== 磁盘空间监控 ==="
    echo "阈值: ${threshold}%"
    echo "检查时间: $(date)"
    echo ""
    
    # 检查磁盘使用率
    df -h | grep -E "^/dev/" | while read filesystem size used avail use mount; do
        use_num=${use%?}
        if [ "$use_num" -gt "$threshold" ]; then
            echo "⚠️  警告: $mount 使用率 ${use} (超过${threshold}%)"
            
            # 查找该挂载点的大文件
            echo "  大文件 (>100MB):"
            find "$mount" -type f -size +100M -exec ls -lh {} \; 2>/dev/null | head -5
            echo ""
        else
            echo "✅ $mount 使用率: $use"
        fi
    done
    
    # 检查inode使用率
    echo ""
    echo "=== inode使用率 ==="
    df -i | grep -E "^/dev/" | while read filesystem inodes iused ifree iuse mount; do
        iuse_num=${iuse%?}
        if [ "$iuse_num" -gt "$threshold" ]; then
            echo "⚠️  警告: $mount inode使用率 ${iuse} (超过${threshold}%)"
        else
            echo "✅ $mount inode使用率: $iuse"
        fi
    done
}

# 使用示例
# DISK_MONITOR 85
```

#### 1.1.2 磁盘清理策略

```bash
#!/bin/bash
# 磁盘清理脚本

CLEANUP_DISK() {
    local target_dir="${1:-/tmp}"
    local dry_run="${2:-true}"
    
    echo "=== 磁盘清理 ==="
    echo "目标目录: $target_dir"
    echo "模式: $([ "$dry_run" = "true" ] && echo "模拟运行" || echo "实际清理")"
    echo ""
    
    # 清理临时文件
    echo "1. 清理临时文件..."
    if [ "$dry_run" = "true" ]; then
        find /tmp -type f -atime +7 -size +10M -exec ls -lh {} \; 2>/dev/null | head -10
    else
        find /tmp -type f -atime +7 -size +10M -delete 2>/dev/null
        echo "临时文件已清理"
    fi
    
    # 清理日志文件
    echo "2. 清理日志文件..."
    if [ "$dry_run" = "true" ]; then
        find /var/log -name "*.log.*" -mtime +7 -exec ls -lh {} \; 2>/dev/null | head -10
    else
        find /var/log -name "*.log.*" -mtime +7 -delete 2>/dev/null
        echo "日志文件已清理"
    fi
    
    # 清理包缓存
    echo "3. 清理包缓存..."
    if command -v apt >/dev/null 2>&1; then
        if [ "$dry_run" = "true" ]; then
            echo "可清理: apt缓存"
        else
            sudo apt autoremove -y
            sudo apt autoclean
            echo "APT缓存已清理"
        fi
    elif command -v yum >/dev/null 2>&1; then
        if [ "$dry_run" = "true" ]; then
            echo "可清理: yum缓存"
        else
            sudo yum autoremove -y
            sudo yum clean all
            echo "YUM缓存已清理"
        fi
    fi
    
    # 清理用户缓存
    echo "4. 清理用户缓存..."
    if [ "$dry_run" = "true" ]; then
        du -sh ~/.cache/ 2>/dev/null || echo "无用户缓存"
    else
        rm -rf ~/.cache/* 2>/dev/null
        echo "用户缓存已清理"
    fi
    
    # 显示清理结果
    echo ""
    echo "清理结果:"
    df -h | grep -E "^/dev/" | head -3
}

# 自动清理计划
AUTO_CLEANUP() {
    local log_file="/var/log/cleanup.log"
    
    echo "=== 自动磁盘清理 ==="
    echo "开始时间: $(date)" | tee -a "$log_file"
    
    # 清理临时文件
    find /tmp -type f -atime +7 -delete 2>/dev/null
    echo "临时文件清理完成" | tee -a "$log_file"
    
    # 清理日志
    find /var/log -name "*.log.*" -mtime +7 -delete 2>/dev/null
    logrotate -f /etc/logrotate.conf 2>/dev/null
    echo "日志清理完成" | tee -a "$log_file"
    
    # 清理包缓存
    if command -v apt >/dev/null 2>&1; then
        apt autoremove -y >/dev/null 2>&1
        apt autoclean >/dev/null 2>&1
        echo "APT缓存清理完成" | tee -a "$log_file"
    fi
    
    echo "清理完成时间: $(date)" | tee -a "$log_file"
    echo "磁盘使用情况:" | tee -a "$log_file"
    df -h | grep -E "^/dev/" | head -3 | tee -a "$log_file"
}

# 使用示例
# CLEANUP_DISK /tmp true    # 模拟运行
# CLEANUP_DISK /tmp false   # 实际清理
# AUTO_CLEANUP
```

### 1.2 文件系统修复

#### 1.2.1 文件系统检查

```bash
#!/bin/bash
# 文件系统检查与修复

# 检查文件系统错误（需要卸载）
sudo umount /dev/sda1
sudo fsck -f /dev/sda1

# 检查ext4文件系统
sudo fsck.ext4 -f /dev/sda1

# 检查xfs文件系统
sudo xfs_repair /dev/sda1

# 检查btrfs文件系统
sudo btrfs check /dev/sda1

# 文件系统检查脚本
FS_CHECKER() {
    local device="$1"
    
    if [ -z "$device" ]; then
        echo "用法: $0 <设备>"
        echo "示例: $0 /dev/sda1"
        return 1
    fi
    
    if [ ! -b "$device" ]; then
        echo "错误: $device 不是有效的块设备"
        return 1
    fi
    
    echo "=== 文件系统检查 ==="
    echo "设备: $device"
    echo ""
    
    # 检查设备是否挂载
    if mount | grep -q "$device"; then
        echo "⚠️  警告: $device 已挂载"
        echo "  建议先卸载再检查"
        read -p "是否继续? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            return 1
        fi
    fi
    
    # 检测文件系统类型
    local fs_type=$(lsblk -no FSTYPE "$device")
    echo "文件系统类型: $fs_type"
    
    case "$fs_type" in
        "ext4"|"ext3"|"ext2")
            echo "使用 fsck 检查..."
            sudo fsck -f "$device"
            ;;
        "xfs")
            echo "使用 xfs_repair 检查..."
            sudo xfs_repair "$device"
            ;;
        "btrfs")
            echo "使用 btrfs check 检查..."
            sudo btrfs check "$device"
            ;;
        *)
            echo "不支持的文件系统类型: $fs_type"
            return 1
            ;;
    esac
}

# 使用示例
# FS_CHECKER /dev/sda1
```

#### 1.2.2 坏块检测与修复

```bash
#!/bin/bash
# 坏块检测与修复

# 检查坏块
sudo badblocks -v /dev/sda1

# 带输出的坏块检查
sudo badblocks -sv /dev/sda1 > badblocks.txt

# 使用e2fsck检查并标记坏块
sudo e2fsck -c /dev/sda1

# 坏块检测脚本
BADBLOCK_DETECTOR() {
    local device="$1"
    local output_file="${2:-/tmp/badblocks_$(basename $device).txt}"
    
    if [ -z "$device" ]; then
        echo "用法: $0 <设备> [输出文件]"
        return 1
    fi
    
    echo "=== 坏块检测 ==="
    echo "设备: $device"
    echo "输出文件: $output_file"
    echo ""
    
    # 检查设备
    if [ ! -b "$device" ]; then
        echo "错误: $device 不是有效的块设备"
        return 1
    fi
    
    # 检查文件系统类型
    local fs_type=$(lsblk -no FSTYPE "$device")
    
    case "$fs_type" in
        "ext4"|"ext3"|"ext2")
            echo "检测ext文件系统坏块..."
            sudo badblocks -sv "$device" > "$output_file" 2>&1
            ;;
        *)
            echo "使用通用坏块检测..."
            sudo badblocks -sv "$device" > "$output_file" 2>&1
            ;;
    esac
    
    # 检查结果
    local bad_count=$(grep -c "bad block" "$output_file" 2>/dev/null || echo 0)
    
    if [ "$bad_count" -gt 0 ]; then
        echo "⚠️  发现 $bad_count 个坏块"
        echo "坏块列表:"
        grep "bad block" "$output_file"
    else
        echo "✅ 未发现坏块"
    fi
    
    echo "检测完成，结果保存在: $output_file"
}

# 使用示例
# BADBLOCK_DETECTOR /dev/sda1
```

## 2 文件系统挂载问题

### 2.1 挂载故障排查

#### 2.1.1 挂载状态检查

```bash
#!/bin/bash
# 挂载故障排查

# 查看挂载状态
mount

# 查看/etc/fstab
cat /etc/fstab

# 检查挂载配置
findmnt

# 挂载故障排查脚本
MOUNT_TROUBLESHOOT() {
    local mount_point="$1"
    
    echo "=== 挂载故障排查 ==="
    echo "挂载点: $mount_point"
    echo ""
    
    # 检查挂载点是否存在
    if [ -n "$mount_point" ]; then
        if [ ! -d "$mount_point" ]; then
            echo "❌ 挂载点 $mount_point 不存在"
            echo "创建挂载点:"
            sudo mkdir -p "$mount_point"
            echo "✅ 挂载点已创建"
        fi
        
        # 检查是否已挂载
        if mountpoint -q "$mount_point"; then
            echo "✅ $mount_point 已挂载"
            echo "挂载信息:"
            mount | grep "$mount_point"
            return 0
        else
            echo "⚠️  $mount_point 未挂载"
        fi
    fi
    
    # 检查/etc/fstab配置
    echo ""
    echo "=== /etc/fstab 配置 ==="
    if [ -f /etc/fstab ]; then
        cat /etc/fstab | grep -v "^#" | grep -v "^$"
    else
        echo "❌ /etc/fstab 文件不存在"
    fi
    
    # 检查挂载设备
    echo ""
    echo "=== 可用设备 ==="
    lsblk -f | grep -v "loop"
    
    # 检查文件系统类型
    echo ""
    echo "=== 文件系统类型 ==="
    blkid
}

# 自动挂载修复
AUTO_MOUNT_FIX() {
    local device="$1"
    local mount_point="$2"
    local fs_type="${3:-auto}"
    
    if [ -z "$device" ] || [ -z "$mount_point" ]; then
        echo "用法: $0 <设备> <挂载点> [文件系统类型]"
        return 1
    fi
    
    echo "=== 自动挂载修复 ==="
    echo "设备: $device"
    echo "挂载点: $mount_point"
    echo "文件系统类型: $fs_type"
    echo ""
    
    # 创建挂载点
    if [ ! -d "$mount_point" ]; then
        sudo mkdir -p "$mount_point"
        echo "✅ 挂载点已创建"
    fi
    
    # 检查文件系统
    if [ "$fs_type" != "auto" ]; then
        echo "检查文件系统..."
        case "$fs_type" in
            "ext4"|"ext3"|"ext2")
                sudo fsck -f "$device"
                ;;
            "xfs")
                sudo xfs_repair "$device"
                ;;
        esac
    fi
    
    # 挂载设备
    echo "挂载设备..."
    sudo mount -t "$fs_type" "$device" "$mount_point"
    
    if [ $? -eq 0 ]; then
        echo "✅ 挂载成功"
        echo "添加到/etc/fstab..."
        echo "$device $mount_point $fs_type defaults 0 2" | sudo tee -a /etc/fstab
        echo "✅ 已添加到/etc/fstab"
    else
        echo "❌ 挂载失败"
        return 1
    fi
}

# 使用示例
# MOUNT_TROUBLESHOOT /mnt/data
# AUTO_MOUNT_FIX /dev/sdb1 /mnt/data ext4
```

#### 2.1.2 自动挂载配置

```bash
#!/bin/bash
# 自动挂载配置

# 使用UUID挂载
SETUP_AUTO_MOUNT() {
    local device="$1"
    local mount_point="$2"
    local fs_type="${3:-auto}"
    local options="${4:-defaults}"
    
    if [ -z "$device" ] || [ -z "$mount_point" ]; then
        echo "用法: $0 <设备> <挂载点> [文件系统类型] [挂载选项]"
        return 1
    fi
    
    echo "=== 自动挂载配置 ==="
    echo "设备: $device"
    echo "挂载点: $mount_point"
    echo "文件系统类型: $fs_type"
    echo "挂载选项: $options"
    echo ""
    
    # 获取设备UUID
    local uuid=$(blkid -s UUID -o value "$device")
    if [ -z "$uuid" ]; then
        echo "❌ 无法获取设备UUID"
        return 1
    fi
    
    echo "设备UUID: $uuid"
    
    # 创建挂载点
    if [ ! -d "$mount_point" ]; then
        sudo mkdir -p "$mount_point"
        echo "✅ 挂载点已创建"
    fi
    
    # 测试挂载
    echo "测试挂载..."
    sudo mount -t "$fs_type" UUID="$uuid" "$mount_point"
    
    if [ $? -ne 0 ]; then
        echo "❌ 挂载测试失败"
        return 1
    fi
    
    # 卸载测试挂载
    sudo umount "$mount_point"
    
    # 添加到/etc/fstab
    local fstab_entry="UUID=$uuid $mount_point $fs_type $options 0 2"
    
    # 检查是否已存在
    if grep -q "$uuid" /etc/fstab; then
        echo "⚠️  UUID已存在于/etc/fstab"
    else
        echo "$fstab_entry" | sudo tee -a /etc/fstab
        echo "✅ 已添加到/etc/fstab"
    fi
    
    # 测试/etc/fstab
    echo "测试/etc/fstab配置..."
    sudo mount -a
    
    if [ $? -eq 0 ]; then
        echo "✅ 自动挂载配置成功"
    else
        echo "❌ /etc/fstab配置有误"
        return 1
    fi
}

# 使用示例
# SETUP_AUTO_MOUNT /dev/sdb1 /mnt/data ext4
```

### 2.2 NFS挂载问题

#### 2.2.1 NFS故障排查

```bash
#!/bin/bash
# NFS故障排查

# 检查NFS服务状态
sudo systemctl status nfs-server

# 检查NFS共享
showmount -e localhost

# 检查NFS挂载
mount | grep nfs

# NFS故障排查脚本
NFS_TROUBLESHOOT() {
    local server="$1"
    local mount_point="$2"
    
    echo "=== NFS故障排查 ==="
    echo "服务器: ${server:-localhost}"
    echo "挂载点: $mount_point"
    echo ""
    
    # 检查NFS服务
    echo "1. 检查NFS服务..."
    if systemctl is-active --quiet nfs-server; then
        echo "✅ NFS服务运行正常"
    else
        echo "❌ NFS服务未运行"
        echo "启动NFS服务: sudo systemctl start nfs-server"
    fi
    
    # 检查NFS共享
    echo ""
    echo "2. 检查NFS共享..."
    if [ -n "$server" ]; then
        echo "远程共享:"
        showmount -e "$server" 2>/dev/null || echo "无法连接到NFS服务器"
    else
        echo "本地共享:"
        showmount -e localhost
    fi
    
    # 检查挂载状态
    if [ -n "$mount_point" ]; then
        echo ""
        echo "3. 检查挂载状态..."
        if mountpoint -q "$mount_point"; then
            echo "✅ $mount_point 已挂载"
            mount | grep "$mount_point"
        else
            echo "⚠️  $mount_point 未挂载"
        fi
    fi
    
    # 检查网络连接
    echo ""
    echo "4. 网络连接检查..."
    if [ -n "$server" ]; then
        if ping -c 1 "$server" >/dev/null 2>&1; then
            echo "✅ 网络连接正常"
        else
            echo "❌ 网络连接失败"
        fi
    fi
    
    # 检查防火墙
    echo ""
    echo "5. 防火墙检查..."
    if sudo ufw status | grep -q "Status: active"; then
        echo "防火墙状态: 活跃"
        echo "NFS端口: 2049"
    else
        echo "防火墙状态: 不活跃"
    fi
}

# 自动NFS挂载
AUTO_NFS_MOUNT() {
    local server="$1"
    local remote_path="$2"
    local local_path="$3"
    local options="${4:-defaults}"
    
    if [ -z "$server" ] || [ -z "$remote_path" ] || [ -z "$local_path" ]; then
        echo "用法: $0 <服务器> <远程路径> <本地路径> [挂载选项]"
        return 1
    fi
    
    echo "=== 自动NFS挂载 ==="
    echo "服务器: $server"
    echo "远程路径: $remote_path"
    echo "本地路径: $local_path"
    echo "挂载选项: $options"
    echo ""
    
    # 安装NFS客户端
    if ! command -v showmount >/dev/null 2>&1; then
        echo "安装NFS客户端..."
        sudo apt update && sudo apt install -y nfs-common
    fi
    
    # 创建挂载点
    if [ ! -d "$local_path" ]; then
        sudo mkdir -p "$local_path"
        echo "✅ 挂载点已创建"
    fi
    
    # 检查NFS共享
    echo "检查NFS共享..."
    showmount -e "$server" | grep -q "$remote_path" || {
        echo "❌ 远程路径 $remote_path 不可用"
        return 1
    }
    
    # 测试挂载
    echo "测试挂载..."
    sudo mount -t nfs -o "$options" "$server:$remote_path" "$local_path"
    
    if [ $? -eq 0 ]; then
        echo "✅ 挂载成功"
        
        # 添加到/etc/fstab
        local fstab_entry="$server:$remote_path $local_path nfs $options 0 0"
        
        if ! grep -q "$server:$remote_path" /etc/fstab; then
            echo "$fstab_entry" | sudo tee -a /etc/fstab
            echo "✅ 已添加到/etc/fstab"
        fi
        
        # 测试/etc/fstab
        sudo mount -a
        if [ $? -eq 0 ]; then
            echo "✅ 自动挂载配置成功"
        fi
    else
        echo "❌ 挂载失败"
        return 1
    fi
}

# 使用示例
# NFS_TROUBLESHOOT 192.168.1.100 /mnt/nfs
# AUTO_NFS_MOUNT 192.168.1.100:/shared /mnt/nfs
```

## 3 文件权限与访问问题

### 3.1 权限修复

#### 3.1.1 权限诊断

```bash
#!/bin/bash
# 权限诊断与修复

# 检查文件权限
ls -la /path/to/file

# 检查文件所有者
ls -ln /path/to/file

# 检查ACL权限
getfacl /path/to/file

# 权限诊断脚本
PERMISSION_DIAGNOSTIC() {
    local target="$1"
    
    if [ -z "$target" ]; then
        echo "用法: $0 <文件或目录>"
        return 1
    fi
    
    if [ ! -e "$target" ]; then
        echo "错误: $target 不存在"
        return 1
    fi
    
    echo "=== 权限诊断 ==="
    echo "目标: $target"
    echo ""
    
    # 基本权限信息
    echo "1. 基本权限信息:"
    ls -ld "$target"
    echo ""
    
    # 文件所有者
    echo "2. 所有者信息:"
    local owner=$(stat -c "%U:%G" "$target")
    local uid_gid=$(stat -c "%u:%g" "$target")
    echo "所有者: $owner (UID:GID: $uid_gid)"
    echo ""
    
    # 权限位分析
    echo "3. 权限位分析:"
    local perms=$(stat -c "%A" "$target")
    echo "权限: $perms"
    
    # 权限解释
    local owner_perms=${perms:1:3}
    local group_perms=${perms:4:3}
    local other_perms=${perms:7:3}
    
    echo "所有者权限: $owner_perms"
    echo "组权限: $group_perms"
    echo "其他用户权限: $other_perms"
    echo ""
    
    # ACL权限
    if command -v getfacl >/dev/null 2>&1; then
        echo "4. ACL权限:"
        getfacl "$target" 2>/dev/null | head -10
        echo ""
    fi
    
    # 访问测试
    echo "5. 访问测试:"
    if [ -r "$target" ]; then
        echo "✅ 可读"
    else
        echo "❌ 不可读"
    fi
    
    if [ -w "$target" ]; then
        echo "✅ 可写"
    else
        echo "❌ 不可写"
    fi
    
    if [ -x "$target" ]; then
        echo "✅ 可执行"
    else
        echo "❌ 不可执行"
    fi
    
    # 建议
    echo ""
    echo "6. 修复建议:"
    if [ -f "$target" ]; then
        echo "修复文件权限: sudo chmod 644 '$target'"
        echo "修复所有者: sudo chown $(whoami):$(whoami) '$target'"
    elif [ -d "$target" ]; then
        echo "修复目录权限: sudo chmod 755 '$target'"
        echo "修复所有者: sudo chown $(whoami):$(whoami) '$target'"
    fi
}

# 批量权限修复
BULK_PERMISSION_FIX() {
    local directory="$1"
    local user="${2:-$(whoami)}"
    local group="${3:-$(whoami)}"
    
    if [ -z "$directory" ]; then
        echo "用法: $0 <目录> [用户] [组]"
        return 1
    fi
    
    if [ ! -d "$directory" ]; then
        echo "错误: $directory 不是有效的目录"
        return 1
    fi
    
    echo "=== 批量权限修复 ==="
    echo "目录: $directory"
    echo "用户: $user"
    echo "组: $group"
    echo ""
    
    # 确认操作
    read -p "确认修复 $directory 及其子目录的权限? (y/N): " -n 1 -r
    echo
    
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "操作已取消"
        return 1
    fi
    
    # 修复目录权限
    echo "修复目录权限..."
    find "$directory" -type d -exec sudo chmod 755 {} \;
    
    # 修复文件权限
    echo "修复文件权限..."
    find "$directory" -type f -exec sudo chmod 644 {} \;
    
    # 修复所有者
    echo "修复所有者..."
    find "$directory" -exec sudo chown "$user:$group" {} \;
    
    echo "✅ 权限修复完成"
}

# 使用示例
# PERMISSION_DIAGNOSTIC /home/user/file.txt
# BULK_PERMISSION_FIX /home/user/projects
```

#### 3.1.2 特殊权限修复

```bash
#!/bin/bash
# 特殊权限修复

# 修复sudo权限
FIX_SUDO_PERMISSIONS() {
    echo "=== 修复sudo权限 ==="
    
    # 检查sudoers文件权限
    if [ -f /etc/sudoers ]; then
        current_perms=$(stat -c "%a" /etc/sudoers)
        if [ "$current_perms" != "440" ]; then
            echo "修复sudoers文件权限..."
            sudo chmod 440 /etc/sudoers
            echo "✅ sudoers权限已修复"
        else
            echo "✅ sudoers权限正确"
        fi
    fi
    
    # 检查sudoers.d目录权限
    if [ -d /etc/sudoers.d ]; then
        sudo chmod 755 /etc/sudoers.d
        sudo chmod 440 /etc/sudoers.d/* 2>/dev/null || true
        echo "✅ sudoers.d权限已修复"
    fi
}

# 修复SSH权限
FIX_SSH_PERMISSIONS() {
    echo "=== 修复SSH权限 ==="
    
    local ssh_dir="$HOME/.ssh"
    
    if [ -d "$ssh_dir" ]; then
        # 修复.ssh目录权限
        chmod 700 "$ssh_dir"
        echo "✅ .ssh目录权限已修复"
        
        # 修复私钥权限
        find "$ssh_dir" -type f -name "id_*" ! -name "*.pub" -exec chmod 600 {} \;
        echo "✅ SSH私钥权限已修复"
        
        # 修复公钥权限
        find "$ssh_dir" -type f -name "*.pub" -exec chmod 644 {} \;
        echo "✅ SSH公钥权限已修复"
        
        # 修复authorized_keys权限
        if [ -f "$ssh_dir/authorized_keys" ]; then
            chmod 600 "$ssh_dir/authorized_keys"
            echo "✅ authorized_keys权限已修复"
        fi
    else
        echo "⚠️  未找到SSH目录: $ssh_dir"
    fi
}

# 修复系统文件权限
FIX_SYSTEM_PERMISSIONS() {
    echo "=== 修复系统文件权限 ==="
    
    # 修复重要系统文件
    local system_files=(
        "/etc/passwd:644"
        "/etc/shadow:640"
        "/etc/group:644"
        "/etc/gshadow:640"
        "/etc/sudoers:440"
    )
    
    for entry in "${system_files[@]}"; do
        local file=$(echo "$entry" | cut -d: -f1)
        local perms=$(echo "$entry" | cut -d: -f2)
        
        if [ -f "$file" ]; then
            current_perms=$(stat -c "%a" "$file")
            if [ "$current_perms" != "$perms" ]; then
                echo "修复 $file 权限..."
                sudo chmod "$perms" "$file"
                echo "✅ $file 权限已修复"
            else
                echo "✅ $file 权限正确"
            fi
        fi
    done
}

# 使用示例
# FIX_SUDO_PERMISSIONS
# FIX_SSH_PERMISSIONS
# FIX_SYSTEM_PERMISSIONS
```

## 4 文件系统性能优化

### 4.1 文件系统调优

#### 4.1.1 挂载选项优化

```bash
#!/bin/bash
# 文件系统挂载优化

# 查看当前挂载选项
mount | grep "/dev/"

# 优化挂载选项
OPTIMIZE_MOUNT() {
    local device="$1"
    local mount_point="$2"
    local fs_type="$3"
    
    if [ -z "$device" ] || [ -z "$mount_point" ] || [ -z "$fs_type" ]; then
        echo "用法: $0 <设备> <挂载点> <文件系统类型>"
        return 1
    fi
    
    echo "=== 文件系统挂载优化 ==="
    echo "设备: $device"
    echo "挂载点: $mount_point"
    echo "文件系统类型: $fs_type"
    echo ""
    
    # 根据文件系统类型设置优化选项
    local mount_options="defaults"
    
    case "$fs_type" in
        "ext4")
            mount_options="defaults,noatime,nodiratime,errors=remount-ro"
            ;;
        "xfs")
            mount_options="defaults,noatime,nodiratime,logbufs=8,logbsize=256k"
            ;;
        "btrfs")
            mount_options="defaults,noatime,nodiratime,compress=lzo,space_cache"
            ;;
        *)
            mount_options="defaults,noatime"
            ;;
    esac
    
    echo "优化挂载选项: $mount_options"
    
    # 创建挂载点
    if [ ! -d "$mount_point" ]; then
        sudo mkdir -p "$mount_point"
        echo "✅ 挂载点已创建"
    fi
    
    # 测试挂载
    echo "测试优化挂载..."
    sudo mount -t "$fs_type" -o "$mount_options" "$device" "$mount_point"
    
    if [ $? -eq 0 ]; then
        echo "✅ 优化挂载成功"
        
        # 添加到/etc/fstab
        local uuid=$(blkid -s UUID -o value "$device")
        local fstab_entry="UUID=$uuid $mount_point $fs_type $mount_options 0 2"
        
        # 备份/etc/fstab
        sudo cp /etc/fstab /etc/fstab.backup.$(date +%Y%m%d)
        
        # 更新/etc/fstab
        if ! grep -q "$uuid" /etc/fstab; then
            echo "$fstab_entry" | sudo tee -a /etc/fstab
            echo "✅ 已更新/etc/fstab"
        else
            echo "⚠️  UUID已存在于/etc/fstab"
        fi
    else
        echo "❌ 优化挂载失败"
        return 1
    fi
}

# 文件系统性能测试
FS_PERFORMANCE_TEST() {
    local mount_point="$1"
    
    if [ -z "$mount_point" ] || [ ! -d "$mount_point" ]; then
        echo "用法: $0 <挂载点>"
        return 1
    fi
    
    echo "=== 文件系统性能测试 ==="
    echo "挂载点: $mount_point"
    echo ""
    
    # 测试写入性能
    echo "1. 写入性能测试..."
    local write_file="$mount_point/test_write_$$"
    time dd if=/dev/zero of="$write_file" bs=1M count=100 2>/dev/null
    rm -f "$write_file"
    
    # 测试读取性能
    echo "2. 读取性能测试..."
    local read_file="$mount_point/test_read_$$"
    dd if=/dev/zero of="$read_file" bs=1M count=50 2>/dev/null
    time dd if="$read_file" of=/dev/null bs=1M 2>/dev/null
    rm -f "$read_file"
    
    # 测试随机读写
    echo "3. 随机读写测试..."
    if command -v fio >/dev/null 2>&1; then
        fio --name=randrw --ioengine=libaio --rw=randrw --bs=4k --numjobs=1 --size=100M --runtime=10 --group_reporting --directory="$mount_point"
    else
        echo "安装fio进行详细性能测试: sudo apt install fio"
    fi
}

# 使用示例
# OPTIMIZE_MOUNT /dev/sdb1 /mnt/data ext4
# FS_PERFORMANCE_TEST /mnt/data
```

这些文件系统问题的诊断和解决方案涵盖了从基础的磁盘空间管理到复杂的文件系统性能优化的各个方面，为系统管理员提供了全面的故障排查工具集。