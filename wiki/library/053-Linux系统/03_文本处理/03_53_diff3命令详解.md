# 03_53_diff3命令详解

## 1. 命令概述

`diff3`命令是Linux系统中的一个文件比较工具，用于同时比较三个文件的内容并显示它们之间的差异。它是`diff`命令的扩展，但专门设计用于处理三个文件的比较场景，特别是在版本控制和代码合并过程中解决冲突。`diff3`命令不仅可以显示三个文件之间的具体差异，还可以生成合并解决方案，帮助用户解决文件合并过程中的冲突。

`diff3`命令的主要功能包括：

- **三路比较**：同时比较三个文件的内容并显示它们之间的差异
- **合并解决方案**：生成解决文件合并冲突的解决方案
- **冲突标记**：在合并结果中标记冲突区域，方便用户手动解决
- **自动合并**：尝试自动合并三个文件，解决非冲突的差异
- **版本控制支持**：特别适合与版本控制系统配合使用，解决代码合并冲突

## 2. 语法格式

`diff3`命令的基本语法格式如下：

```bash
diff3 [选项]... 文件1 文件2 文件3
```

其中：
- `[选项]`：控制比较方式和输出格式的参数
- `文件1`、`文件2`和`文件3`：要比较的三个文件

## 3. 常用选项

| 选项 | 说明 | 示例 |
|------|------|------|
| `-a` 或 `--text` | 将所有文件视为文本文件进行比较 | `diff3 -a binary_file1 binary_file2 binary_file3` |
| `-A` 或 `--show-all` | 显示所有文件的所有行，包括冲突行 | `diff3 -A file1.txt file2.txt file3.txt` |
| `-e` 或 `--ed` | 生成ed编辑器命令，用于将文件1转换为合并结果 | `diff3 -e file1.txt file2.txt file3.txt` |
| `-E` 或 `--show-overlap` | 在冲突区域显示重叠的行 | `diff3 -E file1.txt file2.txt file3.txt` |
| `-i` 或 `--ignore-case` | 忽略大小写的差异 | `diff3 -i file1.txt file2.txt file3.txt` |
| `-l` 或 `--label` | 为文件指定标签 | `diff3 -l LABEL1 -l LABEL2 -l LABEL3 file1.txt file2.txt file3.txt` |
| `-m` 或 `--merge` | 自动合并文件，不显示冲突标记 | `diff3 -m file1.txt file2.txt file3.txt` |
| `-L` 或 `--label=标签` | 为每个文件指定标签 | `diff3 -L "版本1" -L "当前" -L "版本2" file1.txt file2.txt file3.txt` |
| `-n` 或 `--rcs` | 生成RCS格式的合并命令 | `diff3 -n file1.txt file2.txt file3.txt` |
| `-T` 或 `--initial-tab` | 在输出中每行前添加制表符，保持对齐 | `diff3 -T file1.txt file2.txt file3.txt` |
| `-v` 或 `--version` | 显示版本信息 | `diff3 --version` |
| `-x` 或 `--overlap-only` | 仅显示重叠的行（冲突区域） | `diff3 -x file1.txt file2.txt file3.txt` |
| `-X` 或 `--show-overlap-only` | 与`-x`相同，仅显示冲突区域 | `diff3 -X file1.txt file2.txt file3.txt` |
| `--help` | 显示帮助信息 | `diff3 --help` |

## 4. 基本用法

### 4.1 三路文件比较

**示例1：基本三路比较**

假设有三个文件`file1.txt`、`file2.txt`和`file3.txt`，内容分别为：

```
# file1.txt
apple
banana
cherry
date
elderberry
```

```
# file2.txt
apple
orange
cherry
grape
fig
```

```
# file3.txt
apple
pear
cherry
date
fig
kiwi
```

执行以下命令：

```bash
diff3 file1.txt file2.txt file3.txt
```

输出结果类似于：

```
====1
apple
====2
apple
====3
apple
<<<<<<<
banana
======
orange
>>>>>>>
cherry
====1
date
====2
grape
====3
date
====1
elderberry
====2
fig
====3
fig
kiwi
```

这个输出使用特殊标记来区分三个文件的内容：
- `====1`：表示接下来的内容来自第一个文件
- `====2`：表示接下来的内容来自第二个文件
- `====3`：表示接下来的内容来自第三个文件
- `<<<<<<<` 和 `>>>>>>>`：包围冲突区域
- `======`：分隔不同文件的冲突内容

**示例2：显示所有行，包括冲突行**

```bash
diff3 -A file1.txt file2.txt file3.txt
```

输出结果类似于：

```
====1
apple
====2
apple
====3
apple
<<<<<<<
banana
======
orange
>>>>>>>
cherry
====1
date
====2
grape
====3
date
====1
elderberry
====2
fig
====3
fig
kiwi
```

此命令显示三个文件的所有行，包括冲突行，使用特殊标记区分不同文件的内容。

**示例3：使用标签指定文件名称**

```bash
diff3 -L "原始版本" -L "我的版本" -L "他人版本" file1.txt file2.txt file3.txt
```

输出结果类似于：

```
====原始版本
apple
====我的版本
apple
====他人版本
apple
<<<<<<<
banana
======
orange
>>>>>>>
cherry
====原始版本
date
====我的版本
grape
====他人版本
date
====原始版本
elderberry
====我的版本
fig
====他人版本
fig
kiwi
```

此命令使用用户指定的标签代替默认的数字标签，使输出更容易理解。

### 4.2 生成合并解决方案

**示例4：生成ed编辑器合并命令**

```bash
diff3 -e file1.txt file2.txt file3.txt > merge_script.ed
```

此命令生成ed编辑器脚本`merge_script.ed`，可以将`file1.txt`转换为合并结果。ed脚本包含一系列编辑命令，用于应用`file2.txt`和`file3.txt`中的更改到`file1.txt`。

**示例5：应用合并脚本**

```bash
echo 'w' >> merge_script.ed
ed - file1.txt < merge_script.ed
```

此命令应用合并脚本`merge_script.ed`到`file1.txt`文件，并保存更改。首先，我们向脚本添加一个`w`命令以保存更改，然后使用ed编辑器执行脚本。

**示例6：生成RCS格式的合并命令**

```bash
diff3 -n file1.txt file2.txt file3.txt > merge_script.rcs
```

此命令生成RCS（Revision Control System）格式的合并脚本`merge_script.rcs`，可以用于RCS版本控制系统中的合并操作。

### 4.3 自动合并文件

**示例7：自动合并三个文件**

```bash
diff3 -m file1.txt file2.txt file3.txt > merged_file.txt
```

此命令尝试自动合并三个文件，并将结果保存到`merged_file.txt`。如果存在无法自动解决的冲突，合并结果中将包含冲突标记，需要用户手动解决。

**示例8：合并文件并显示冲突标记**

```bash
diff3 -E -m file1.txt file2.txt file3.txt > merged_file.txt
```

此命令尝试自动合并三个文件，并在冲突区域显示重叠的行，使用特殊标记标记冲突。

**示例9：仅显示冲突区域**

```bash
diff3 -x file1.txt file2.txt file3.txt
```

此命令仅显示三个文件之间的冲突区域（重叠的行），不显示其他内容。这对于快速定位和解决冲突非常有用。

## 5. 高级用法与技巧

### 5.1 版本控制中的冲突解决

**示例10：解决Git合并冲突**

在Git版本控制系统中，当合并分支时遇到冲突，可以使用`diff3`命令帮助解决冲突。假设我们有一个文件`example.txt`存在合并冲突，Git已经将冲突标记添加到文件中：

```
<<<<<<< HEAD
apple
banana
cherry
=======
apple
orange
cherry
grape
>>>>>>> feature_branch
```

首先，我们需要获取冲突文件的三个版本：

```bash
# 获取共同的祖先版本
git show :1:example.txt > ancestor.txt
# 获取当前分支版本
git show :2:example.txt > current.txt
# 获取要合并的分支版本
git show :3:example.txt > other.txt
```

然后，使用`diff3`命令比较这三个版本：

```bash
diff3 -A ancestor.txt current.txt other.txt
```

或者，直接使用`diff3`命令生成合并解决方案：

```bash
diff3 -m ancestor.txt current.txt other.txt > example.txt
```

最后，检查合并结果并提交：

```bash
cat example.txt
# 检查合并结果，解决剩余冲突（如果有）
git add example.txt
git commit -m "Resolve merge conflict"
```

**示例11：批量解决Git合并冲突**

```bash
#!/bin/bash
# 批量解决Git合并冲突

# 使用方法：./batch_resolve_conflicts.sh

# 获取所有存在冲突的文件
conflicted_files=$(git status --porcelain | grep '^UU' | cut -d ' ' -f 2)

if [ -z "$conflicted_files" ]; then
  echo "没有找到冲突文件。"
  exit 0
fi

echo "找到以下冲突文件："
echo "$conflicted_files"

# 为每个冲突文件创建临时目录
temp_dir=$(mktemp -d)
echo "创建临时目录：$temp_dir"

# 解决每个文件的冲突
for file in $conflicted_files; do
  echo -e "\n解决文件冲突：$file"
  
  # 获取三个版本的文件
  git show :1:"$file" > "$temp_dir/ancestor.txt"
  git show :2:"$file" > "$temp_dir/current.txt"
  git show :3:"$file" > "$temp_dir/other.txt"
  
  # 显示三个版本的差异
echo "显示三个版本的差异："
diff3 -A "$temp_dir/ancestor.txt" "$temp_dir/current.txt" "$temp_dir/other.txt" | less -R
  
  # 询问用户是否自动合并
  read -p "是否尝试自动合并此文件？(y/n) " auto_merge
  if [ "$auto_merge" = "y" ] || [ "$auto_merge" = "Y" ]; then
    # 尝试自动合并
    diff3 -m "$temp_dir/ancestor.txt" "$temp_dir/current.txt" "$temp_dir/other.txt" > "$file"
    
    # 检查是否还有冲突
    if grep -q '<<<<<<<' "$file" || grep -q '=======' "$file" || grep -q '>>>>>>>' "$file"; then
      echo "自动合并后仍有冲突，需要手动解决。"
      # 打开文件编辑器让用户手动解决冲突
      read -p "请输入您喜欢的编辑器（默认为vim）：" editor
      editor=${editor:-vim}
      $editor "$file"
    else
      echo "自动合并成功！"
    fi
    
    # 添加解决冲突后的文件
    git add "$file"
  fi
done

# 清理临时目录
rm -rf "$temp_dir"
echo "\n临时目录已清理。"
echo "\n冲突解决完成，请检查结果并提交。"
```

此脚本批量解决Git合并冲突，它使用`diff3`命令获取和比较冲突文件的三个版本，并尝试自动合并或让用户手动解决冲突。

### 5.2 代码合并与审查

**示例12：三路代码合并工具**

```bash
#!/bin/bash
# 三路代码合并工具

# 使用方法：./three_way_merge.sh base_file your_file their_file output_file

if [ $# -ne 4 ]; then
  echo "使用方法：$0 base_file your_file their_file output_file"
  echo "示例：$0 base.c your.c their.c merged.c"
  exit 1
fi

base_file=$1
your_file=$2
their_file=$3
output_file=$4

# 确保文件存在
for file in "$base_file" "$your_file" "$their_file"; do
  if [ ! -f "$file" ]; then
    echo "错误：文件 $file 不存在！"
    exit 1
  fidone

# 显示三个文件的差异
echo "=== 三个文件的差异比较 ==="
diff3 -A "$base_file" "$your_file" "$their_file" | less -R

# 生成合并解决方案
echo -e "\n=== 生成合并解决方案 ==="
diff3 -m "$base_file" "$your_file" "$their_file" > "$output_file"

# 检查是否有冲突
if grep -q '<<<<<<<' "$output_file" || grep -q '=======' "$output_file" || grep -q '>>>>>>>' "$output_file"; then
  echo "合并后存在冲突，请手动解决。"
  # 显示冲突内容
  echo -e "\n=== 冲突内容 ==="
  grep -n -A 1 -B 1 '<<<<<<<\|=======\|>>>>>>>' "$output_file"
  
  # 询问用户是否打开编辑器解决冲突
  read -p "是否打开编辑器解决冲突？(y/n) " edit_conflicts
  if [ "$edit_conflicts" = "y" ] || [ "$edit_conflicts" = "Y" ]; then
    read -p "请输入您喜欢的编辑器（默认为vim）：" editor
    editor=${editor:-vim}
    $editor "$output_file"
  fi
else
  echo "合并成功，没有冲突！"
fi

# 显示合并结果统计
added_lines=$(diff -u "$base_file" "$output_file" | grep -c '^+[^+]')
removed_lines=$(diff -u "$base_file" "$output_file" | grep -c '^-[^-]')

echo -e "\n=== 合并结果统计 ==="
echo "输出文件：$output_file"
echo "新增行数：$added_lines"
echo "删除行数：$removed_lines"
echo "总修改行数：$((added_lines + removed_lines))"
```

此脚本是一个三路代码合并工具，它使用`diff3`命令比较三个版本的代码文件，并尝试自动合并它们，同时提供冲突解决功能和合并结果统计。

**示例13：代码审查与合并报告生成器**

```bash
#!/bin/bash
# 代码审查与合并报告生成器

# 使用方法：./code_review_merge.sh base_file your_file their_file reviewer

if [ $# -ne 4 ]; then
  echo "使用方法：$0 base_file your_file their_file reviewer"
  echo "示例：$0 base.c your.c their.c alice"
  exit 1
fi

base_file=$1
your_file=$2
their_file=$3
reviewer=$4

# 确保文件存在
for file in "$base_file" "$your_file" "$their_file"; do
  if [ ! -f "$file" ]; then
    echo "错误：文件 $file 不存在！"
    exit 1
  fidone

# 生成报告文件名
report_file="merge_report_$(basename "$base_file")_$(date +%Y%m%d_%H%M%S).txt"

# 写入报告头部
cat > "$report_file" << EOF
==========================
代码审查与合并报告
==========================
基础文件: $base_file
您的文件: $your_file
他人文件: $their_file
审查人: $reviewer
审查日期: $(date)
==========================
EOF

# 生成三个文件的差异比较
diff3 -A "$base_file" "$your_file" "$their_file" > "$report_file.tmp"

# 分析差异
conflicts=$(grep -c '<<<<<<<' "$report_file.tmp")

# 写入差异分析
cat >> "$report_file" << EOF

差异分析:
- 冲突数量: $conflicts

详细差异比较:
EOF

# 写入详细差异
cat "$report_file.tmp" >> "$report_file"

# 添加合并建议
cat >> "$report_file" << EOF

==========================
合并建议
==========================

1. 使用diff3命令自动合并：
   diff3 -m $base_file $your_file $their_file > merged_file.txt

2. 如果有冲突，手动解决冲突后，检查合并结果：
   diff -u $base_file merged_file.txt

3. 确认合并结果无误后，提交更改。

==========================
审查意见（请在此处添加）
==========================

1.

2.

3.
EOF

# 清理临时文件
rm "$report_file.tmp"

# 显示完成信息
echo "代码审查与合并报告已生成：$report_file"
echo "请使用文本编辑器打开报告并添加审查意见。"
```

此脚本生成代码审查与合并报告，它使用`diff3`命令比较三个版本的代码文件，并创建一个包含差异分析、冲突数量和合并建议的报告。

### 5.3 配置文件合并与管理

**示例14：配置文件三路合并工具**

```bash
#!/bin/bash
# 配置文件三路合并工具

# 使用方法：./config_merge.sh base_config your_config their_config output_config

if [ $# -ne 4 ]; then
  echo "使用方法：$0 base_config your_config their_config output_config"
  echo "示例：$0 base.conf your.conf their.conf merged.conf"
  exit 1
fi

base_config=$1
your_config=$2
their_config=$3
output_config=$4

# 确保文件存在
for file in "$base_config" "$your_config" "$their_config"; do
  if [ ! -f "$file" ]; then
    echo "错误：文件 $file 不存在！"
    exit 1
  fidone

# 创建备份
backup_dir="./config_backups"
mkdir -p "$backup_dir"
backup_suffix="_backup_$(date +%Y%m%d_%H%M%S)"
cp "$your_config" "$backup_dir/$(basename "$your_config")$backup_suffix"
echo "已创建配置文件备份：$backup_dir/$(basename "$your_config")$backup_suffix"

# 显示三个配置文件的差异
echo "=== 三个配置文件的差异比较 ==="
diff3 -A "$base_config" "$your_config" "$their_config" | less -R

# 生成合并解决方案
echo -e "\n=== 生成配置文件合并解决方案 ==="

# 对于配置文件，我们可能需要特殊处理，如忽略注释和空白行
# 首先，过滤三个文件，移除注释和空白行
grep -v '^[[:space:]]*#' "$base_config" | grep -v '^[[:space:]]*$' > "$base_config.filtered"
grep -v '^[[:space:]]*#' "$your_config" | grep -v '^[[:space:]]*$' > "$your_config.filtered"
grep -v '^[[:space:]]*#' "$their_config" | grep -v '^[[:space:]]*$' > "$their_config.filtered"

# 比较过滤后的文件
diff3 -m "$base_config.filtered" "$your_config.filtered" "$their_config.filtered" > "$output_config.filtered"

# 合并回原始格式（保留注释和空白行）
# 这里使用简单的方法，您可能需要根据配置文件的格式调整
cat "$base_config" | while read line; do
  # 如果是注释或空白行，直接保留
  if [[ $line =~ ^[[:space:]]*# ]] || [[ $line =~ ^[[:space:]]*$ ]]; then
    echo "$line" >> "$output_config"
  else
    # 否则，从过滤后的合并结果中查找对应的行
    key=$(echo "$line" | cut -d '=' -f 1 | tr -d ' ')
    if grep -q "^$key=" "$output_config.filtered"; then
      grep "^$key=" "$output_config.filtered" >> "$output_config"
    fi
  fidone

# 清理临时文件
rm "$base_config.filtered" "$your_config.filtered" "$their_config.filtered" "$output_config.filtered"

# 检查是否有冲突
if grep -q '<<<<<<<' "$output_config" || grep -q '=======' "$output_config" || grep -q '>>>>>>>' "$output_config"; then
  echo "合并后存在冲突，请手动解决。"
  # 显示冲突内容
  echo -e "\n=== 冲突内容 ==="
  grep -n -A 1 -B 1 '<<<<<<<\|=======\|>>>>>>>' "$output_config"
  
  # 询问用户是否打开编辑器解决冲突
  read -p "是否打开编辑器解决冲突？(y/n) " edit_conflicts
  if [ "$edit_conflicts" = "y" ] || [ "$edit_conflicts" = "Y" ]; then
    read -p "请输入您喜欢的编辑器（默认为vim）：" editor
    editor=${editor:-vim}
    $editor "$output_config"
  fi
else
  echo "合并成功，没有冲突！"
fi

# 显示合并结果统计
added_lines=$(diff -u "$your_config" "$output_config" | grep -c '^+[^+]')
removed_lines=$(diff -u "$your_config" "$output_config" | grep -c '^-[^-]')

echo -e "\n=== 合并结果统计 ==="
echo "输出配置文件：$output_config"
echo "新增配置项：$added_lines"
echo "删除配置项：$removed_lines"
echo "总修改配置项：$((added_lines + removed_lines))"
```

此脚本是一个配置文件三路合并工具，它使用`diff3`命令比较三个版本的配置文件，并尝试自动合并它们，同时提供冲突解决功能和合并结果统计。对于配置文件，脚本还特别处理了注释和空白行。

### 5.4 批量合并文件

**示例15：批量三路合并工具**

```bash
#!/bin/bash
# 批量三路合并工具

# 使用方法：./batch_three_way_merge.sh base_dir your_dir their_dir output_dir

if [ $# -ne 4 ]; then
  echo "使用方法：$0 base_dir your_dir their_dir output_dir"
  echo "示例：$0 ./base ./your ./their ./merged"
  exit 1
fi

base_dir=$1
your_dir=$2
their_dir=$3
output_dir=$4

# 确保目录存在
for dir in "$base_dir" "$your_dir" "$their_dir"; do
  if [ ! -d "$dir" ]; then
    echo "错误：目录 $dir 不存在！"
    exit 1
  fidone

# 创建输出目录
mkdir -p "$output_dir"

# 获取基础目录中的文件列表
base_files=$(find "$base_dir" -type f | sed "s|^$base_dir/||")

total_files=$(echo "$base_files" | wc -w)
merged_files=0
conflicted_files=0

# 合并每个文件
echo "开始批量合并 $total_files 个文件..."
echo "=========================="

for file in $base_files; do
  base_file="$base_dir/$file"
your_file="$your_dir/$file"
their_file="$their_dir/$file"
output_file="$output_dir/$file"
  
  # 确保文件存在
  if [ ! -f "$your_file" ]; then
    echo "警告：文件 $your_file 不存在，跳过。"
    continue
  fi
  
  if [ ! -f "$their_file" ]; then
    echo "警告：文件 $their_file 不存在，跳过。"
    continue
  fi
  
  # 创建输出文件的目录
  mkdir -p "$(dirname "$output_file")"
  
  # 合并文件
  diff3 -m "$base_file" "$your_file" "$their_file" > "$output_file"
  
  # 检查是否有冲突
  if grep -q '<<<<<<<' "$output_file" || grep -q '=======' "$output_file" || grep -q '>>>>>>>' "$output_file"; then
    echo "文件 $file：存在冲突"
    conflicted_files=$((conflicted_files + 1))
  else
    echo "文件 $file：合并成功"
  fi
  
  merged_files=$((merged_files + 1))
done

# 显示总结信息
echo "=========================="
echo "批量合并完成！"
echo "总文件数：$total_files"
echo "已合并文件数：$merged_files"
echo "存在冲突的文件数：$conflicted_files"
echo "合并结果保存在：$output_dir"

if [ $conflicted_files -gt 0 ]; then
  echo -e "\n注意：有 $conflicted_files 个文件存在冲突，需要手动解决。"
  echo "您可以使用以下命令查找冲突文件："
  echo "grep -r '<<<<<<<' $output_dir"
fi
```

此脚本是一个批量三路合并工具，它使用`diff3`命令批量合并三个目录中的文件，统计合并成功和存在冲突的文件数量，并提供查找冲突文件的方法。

### 5.5 与其他命令结合使用

**示例16：与sort和uniq结合使用**

```bash
# 比较三个未排序的文件
diff3 <(sort file1.txt) <(sort file2.txt) <(sort file3.txt)
```

此命令首先使用`sort`命令对三个文件进行排序，然后使用进程替换（`<()`）将结果传递给`diff3`命令进行比较。这对于比较三个未排序的文件非常有用。

**示例17：与grep结合使用**

```bash
# 查找特定模式的差异
diff3 file1.txt file2.txt file3.txt | grep '<<<<<<<\|=======\|>>>>>>>'
```

此命令使用`diff3`命令比较三个文件，然后使用`grep`命令仅显示冲突标记，帮助快速定位冲突区域。

**示例18：与awk结合使用**

```bash
# 统计每个文件的唯一行
diff3 file1.txt file2.txt file3.txt | awk 'BEGIN {count1=0; count2=0; count3=0} /^====1$/ {flag=1} /^====2$/ {flag=2} /^====3$/ {flag=3} /^<<<<<<<\|=======\|>>>>>>>$/ {flag=0} flag==1 && !/^====1$/ {count1++} flag==2 && !/^====2$/ {count2++} flag==3 && !/^====3$/ {count3++} END {print "File1 unique lines: " count1; print "File2 unique lines: " count2; print "File3 unique lines: " count3}'
```

此命令使用`diff3`命令比较三个文件，然后使用`awk`命令统计每个文件的唯一行数量。这对于分析三个文件的内容差异非常有用。

## 6. 实用技巧

### 6.1 交互式三路合并工具

**示例19：交互式三路合并工具**

```bash
#!/bin/bash
# 交互式三路合并工具

# 使用方法：./interactive_three_way_merge.sh base_file your_file their_file

if [ $# -ne 3 ]; then
  echo "使用方法：$0 base_file your_file their_file"
  echo "示例：$0 base.txt your.txt their.txt"
  exit 1
fi

base_file=$1
your_file=$2
their_file=$3

# 确保文件存在
for file in "$base_file" "$your_file" "$their_file"; do
  if [ ! -f "$file" ]; then
    echo "错误：文件 $file 不存在！"
    exit 1
  fidone

# 生成临时输出文件名
output_file="${base_file}_merged_$(date +%Y%m%d_%H%M%S).txt"

# 显示菜单
while true; do
  clear
  echo "====== 交互式三路合并工具 ======"
  echo "1. 显示三个文件的详细差异"
  echo "2. 自动合并（不标记冲突）"
  echo "3. 自动合并并标记冲突"
  echo "4. 仅显示冲突区域"
  echo "5. 生成ed编辑器合并命令"
  echo "6. 生成RCS格式合并命令"
  echo "7. 使用您的版本（忽略他人版本）"
  echo "8. 使用他人版本（忽略您的版本）"
  echo "9. 查看合并结果"
  echo "0. 退出并保存结果"
  echo "=============================="
  read -p "请选择操作（0-9）：" choice
  
  case $choice in
    1)
      echo -e "\n=== 三个文件的详细差异 ==="
      diff3 -A "$base_file" "$your_file" "$their_file" | less -R
      read -p "按Enter键继续..."
      ;;
    2)
      echo -e "\n=== 自动合并（不标记冲突） ==="
      diff3 -m "$base_file" "$your_file" "$their_file" > "$output_file"
      echo "合并结果已保存到：$output_file"
      read -p "按Enter键继续..."
      ;;
    3)
      echo -e "\n=== 自动合并并标记冲突 ==="
      diff3 -E -m "$base_file" "$your_file" "$their_file" > "$output_file"
      echo "合并结果已保存到：$output_file"
      # 检查是否有冲突
      if grep -q '<<<<<<<' "$output_file" || grep -q '=======' "$output_file" || grep -q '>>>>>>>' "$output_file"; then
        echo "警告：合并后存在冲突！"
      fi
      read -p "按Enter键继续..."
      ;;
    4)
      echo -e "\n=== 仅显示冲突区域 ==="
      diff3 -x "$base_file" "$your_file" "$their_file" | less -R
      read -p "按Enter键继续..."
      ;;
    5)
      ed_script="${base_file}_merge.ed"
      diff3 -e "$base_file" "$your_file" "$their_file" > "$ed_script"
      echo "ed编辑器合并命令已保存到：$ed_script"
      echo "使用方法：ed - $base_file < $ed_script"
      read -p "按Enter键继续..."
      ;;
    6)
      rcs_script="${base_file}_merge.rcs"
      diff3 -n "$base_file" "$your_file" "$their_file" > "$rcs_script"
      echo "RCS格式合并命令已保存到：$rcs_script"
      read -p "按Enter键继续..."
      ;;
    7)
      echo -e "\n=== 使用您的版本（忽略他人版本） ==="
      cp "$your_file" "$output_file"
      echo "您的版本已保存到：$output_file"
      read -p "按Enter键继续..."
      ;;
    8)
      echo -e "\n=== 使用他人版本（忽略您的版本） ==="
      cp "$their_file" "$output_file"
      echo "他人版本已保存到：$output_file"
      read -p "按Enter键继续..."
      ;;
    9)
      if [ -f "$output_file" ]; then
        echo -e "\n=== 查看合并结果 ==="
        less "$output_file"
      else
        echo "错误：还没有生成合并结果，请先执行合并操作（选项2或3）。"
        read -p "按Enter键继续..."
      fi
      ;;
    0)
      if [ -f "$output_file" ]; then
        echo "合并结果已保存到：$output_file"
      else
        echo "没有生成合并结果。"
      fi
      echo "退出程序。"
      break
      ;;
    *)
      echo "无效的选择，请重新输入。"
      read -p "按Enter键继续..."
      ;;
  esac
done
```

此脚本是一个交互式的三路合并工具，它提供菜单界面让用户选择不同的合并操作，如自动合并、标记冲突、仅显示冲突区域等，还支持生成ed编辑器合并命令和RCS格式合并命令等功能。

### 6.2 版本控制系统集成

**示例20：Git合并冲突解决助手**

```bash
#!/bin/bash
# Git合并冲突解决助手

# 使用方法：./git_conflict_resolver.sh [file]

# 检查是否在Git仓库中
git rev-parse --is-inside-work-tree &> /dev/null
if [ $? -ne 0 ]; then
  echo "错误：当前目录不是Git仓库！"
  exit 1
fi

# 如果没有指定文件，显示所有冲突文件
if [ $# -eq 0 ]; then
  echo "===== 存在冲突的文件 =====