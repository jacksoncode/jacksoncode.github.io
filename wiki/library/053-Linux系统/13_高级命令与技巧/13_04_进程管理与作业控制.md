# 进程管理与作业控制

## 1 进程基础概念

### 1.1 进程与线程

#### 1.1.1 进程定义
进程是操作系统中正在运行的程序的实例，具有以下特征：
- 独立的内存空间
- 独立的文件描述符
- 独立的进程ID (PID)
- 父进程ID (PPID)
- 进程状态信息

#### 1.1.2 线程定义
线程是进程中的执行单元，特点包括：
- 共享进程的内存空间
- 共享文件描述符
- 轻量级，创建和切换开销小
- 同一进程内的线程可以并发执行

### 1.2 进程状态

Linux进程主要有以下状态：

| 状态 | 描述 | 示例 |
|------|------|------|
| R (Running) | 运行或可运行状态 | 正在执行的任务 |
| S (Sleeping) | 可中断睡眠状态 | 等待用户输入 |
| D (Disk Sleep) | 不可中断睡眠状态 | 等待I/O完成 |
| T (Stopped) | 停止状态 | Ctrl+Z挂起的进程 |
| Z (Zombie) | 僵尸进程 | 子进程已结束但父进程未回收 |
| X (Dead) | 死亡状态 | 进程即将被销毁 |

## 2 进程查看命令

### 2.1 ps命令详解

#### 2.1.1 基本用法

```bash
#!/bin/bash
# ps命令基础用法示例

# 查看当前用户的进程
ps

# 查看所有进程
ps aux

# 查看进程树
ps auxf

# 查看特定用户的进程
ps -u username

# 查看进程详细信息
ps -ef

# 查看进程线程
ps -eLf

# 查看进程树状结构
ps axjf
```

#### 2.1.2 高级用法

```bash
#!/bin/bash
# ps高级用法示例

# 自定义输出格式
ps -eo pid,ppid,user,cmd,pcpu,pmem,etime

# 按CPU使用率排序
ps aux --sort=-%cpu

# 按内存使用率排序
ps aux --sort=-%mem

# 查找特定进程
ps aux | grep nginx

# 查看进程环境变量
ps e -p PID

# 查看进程文件描述符
ps -o pid,ppid,cmd,etime -p PID

# 查看进程状态变化
watch -n 1 'ps aux | head -20'
```

### 2.2 top命令详解

#### 2.2.1 基本界面

```bash
#!/bin/bash
# top命令基础用法

top                    # 启动top
htop                   # 更友好的版本（需安装）

# 常用交互命令
# P - 按CPU排序
# M - 按内存排序
# T - 按时间排序
# k - 杀死进程
# r - 改变优先级
# h - 帮助
# q - 退出
```

#### 2.2.2 高级配置

```bash
#!/bin/bash
# top高级配置示例

# 保存top配置
echo "设置top显示选项后，按W保存到~/.toprc"

# 自定义top显示字段
top -o %CPU            # 按CPU排序
top -o %MEM            # 按内存排序
top -u username        # 查看特定用户
top -p 1,2,3           # 查看特定PID

# 批处理模式（适合脚本）
top -b -n 1            # 只运行一次
```

### 2.3 进程树查看

#### 2.3.1 pstree命令

```bash
#!/bin/bash
# pstree命令示例

# 基本树状结构
pstree

# 显示PID
pstree -p

# 显示用户名
pstree -u

# 显示完整命令
pstree -a

# 显示特定进程树
pstree -p 1

# 高亮显示当前进程
pstree -h

# 结合grep查找
pstree | grep nginx
```

#### 2.3.2 自定义进程树

```bash
#!/bin/bash
# 自定义进程树查看脚本

show_process_tree() {
    local target_pid="${1:-1}"
    
    echo "进程树 (PID: $target_pid)"
    echo "================================"
    
    # 递归显示进程树
    show_tree() {
        local pid="$1"
        local indent="$2"
        
        local cmd=$(ps -p "$pid" -o cmd= 2>/dev/null)
        local user=$(ps -p "$pid" -o user= 2>/dev/null)
        
        if [ -n "$cmd" ]; then
            printf "%s├─ %d [%s] %s\n" "$indent" "$pid" "$user" "$cmd"
            
            # 查找子进程
            local children=$(pgrep -P "$pid")
            for child in $children; do
                show_tree "$child" "  $indent"
            done
        fi
    }
    
    show_tree "$target_pid" ""
}

# 使用示例
show_process_tree $$          # 显示当前shell进程树
show_process_tree 1           # 显示init进程树
```

## 3 进程控制

### 3.1 启动进程

#### 3.1.1 前台与后台进程

```bash
#!/bin/bash
# 前台与后台进程示例

# 前台进程（阻塞终端）
sleep 30

# 后台进程（不阻塞终端）
sleep 30 &
echo "后台进程PID: $!"

# 查看后台作业
jobs

# 将前台进程转到后台
# Ctrl+Z 挂起进程
# bg %1 将作业1转到后台

# 将后台进程转到前台
# fg %1 将作业1转到前台
```

#### 3.1.2 nohup与disown

```bash
#!/bin/bash
# nohup与disown示例

# 使用nohup启动长期运行进程
nohup ./long_running_script.sh > output.log 2>&1 &
echo "进程已启动，PID: $!"

# 使用disown分离进程
./long_running_script.sh &
disown %1                    # 从作业列表中移除

# 检查进程状态
ps aux | grep long_running_script
```

### 3.2 终止进程

#### 3.2.1 kill命令详解

```bash
#!/bin/bash
# kill命令详解

# 基本终止信号
kill -15 PID                 # SIGTERM (优雅终止)
kill -9 PID                  # SIGKILL (强制终止)
kill -2 PID                  # SIGINT (中断)
kill -1 PID                  # SIGHUP (挂起)

# 按名称终止
killall nginx                # 终止所有nginx进程
pkill -f "python.*script"    # 按模式匹配终止

# 确认终止
pkill -f "nginx" && echo "nginx进程已终止"

# 安全终止脚本
safe_kill() {
    local pid="$1"
    local timeout="${2:-10}"
    
    if kill -0 "$pid" 2>/dev/null; then
        echo "终止进程 $pid..."
        kill -15 "$pid"
        
        # 等待进程退出
        local count=0
        while kill -0 "$pid" 2>/dev/null && [ $count -lt $timeout ]; do
            sleep 1
            ((count++))
        done
        
        if kill -0 "$pid" 2>/dev/null; then
            echo "强制终止进程 $pid..."
            kill -9 "$pid"
        fi
        
        echo "进程 $pid 已终止"
    else
        echo "进程 $pid 不存在"
    fi
}

# 使用示例
# safe_kill 12345
```

#### 3.2.2 进程清理脚本

```bash
#!/bin/bash
# 进程清理脚本

cleanup_processes() {
    local pattern="$1"
    local force="${2:-false}"
    
    if [ -z "$pattern" ]; then
        echo "用法: $0 <进程模式> [force]"
        return 1
    fi
    
    echo "查找匹配的进程: $pattern"
    
    # 查找匹配的进程
    local pids=$(pgrep -f "$pattern")
    
    if [ -z "$pids" ]; then
        echo "未找到匹配的进程"
        return 0
    fi
    
    echo "找到以下进程:"
    ps -fp $pids
    
    # 确认终止
    read -p "确认终止这些进程? (y/N): " -n 1 -r
    echo
    
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        if [ "$force" = "true" ]; then
            kill -9 $pids
        else
            kill -15 $pids
        fi
        echo "进程已终止"
    else
        echo "操作已取消"
    fi
}

# 使用示例
# cleanup_processes "nginx"
# cleanup_processes "python" force
```

## 4 作业控制

### 4.1 作业管理基础

#### 4.1.1 作业状态

```bash
#!/bin/bash
# 作业状态示例

# 启动多个作业
sleep 100 &
sleep 200 &
sleep 300 &

# 查看作业状态
jobs -l                    # 显示作业列表和PID
jobs -p                    # 只显示PID
jobs -r                    # 只显示运行中的作业
jobs -s                    # 只显示停止的作业

# 作业控制命令
fg %1                      # 将作业1转到前台
bg %2                      # 将作业2转到后台
kill %3                    # 终止作业3

# 作业状态说明
# + 表示当前作业
# - 表示前一个作业
```

#### 4.1.2 作业控制脚本

```bash
#!/bin/bash
# 作业控制脚本

JOB_MANAGER() {
    local action="$1"
    local job_id="$2"
    
    case "$action" in
        "list")
            echo "=== 当前作业 ==="
            jobs -l
            ;;
            
        "foreground")
            if [ -n "$job_id" ]; then
                echo "将作业 $job_id 转到前台..."
                fg "%$job_id"
            else
                echo "请指定作业ID"
            fi
            ;;
            
        "background")
            if [ -n "$job_id" ]; then
                echo "将作业 $job_id 转到后台..."
                bg "%$job_id"
            else
                echo "请指定作业ID"
            fi
            ;;
            
        "kill")
            if [ -n "$job_id" ]; then
                echo "终止作业 $job_id..."
                kill "%$job_id"
            else
                echo "请指定作业ID"
            fi
            ;;
            
        *)
            echo "用法: $0 {list|foreground|background|kill} [job_id]"
            ;;
    esac
}

# 使用示例
# JOB_MANAGER list
# JOB_MANAGER foreground 1
```

### 4.2 高级作业控制

#### 4.2.1 作业优先级

```bash
#!/bin/bash
# 作业优先级管理

# 查看进程优先级
ps -eo pid,ni,pri,cmd | head -10

# 启动低优先级进程
nice -n 10 ./cpu_intensive_task.sh &

# 修改运行中进程的优先级
renice 5 -p PID

# 启动高优先级进程（需要root权限）
sudo nice -n -10 ./important_task.sh &

# 优先级管理脚本
manage_priority() {
    local pid="$1"
    local new_priority="$2"
    
    if [ -z "$pid" ] || [ -z "$new_priority" ]; then
        echo "用法: $0 <PID> <优先级(-20到19)>"
        return 1
    fi
    
    if ! kill -0 "$pid" 2>/dev/null; then
        echo "进程 $pid 不存在"
        return 1
    fi
    
    # 检查权限
    local current_user=$(whoami)
    local process_user=$(ps -p "$pid" -o user=)
    
    if [ "$current_user" != "$process_user" ] && [ "$current_user" != "root" ]; then
        echo "权限不足，无法修改其他用户的进程优先级"
        return 1
    fi
    
    echo "修改进程 $pid 的优先级为 $new_priority..."
    renice "$new_priority" -p "$pid"
}

# 使用示例
# manage_priority 12345 10
```

#### 4.2.2 作业监控

```bash
#!/bin/bash
# 作业监控脚本

MONITOR_JOBS() {
    local log_file="/tmp/job_monitor.log"
    
    # 启动监控
    echo "开始监控作业... (按Ctrl+C停止)"
    
    # 捕获退出信号
    trap 'echo "监控已停止"; exit 0' INT TERM
    
    while true; do
        {
            echo "=== 作业监控报告 $(date) ==="
            echo ""
            
            # 当前作业
            echo "当前作业:"
            jobs -l
            echo ""
            
            # 系统负载
            echo "系统负载:"
            uptime
            echo ""
            
            # 内存使用
            echo "内存使用:"
            free -h | grep -E "^Mem|^Swap"
            echo ""
            
            # 磁盘使用
            echo "磁盘使用:"
            df -h | grep -E "^/dev/"
            echo ""
            
            echo "================================"
            echo ""
            
        } >> "$log_file"
        
        sleep 60
    done
}

# 后台监控
start_monitoring() {
    nohup bash -c 'MONITOR_JOBS' > /dev/null 2>&1 &
    echo "监控已启动，PID: $!"
    echo "日志文件: /tmp/job_monitor.log"
}

# 停止监控
stop_monitoring() {
    local monitor_pid=$(pgrep -f "MONITOR_JOBS")
    if [ -n "$monitor_pid" ]; then
        kill "$monitor_pid"
        echo "监控已停止"
    else
        echo "未找到监控进程"
    fi
}

# 查看监控日志
view_monitor_log() {
    if [ -f "/tmp/job_monitor.log" ]; then
        tail -50 "/tmp/job_monitor.log"
    else
        echo "监控日志不存在"
    fi
}

# 使用监控功能
# start_monitoring
# stop_monitoring
# view_monitor_log
```

## 5 实战案例

### 5.1 Web服务管理

```bash
#!/bin/bash
# Web服务管理脚本

WEB_SERVICE_MANAGER() {
    local service="${1:-nginx}"
    local action="$2"
    
    case "$action" in
        "start")
            echo "启动 $service 服务..."
            sudo systemctl start "$service"
            
            # 等待服务启动
            sleep 3
            
            if systemctl is-active --quiet "$service"; then
                echo "✅ $service 服务已启动"
                
                # 显示进程信息
                echo "进程信息:"
                ps aux | grep -v grep | grep "$service" | head -5
            else
                echo "❌ $service 服务启动失败"
                return 1
            fi
            ;;
            
        "stop")
            echo "停止 $service 服务..."
            sudo systemctl stop "$service"
            
            # 等待服务停止
            sleep 3
            
            if ! systemctl is-active --quiet "$service"; then
                echo "✅ $service 服务已停止"
            else
                echo "❌ $service 服务停止失败"
                return 1
            fi
            ;;
            
        "restart")
            echo "重启 $service 服务..."
            sudo systemctl restart "$service"
            
            # 等待服务重启
            sleep 5
            
            if systemctl is-active --quiet "$service"; then
                echo "✅ $service 服务已重启"
            else
                echo "❌ $service 服务重启失败"
                return 1
            fi
            ;;
            
        "status")
            echo "=== $service 服务状态 ==="
            
            # 服务状态
            systemctl status "$service" --no-pager -l
            
            # 进程信息
            echo ""
            echo "=== 进程信息 ==="
            ps aux | grep -v grep | grep "$service" | head -10
            
            # 端口监听
            echo ""
            echo "=== 端口监听 ==="
            ss -tuln | grep -E ":80|:443"
            ;;
            
        "monitor")
            echo "监控 $service 服务... (按Ctrl+C停止)"
            
            while true; do
                if ! systemctl is-active --quiet "$service"; then
                    echo "$(date): $service 服务异常停止，正在重启..."
                    sudo systemctl start "$service"
                fi
                
                # 显示资源使用
                local pid=$(pgrep "$service" | head -1)
                if [ -n "$pid" ]; then
                    local cpu=$(ps -p "$pid" -o %cpu= | tr -d ' ')
                    local mem=$(ps -p "$pid" -o %mem= | tr -d ' ')
                    echo "$(date): CPU: ${cpu}%, 内存: ${mem}%"
                fi
                
                sleep 60
            done
            ;;
            
        *)
            echo "用法: $0 <service> {start|stop|restart|status|monitor}"
            echo "示例: $0 nginx start"
            ;;
    esac
}

# 使用示例
# WEB_SERVICE_MANAGER nginx status
# WEB_SERVICE_MANAGER nginx start
```

### 5.2 数据库服务管理

```bash
#!/bin/bash
# 数据库服务管理脚本

DB_SERVICE_MANAGER() {
    local db_type="${1:-mysql}"
    local action="$2"
    
    case "$action" in
        "start")
            echo "启动 $db_type 数据库..."
            
            case "$db_type" in
                "mysql")
                    sudo systemctl start mysql
                    ;;
                "postgresql")
                    sudo systemctl start postgresql
                    ;;
                "mongodb")
                    sudo systemctl start mongod
                    ;;
                *)
                    echo "不支持的数据库类型: $db_type"
                    return 1
                    ;;
            esac
            
            # 检查服务状态
            sleep 5
            if systemctl is-active --quiet "$db_type"; then
                echo "✅ $db_type 数据库已启动"
                
                # 显示连接信息
                case "$db_type" in
                    "mysql")
                        echo "连接信息: mysql -u root -p"
                        ;;
                    "postgresql")
                        echo "连接信息: sudo -u postgres psql"
                        ;;
                    "mongodb")
                        echo "连接信息: mongo"
                        ;;
                esac
            else
                echo "❌ $db_type 数据库启动失败"
                return 1
            fi
            ;;
            
        "backup")
            echo "创建 $db_type 数据库备份..."
            
            local backup_dir="/backup/$db_type/$(date +%Y%m%d)"
            mkdir -p "$backup_dir"
            
            case "$db_type" in
                "mysql")
                    mysqldump -u root -p --all-databases > "$backup_dir/all_databases.sql"
                    ;;
                "postgresql")
                    sudo -u postgres pg_dumpall > "$backup_dir/all_databases.sql"
                    ;;
                "mongodb")
                    mongodump --out "$backup_dir"
                    ;;
            esac
            
            echo "备份完成: $backup_dir"
            ;;
            
        *)
            echo "用法: $0 <mysql|postgresql|mongodb> {start|backup}"
            ;;
    esac
}

# 使用示例
# DB_SERVICE_MANAGER mysql start
# DB_SERVICE_MANAGER mysql backup
```

这些示例涵盖了进程管理与作业控制的各个方面，从基础的进程查看到复杂的系统服务管理，提供了实用的脚本和最佳实践。