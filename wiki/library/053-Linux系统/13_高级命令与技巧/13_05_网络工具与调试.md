# 网络工具与调试

## 1 网络基础概念

### 1.1 TCP/IP协议栈

#### 1.1.1 协议层次结构

| 层次 | 协议 | 功能 | 常用工具 |
|------|------|------|----------|
| 应用层 | HTTP/HTTPS, FTP, SMTP | 应用协议 | curl, wget, nc |
| 传输层 | TCP, UDP | 端到端通信 | netstat, ss |
| 网络层 | IP, ICMP | 路由和寻址 | ping, traceroute |
| 数据链路层 | Ethernet | 物理寻址 | ifconfig, ip |

#### 1.1.2 端口和套接字

```bash
#!/bin/bash
# 端口和套接字概念示例

# 查看系统端口范围
cat /proc/sys/net/ipv4/ip_local_port_range

# 查看已用端口
ss -tuln | head -20

# 查看端口使用情况
lsof -i :80

# 查看所有网络连接
netstat -tuln
```

## 2 网络连接诊断工具

### 2.1 ping命令详解

#### 2.1.1 基本用法

```bash
#!/bin/bash
# ping命令基础用法

# 基本ping测试
ping google.com

# 指定次数
ping -c 4 google.com

# 指定时间间隔
ping -i 2 google.com

# 指定超时时间
ping -w 10 google.com

# 指定数据包大小
ping -s 1000 google.com

# 持续ping
ping -c 100 google.com

# 记录时间戳
ping -D google.com
```

#### 2.1.2 高级ping技巧

```bash
#!/bin/bash
# 高级ping技巧

# 网络质量测试
ping_quality() {
    local host="$1"
    local count="${2:-10}"
    
    if [ -z "$host" ]; then
        echo "用法: $0 <主机> [次数]"
        return 1
    fi
    
    echo "=== 网络质量测试 ==="
    echo "目标: $host"
    echo "测试包数: $count"
    echo ""
    
    local output=$(ping -c "$count" "$host" 2>/dev/null)
    
    if [ $? -ne 0 ]; then
        echo "无法连接到 $host"
        return 1
    fi
    
    # 提取统计信息
    local packets=$(echo "$output" | grep "packets transmitted" | awk '{print $1}')
    local received=$(echo "$output" | grep "packets transmitted" | awk '{print $4}')
    local loss=$(echo "$output" | grep "packets transmitted" | awk '{print $6}')
    local rtt=$(echo "$output" | grep "rtt" | awk -F"/" '{print $5}')
    
    echo "发送: $packets 包"
    echo "接收: $received 包"
    echo "丢包率: $loss"
    echo "平均延迟: ${rtt}ms"
    
    # 质量评估
    if [ "$loss" = "0%" ]; then
        if (( $(echo "$rtt < 50" | bc -l) )); then
            echo "网络质量: 优秀"
        elif (( $(echo "$rtt < 100" | bc -l) )); then
            echo "网络质量: 良好"
        else
            echo "网络质量: 一般"
        fi
    else
        echo "网络质量: 差 (有丢包)"
    fi
}

# 批量ping测试
batch_ping() {
    local hosts=("google.com" "github.com" "baidu.com")
    
    echo "=== 批量网络测试 ==="
    printf "%-20s %-10s %-10s %-10s\n" "主机" "状态" "延迟" "丢包率"
    printf "%-20s %-10s %-10s %-10s\n" "----" "----" "----" "----"
    
    for host in "${hosts[@]}"; do
        local output=$(ping -c 3 "$host" 2>/dev/null)
        
        if [ $? -eq 0 ]; then
            local rtt=$(echo "$output" | grep "rtt" | awk -F"/" '{print $5}')
            local loss=$(echo "$output" | grep "packets transmitted" | awk '{print $6}')
            printf "%-20s %-10s %-10s %-10s\n" "$host" "正常" "$rtt" "$loss"
        else
            printf "%-20s %-10s %-10s %-10s\n" "$host" "失败" "-" "-"
        fi
    done
}

# 使用示例
# ping_quality google.com 20
# batch_ping
```

### 2.2 traceroute路由追踪

#### 2.2.1 基本路由追踪

```bash
#!/bin/bash
# traceroute基本用法

# 基本路由追踪
traceroute google.com

# 使用UDP协议
traceroute -U google.com

# 使用ICMP协议
traceroute -I google.com

# 指定TTL范围
traceroute -m 30 google.com

# 指定等待时间
traceroute -w 3 google.com

# 指定包大小
traceroute -s 1000 google.com
```

#### 2.2.2 高级路由分析

```bash
#!/bin/bash
# 高级路由分析脚本

route_analysis() {
    local target="$1"
    
    if [ -z "$target" ]; then
        echo "用法: $0 <目标主机>"
        return 1
    fi
    
    echo "=== 路由分析 ==="
    echo "目标: $target"
    echo "测试时间: $(date)"
    echo ""
    
    # 基本路由追踪
    echo "=== 路由路径 ==="
    traceroute "$target" 2>/dev/null || {
        echo "路由追踪失败，尝试使用mtr..."
        mtr -r -c 10 "$target" 2>/dev/null
    }
    
    echo ""
    
    # 延迟分析
    echo "=== 延迟分析 ==="
    for i in {1..5}; do
        echo "测试 $i:"
        ping -c 3 "$target" | grep "rtt" | awk -F"/" '{print "  平均延迟: " $5 "ms"}'
    done
    
    echo ""
    
    # DNS解析检查
    echo "=== DNS解析 ==="
    local ips=$(dig +short "$target")
    for ip in $ips; do
        echo "解析到: $ip"
        echo "地理位置: $(geoiplookup "$ip" 2>/dev/null || echo "未知")"
    done
}

# 网络路径可视化
visualize_route() {
    local target="$1"
    
    if [ -z "$target" ]; then
        echo "用法: $0 <目标主机>"
        return 1
    fi
    
    echo "=== 网络路径可视化 ==="
    echo "目标: $target"
    echo ""
    
    # 使用mtr进行可视化
    if command -v mtr >/dev/null 2>&1; then
        echo "使用mtr进行实时路径分析..."
        echo "按q退出mtr界面"
        mtr "$target"
    else
        echo "安装mtr以获得更好的可视化: sudo apt install mtr"
        
        # 使用traceroute和ping的组合
        local hops=$(traceroute -n "$target" 2>/dev/null | tail -n +2 | awk '{print $2}' | grep -v "*")
        
        echo "路由跳点:"
        local count=1
        for hop in $hops; do
            if [ "$hop" != "*" ]; then
                local ping_result=$(ping -c 1 -W 1 "$hop" 2>/dev/null | grep "time=" | awk -F"time=" '{print $2}' | awk '{print $1}')
                if [ -n "$ping_result" ]; then
                    echo "跳点 $count: $hop (${ping_result})"
                else
                    echo "跳点 $count: $hop (超时)"
                fi
                ((count++))
            fi
        done
    fi
}

# 使用示例
# route_analysis google.com
# visualize_route github.com
```

### 2.3 端口扫描工具

#### 2.3.1 nc (netcat) 工具

```bash
#!/bin/bash
# nc工具使用示例

# 端口测试
nc -zv google.com 80

# 端口范围扫描
nc -zv google.com 1-100

# 监听端口
nc -l 12345

# 文件传输
# 接收端: nc -l 12345 > received_file
# 发送端: nc hostname 12345 < file_to_send

# 网络聊天
# 接收端: nc -l 12345
# 发送端: nc hostname 12345

# 端口扫描脚本
port_scan() {
    local host="$1"
    local start_port="${2:-1}"
    local end_port="${3:-100}"
    
    if [ -z "$host" ]; then
        echo "用法: $0 <主机> [起始端口] [结束端口]"
        return 1
    fi
    
    echo "=== 端口扫描 ==="
    echo "目标: $host"
    echo "端口范围: $start_port-$end_port"
    echo "开始时间: $(date)"
    echo ""
    
    for port in $(seq "$start_port" "$end_port"); do
        if nc -z -w 1 "$host" "$port" 2>/dev/null; then
            echo "端口 $port: 开放"
            
            # 尝试识别服务
            local service=$(grep -w "$port" /etc/services 2>/dev/null | head -1 | awk '{print $2}')
            if [ -n "$service" ]; then
                echo "  服务: $service"
            fi
        fi
    done
    
    echo ""
    echo "扫描完成: $(date)"
}

# 快速端口扫描
quick_scan() {
    local host="$1"
    local common_ports=(21 22 23 25 53 80 110 143 443 993 995 3306 5432 8080)
    
    if [ -z "$host" ]; then
        echo "用法: $0 <主机>"
        return 1
    fi
    
    echo "=== 常用端口扫描 ==="
    echo "目标: $host"
    echo ""
    
    for port in "${common_ports[@]}"; do
        if nc -z -w 1 "$host" "$port" 2>/dev/null; then
            local service=$(grep -w "$port" /etc/services 2>/dev/null | head -1 | awk '{print $1}')
            echo "端口 $port ($service): 开放"
        fi
    done
}

# 使用示例
# port_scan localhost 1 1000
# quick_scan google.com
```

#### 2.3.2 nmap高级扫描

```bash
#!/bin/bash
# nmap使用示例（需要安装nmap）

# 基本端口扫描
nmap -sS google.com

# 快速扫描
nmap -F google.com

# 扫描所有端口
nmap -p- google.com

# 操作系统检测
nmap -O google.com

# 服务版本检测
nmap -sV google.com

# 脚本扫描
nmap -sC google.com

# 综合扫描
nmap -A google.com

# 网络扫描脚本
network_discovery() {
    local network="$1"
    
    if [ -z "$network" ]; then
        echo "用法: $0 <网络地址>"
        echo "示例: $0 192.168.1.0/24"
        return 1
    fi
    
    echo "=== 网络发现 ==="
    echo "网络: $network"
    echo "开始时间: $(date)"
    echo ""
    
    if command -v nmap >/dev/null 2>&1; then
        # 使用nmap进行网络发现
        nmap -sn "$network"
    else
        echo "nmap未安装，使用ping扫描..."
        
        # 基础ping扫描
        local base_ip=$(echo "$network" | cut -d'/' -f1 | cut -d'.' -f1-3)
        for i in {1..254}; do
            local ip="$base_ip.$i"
            if ping -c 1 -W 1 "$ip" >/dev/null 2>&1; then
                echo "发现主机: $ip"
            fi
        done
    fi
}

# 使用示例
# network_discovery 192.168.1.0/24
```

## 3 网络连接管理

### 3.1 ss和netstat工具

#### 3.1.1 ss命令详解

```bash
#!/bin/bash
# ss命令详解

# 查看所有连接
ss -tuln

# 查看TCP连接
ss -t -a

# 查看UDP连接
ss -u -a

# 查看监听端口
ss -l

# 查看进程信息
ss -tulpn

# 查看连接状态统计
ss -s

# 查看特定端口
ss -tuln | grep :80

# 查看连接详细信息
ss -i -t

# 查看路由表
ss -r
```

#### 3.1.2 网络连接分析脚本

```bash
#!/bin/bash
# 网络连接分析脚本

NETWORK_ANALYZER() {
    local action="$1"
    
    case "$action" in
        "summary")
            echo "=== 网络连接摘要 ==="
            echo ""
            
            # 连接统计
            echo "连接统计:"
            ss -s | grep -E "TCP|UDP"
            echo ""
            
            # 监听端口
            echo "监听端口:"
            ss -tuln | grep LISTEN | head -10
            echo ""
            
            # 活跃连接
            echo "活跃连接:"
            ss -t | grep ESTAB | head -10
            ;;
            
        "top-ports")
            echo "=== 最常用端口 ==="
            ss -tuln |
            awk 'NR>1 {
                split($4, addr, ":")
                port = addr[length(addr)]
                ports[port]++
            } 
            END {
                for (p in ports)
                    printf "%-6s %d\n", p, ports[p]
            }' |
            sort -k2 -nr |
            head -20
            ;;
            
        "connections")
            local pid="${2:-all}"
            
            if [ "$pid" = "all" ]; then
                echo "=== 所有网络连接 ==="
                ss -tulpn
            else
                echo "=== 进程 $pid 的网络连接 ==="
                ss -tulpn | grep "$pid"
            fi
            ;;
            
        "monitor")
            echo "=== 网络连接监控 ==="
            echo "按Ctrl+C停止"
            
            while true; do
                clear
                echo "=== 实时网络监控 $(date) ==="
                echo ""
                
                # 连接统计
                ss -s | grep -E "TCP|UDP"
                echo ""
                
                # 活跃连接
                echo "活跃连接:"
                ss -t | grep ESTAB | head -10
                
                sleep 2
            done
            ;;
            
        *)
            echo "用法: $0 {summary|top-ports|connections|monitor} [PID]"
            ;;
    esac
}

# 使用示例
# NETWORK_ANALYZER summary
# NETWORK_ANALYZER top-ports
# NETWORK_ANALYZER connections
# NETWORK_ANALYZER monitor
```

### 3.2 网络配置管理

#### 3.2.1 ifconfig和ip命令

```bash
#!/bin/bash
# 网络配置管理

# 查看网络接口
ip addr show

# 查看路由表
ip route show

# 查看ARP缓存
ip neigh show

# 配置IP地址（临时）
sudo ip addr add 192.168.1.100/24 dev eth0

# 删除IP地址
sudo ip addr del 192.168.1.100/24 dev eth0

# 启用/禁用接口
sudo ip link set eth0 up
sudo ip link set eth0 down

# 添加默认路由
sudo ip route add default via 192.168.1.1

# 删除路由
sudo ip route del default

# 查看接口统计
ip -s link show eth0
```

#### 3.2.2 网络配置脚本

```bash
#!/bin/bash
# 网络配置管理脚本

NETWORK_CONFIG() {
    local action="$1"
    local interface="$2"
    
    case "$action" in
        "show")
            if [ -n "$interface" ]; then
                echo "=== 接口 $interface 信息 ==="
                ip addr show "$interface"
                echo ""
                ip -s link show "$interface"
            else
                echo "=== 所有网络接口 ==="
                ip addr show
            fi
            ;;
            
        "configure")
            local ip="$3"
            local gateway="$4"
            
            if [ -z "$interface" ] || [ -z "$ip" ]; then
                echo "用法: $0 configure <接口> <IP/掩码> [网关]"
                return 1
            fi
            
            echo "配置接口 $interface..."
            sudo ip addr flush dev "$interface"
            sudo ip addr add "$ip" dev "$interface"
            sudo ip link set "$interface" up
            
            if [ -n "$gateway" ]; then
                sudo ip route add default via "$gateway"
            fi
            
            echo "配置完成"
            ip addr show "$interface"
            ;;
            
        "reset")
            if [ -z "$interface" ]; then
                echo "用法: $0 reset <接口>"
                return 1
            fi
            
            echo "重置接口 $interface..."
            sudo ip addr flush dev "$interface"
            sudo ip link set "$interface" down
            sudo ip link set "$interface" up
            
            echo "重置完成"
            ;;
            
        "dhcp")
            if [ -z "$interface" ]; then
                echo "用法: $0 dhcp <接口>"
                return 1
            fi
            
            echo "启用DHCP $interface..."
            sudo dhclient -r "$interface" 2>/dev/null || true
            sudo dhclient "$interface"
            
            echo "DHCP配置完成"
            ip addr show "$interface"
            ;;
            
        *)
            echo "用法: $0 {show|configure|reset|dhcp} [接口] [IP/掩码] [网关]"
            ;;
    esac
}

# 使用示例
# NETWORK_CONFIG show
# NETWORK_CONFIG show eth0
# NETWORK_CONFIG configure eth0 192.168.1.100/24 192.168.1.1
# NETWORK_CONFIG reset eth0
# NETWORK_CONFIG dhcp eth0
```

## 4 网络调试工具

### 4.1 curl和wget工具

#### 4.1.1 curl高级用法

```bash
#!/bin/bash
# curl高级用法

# 基本HTTP请求
curl http://example.com

# 显示响应头
curl -I http://example.com

# 保存输出
curl -o output.html http://example.com

# 跟随重定向
curl -L http://example.com

# 发送POST请求
curl -X POST -d "key=value" http://example.com

# 设置请求头
curl -H "User-Agent: MyApp/1.0" http://example.com

# 基本认证
curl -u username:password http://example.com

# 显示详细输出
curl -v http://example.com

# 测试API
API_TESTER() {
    local url="$1"
    local method="${2:-GET}"
    local data="${3:-}"
    
    if [ -z "$url" ]; then
        echo "用法: $0 <URL> [方法] [数据]"
        return 1
    fi
    
    echo "=== API测试 ==="
    echo "URL: $url"
    echo "方法: $method"
    echo ""
    
    case "$method" in
        "GET")
            curl -s -w "\nHTTP状态: %{http_code}\n响应时间: %{time_total}s\n" "$url"
            ;;
        "POST")
            if [ -n "$data" ]; then
                curl -s -X POST -d "$data" -w "\nHTTP状态: %{http_code}\n响应时间: %{time_total}s\n" "$url"
            else
                echo "POST需要数据参数"
            fi
            ;;
        *)
            curl -s -X "$method" -w "\nHTTP状态: %{http_code}\n响应时间: %{time_total}s\n" "$url"
            ;;
    esac
}

# 使用示例
# API_TESTER http://httpbin.org/get
# API_TESTER http://httpbin.org/post POST "name=test&value=123"
```

#### 4.1.2 wget下载工具

```bash
#!/bin/bash
# wget下载工具

# 基本下载
wget http://example.com/file.zip

# 断点续传
wget -c http://example.com/large_file.zip

# 后台下载
wget -b http://example.com/file.zip

# 限速下载
wget --limit-rate=200k http://example.com/file.zip

# 下载整个网站
wget --recursive --no-parent http://example.com/

# 镜像网站
wget --mirror --convert-links --adjust-extension --page-requisites --no-parent http://example.com/

# 批量下载
wget -i urls.txt

# 下载管理脚本
DOWNLOAD_MANAGER() {
    local url="$1"
    local output="$2"
    local retries="${3:-3}"
    
    if [ -z "$url" ]; then
        echo "用法: $0 <URL> [输出文件] [重试次数]"
        return 1
    fi
    
    echo "开始下载: $url"
    
    local wget_opts="-c --tries=$retries"
    if [ -n "$output" ]; then
        wget_opts="$wget_opts -O $output"
    fi
    
    wget $wget_opts "$url"
    
    if [ $? -eq 0 ]; then
        echo "下载完成"
    else
        echo "下载失败"
    fi
}

# 使用示例
# DOWNLOAD_MANAGER http://example.com/file.zip
# DOWNLOAD_MANAGER http://example.com/file.zip custom_name.zip
```

### 4.2 网络性能测试

#### 4.2.1 带宽测试

```bash
#!/bin/bash
# 网络性能测试

# 使用speedtest-cli测试带宽
# 需要先安装: pip install speedtest-cli

SPEED_TEST() {
    if ! command -v speedtest-cli >/dev/null 2>&1; then
        echo "安装speedtest-cli: pip install speedtest-cli"
        return 1
    fi
    
    echo "=== 网络速度测试 ==="
    echo "测试时间: $(date)"
    echo ""
    
    speedtest-cli --simple
}

# 使用iperf3测试
# 服务器端: iperf3 -s
# 客户端: iperf3 -c server_ip

IPERF_TEST() {
    local server="$1"
    local port="${2:-5201}"
    
    if [ -z "$server" ]; then
        echo "用法: $0 <服务器IP> [端口]"
        return 1
    fi
    
    echo "=== iperf3测试 ==="
    echo "服务器: $server:$port"
    echo ""
    
    # 测试下载速度
    echo "下载测试:"
    iperf3 -c "$server" -p "$port" -t 10
    
    # 测试上传速度
    echo ""
    echo "上传测试:"
    iperf3 -c "$server" -p "$port" -t 10 -R
}

# 网络延迟测试
LATENCY_TEST() {
    local hosts=("google.com" "github.com" "baidu.com")
    
    echo "=== 网络延迟测试 ==="
    printf "%-20s %-15s %-15s %-15s\n" "主机" "最小延迟" "平均延迟" "最大延迟"
    printf "%-20s %-15s %-15s %-15s\n" "----" "--------" "--------" "--------"
    
    for host in "${hosts[@]}"; do
        local output=$(ping -c 10 "$host" 2>/dev/null)
        if [ $? -eq 0 ]; then
            local min=$(echo "$output" | grep "rtt" | awk -F"/" '{print $4}')
            local avg=$(echo "$output" | grep "rtt" | awk -F"/" '{print $5}')
            local max=$(echo "$output" | grep "rtt" | awk -F"/" '{print $6}')
            printf "%-20s %-15s %-15s %-15s\n" "$host" "$min" "$avg" "$max"
        else
            printf "%-20s %-15s %-15s %-15s\n" "$host" "超时" "超时" "超时"
        fi
    done
}

# 综合网络测试
COMPREHENSIVE_TEST() {
    echo "=== 综合网络测试 ==="
    echo "测试时间: $(date)"
    echo ""
    
    # DNS解析测试
    echo "DNS解析测试:"
    time nslookup google.com >/dev/null 2>&1 && echo "DNS解析: 正常" || echo "DNS解析: 失败"
    
    # 网络连通性
    echo "网络连通性:"
    ping -c 1 google.com >/dev/null 2>&1 && echo "网络连通: 正常" || echo "网络连通: 失败"
    
    # 端口测试
    echo "常用端口测试:"
    local ports=(80 443 22 53)
    for port in "${ports[@]}"; do
        if nc -z -w 2 google.com "$port" 2>/dev/null; then
            echo "端口 $port: 开放"
        else
            echo "端口 $port: 关闭"
        fi
    done
    
    # 速度测试
    if command -v speedtest-cli >/dev/null 2>&1; then
        echo ""
        echo "速度测试:"
        speedtest-cli --simple
    fi
}

# 使用示例
# SPEED_TEST
# LATENCY_TEST
# COMPREHENSIVE_TEST
```

## 5 网络故障排查

### 5.1 网络故障诊断流程

```bash
#!/bin/bash
# 网络故障诊断脚本

NETWORK_TROUBLESHOOT() {
    local target="${1:-google.com}"
    
    echo "=== 网络故障诊断 ==="
    echo "目标: $target"
    echo "开始时间: $(date)"
    echo ""
    
    # 步骤1: 检查网络接口
    echo "步骤1: 检查网络接口..."
    local interfaces=$(ip addr show | grep -E "^[0-9]:" | awk '{print $2}' | sed 's/://')
    for iface in $interfaces; do
        if ip addr show "$iface" | grep -q "inet "; then
            echo "✅ 接口 $iface: 已配置IP"
        else
            echo "⚠️  接口 $iface: 未配置IP"
        fi
    done
    echo ""
    
    # 步骤2: 检查DNS解析
    echo "步骤2: 检查DNS解析..."
    if nslookup "$target" >/dev/null 2>&1; then
        echo "✅ DNS解析: 正常"
        local ip=$(dig +short "$target" | head -1)
        echo "  解析到: $ip"
    else
        echo "❌ DNS解析: 失败"
        echo "  检查/etc/resolv.conf文件"
    fi
    echo ""
    
    # 步骤3: 检查网关
    echo "步骤3: 检查网关..."
    local gateway=$(ip route show default | grep default | awk '{print $3}')
    if [ -n "$gateway" ]; then
        if ping -c 1 "$gateway" >/dev/null 2>&1; then
            echo "✅ 网关 $gateway: 可达"
        else
            echo "❌ 网关 $gateway: 不可达"
        fi
    else
        echo "⚠️  未找到默认网关"
    fi
    echo ""
    
    # 步骤4: 检查目标主机
    echo "步骤4: 检查目标主机..."
    if ping -c 1 "$target" >/dev/null 2>&1; then
        echo "✅ 目标主机: 可达"
        
        # 延迟测试
        local output=$(ping -c 3 "$target" 2>/dev/null)
        local avg=$(echo "$output" | grep "rtt" | awk -F"/" '{print $5}')
        echo "  平均延迟: ${avg}ms"
    else
        echo "❌ 目标主机: 不可达"
        
        # 路由追踪
        echo "  进行路由追踪..."
        traceroute "$target" 2>/dev/null || echo "  路由追踪失败"
    fi
    echo ""
    
    # 步骤5: 检查端口
    echo "步骤5: 检查端口..."
    local ports=(80 443)
    for port in "${ports[@]}"; do
        if nc -z -w 2 "$target" "$port" 2>/dev/null; then
            echo "✅ 端口 $port: 开放"
        else
            echo "❌ 端口 $port: 关闭"
        fi
    done
    echo ""
    
    # 生成报告
    echo "=== 诊断报告 ==="
    echo "生成时间: $(date)"
    echo "诊断结果已保存到: /tmp/network_diagnosis_$(date +%Y%m%d_%H%M%S).txt"
    
    # 保存完整报告
    {
        echo "网络故障诊断报告"
        echo "=================="
        echo "目标: $target"
        echo "时间: $(date)"
        echo ""
        
        echo "网络接口信息:"
        ip addr show
        echo ""
        
        echo "路由表:"
        ip route show
        echo ""
        
        echo "DNS配置:"
        cat /etc/resolv.conf 2>/dev/null || echo "无DNS配置"
        echo ""
        
        echo "网络连接:"
        ss -tuln
    } > "/tmp/network_diagnosis_$(date +%Y%m%d_%H%M%S).txt"
}

# 网络监控脚本
NETWORK_MONITOR() {
    local target="${1:-google.com}"
    local interval="${2:-60}"
    
    echo "=== 网络监控 ==="
    echo "目标: $target"
    echo "间隔: ${interval}秒"
    echo "按Ctrl+C停止"
    echo ""
    
    # 创建监控日志
    local log_file="/tmp/network_monitor_$(date +%Y%m%d).log"
    
    # 捕获退出信号
    trap 'echo "监控已停止"; exit 0' INT TERM
    
    while true; do
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        
        # 网络测试
        if ping -c 1 "$target" >/dev/null 2>&1; then
            local output=$(ping -c 3 "$target" 2>/dev/null)
            local avg=$(echo "$output" | grep "rtt" | awk -F"/" '{print $5}')
            echo "$timestamp - 正常 - 延迟: ${avg}ms" | tee -a "$log_file"
        else
            echo "$timestamp - 失败 - 网络不可达" | tee -a "$log_file"
        fi
        
        sleep "$interval"
    done
}

# 使用示例
# NETWORK_TROUBLESHOOT google.com
# NETWORK_MONITOR google.com 30
```

这些网络工具和调试技术为系统管理员和开发人员提供了全面的网络诊断能力，从基础的ping测试到复杂的网络性能分析，都能有效应对各种网络问题。