# 常用脚本集合

## 1 系统管理脚本

### 1.1 系统信息收集脚本
```bash
#!/bin/bash
# system-info.sh - 系统信息收集脚本

OUTPUT_DIR="/tmp/system-info-$(date +%Y%m%d-%H%M%S)"
mkdir -p "$OUTPUT_DIR"

echo "正在收集系统信息..."

# 基本信息
echo "=== 系统基本信息 ===" > "$OUTPUT_DIR/basic-info.txt"
uname -a >> "$OUTPUT_DIR/basic-info.txt"
cat /etc/os-release >> "$OUTPUT_DIR/basic-info.txt"
echo "" >> "$OUTPUT_DIR/basic-info.txt"

# 硬件信息
echo "=== 硬件信息 ===" > "$OUTPUT_DIR/hardware-info.txt"
lscpu >> "$OUTPUT_DIR/hardware-info.txt"
echo "" >> "$OUTPUT_DIR/hardware-info.txt"
lsmem >> "$OUTPUT_DIR/hardware-info.txt"
echo "" >> "$OUTPUT_DIR/hardware-info.txt"
lsblk -f >> "$OUTPUT_DIR/hardware-info.txt"
echo "" >> "$OUTPUT_DIR/hardware-info.txt"
lspci -v >> "$OUTPUT_DIR/hardware-info.txt"

# 网络信息
echo "=== 网络信息 ===" > "$OUTPUT_DIR/network-info.txt"
ip addr show >> "$OUTPUT_DIR/network-info.txt"
echo "" >> "$OUTPUT_DIR/network-info.txt"
ip route show >> "$OUTPUT_DIR/network-info.txt"
echo "" >> "$OUTPUT_DIR/network-info.txt"
cat /etc/resolv.conf >> "$OUTPUT_DIR/network-info.txt"

# 服务信息
echo "=== 服务状态 ===" > "$OUTPUT_DIR/service-info.txt"
systemctl list-units --type=service --state=running >> "$OUTPUT_DIR/service-info.txt"

# 进程信息
echo "=== 进程信息 ===" > "$OUTPUT_DIR/process-info.txt"
ps aux --sort=-%cpu | head -20 >> "$OUTPUT_DIR/process-info.txt"
echo "" >> "$OUTPUT_DIR/process-info.txt"
ps aux --sort=-%mem | head -20 >> "$OUTPUT_DIR/process-info.txt"

# 磁盘使用
echo "=== 磁盘使用情况 ===" > "$OUTPUT_DIR/disk-info.txt"
df -h >> "$OUTPUT_DIR/disk-info.txt"
echo "" >> "$OUTPUT_DIR/disk-info.txt"
du -sh /var/log/* | sort -hr | head -20 >> "$OUTPUT_DIR/disk-info.txt"

# 创建压缩包
tar -czf "$OUTPUT_DIR.tar.gz" "$OUTPUT_DIR"
rm -rf "$OUTPUT_DIR"

echo "系统信息收集完成：$OUTPUT_DIR.tar.gz"
```

### 1.2 自动备份脚本
```bash
#!/bin/bash
# backup.sh - 自动备份脚本

# 配置变量
BACKUP_DIR="/backup"
SOURCE_DIRS="/etc /home /var/www"
EXCLUDE_DIRS="--exclude=/home/*/Downloads --exclude=/home/*/cache"
RETENTION_DAYS=30
DATE=$(date +%Y%m%d-%H%M%S)
HOSTNAME=$(hostname)

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 系统配置文件备份
echo "开始备份系统配置..."
tar -czf "$BACKUP_DIR/config-$HOSTNAME-$DATE.tar.gz" /etc

# 用户数据备份
echo "开始备份用户数据..."
tar -czf "$BACKUP_DIR/home-$HOSTNAME-$DATE.tar.gz" $EXCLUDE_DIRS /home

# Web数据备份（如果存在）
if [ -d "/var/www" ]; then
    echo "开始备份Web数据..."
    tar -czf "$BACKUP_DIR/www-$HOSTNAME-$DATE.tar.gz" /var/www
fi

# 数据库备份（如果存在）
if command -v mysql >/dev/null 2>&1; then
    echo "开始备份MySQL数据库..."
    mysqldump --all-databases --single-transaction > "$BACKUP_DIR/mysql-$HOSTNAME-$DATE.sql"
    gzip "$BACKUP_DIR/mysql-$HOSTNAME-$DATE.sql"
fi

if command -v pg_dumpall >/dev/null 2>&1; then
    echo "开始备份PostgreSQL数据库..."
    pg_dumpall > "$BACKUP_DIR/postgres-$HOSTNAME-$DATE.sql"
    gzip "$BACKUP_DIR/postgres-$HOSTNAME-$DATE.sql"
fi

# 清理旧备份
echo "清理超过$RETENTION_DAYS天的旧备份..."
find "$BACKUP_DIR" -name "*.tar.gz" -mtime +$RETENTION_DAYS -delete
find "$BACKUP_DIR" -name "*.sql.gz" -mtime +$RETENTION_DAYS -delete

# 生成备份报告
echo "备份完成时间：$(date)" > "$BACKUP_DIR/backup-report-$DATE.txt"
echo "备份文件列表：" >> "$BACKUP_DIR/backup-report-$DATE.txt"
ls -lh "$BACKUP_DIR"/*-$DATE* >> "$BACKUP_DIR/backup-report-$DATE.txt"

echo "备份完成！备份文件保存在：$BACKUP_DIR"
```

### 1.3 系统监控脚本
```bash
#!/bin/bash
# system-monitor.sh - 系统监控脚本

LOG_FILE="/var/log/system-monitor.log"
ALERT_EMAIL="admin@example.com"
THRESHOLD_CPU=80
THRESHOLD_MEM=80
THRESHOLD_DISK=85

# 创建日志文件
touch "$LOG_FILE"

log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

check_cpu() {
    CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    if (( $(echo "$CPU_USAGE > $THRESHOLD_CPU" | bc -l) )); then
        log_message "WARNING: High CPU usage: ${CPU_USAGE}%"
        echo "CPU usage is ${CPU_USAGE}% on $(hostname)" | mail -s "CPU Alert" "$ALERT_EMAIL"
    fi
}

check_memory() {
    MEMORY_USAGE=$(free | grep Mem | awk '{printf "%.2f", $3/$2 * 100.0}')
    if (( $(echo "$MEMORY_USAGE > $THRESHOLD_MEM" | bc -l) )); then
        log_message "WARNING: High memory usage: ${MEMORY_USAGE}%"
        # 清理缓存
        echo 3 > /proc/sys/vm/drop_caches
        log_message "Memory cache cleared"
    fi
}

check_disk() {
    DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | cut -d'%' -f1)
    if [ "$DISK_USAGE" -gt "$THRESHOLD_DISK" ]; then
        log_message "WARNING: High disk usage: ${DISK_USAGE}%"
        # 清理日志
        find /var/log -name "*.log" -mtime +7 -delete
        journalctl --vacuum-time=7d
        log_message "Old logs cleaned"
    fi
}

check_services() {
    FAILED_SERVICES=$(systemctl list-units --type=service --state=failed --no-pager --no-legend | wc -l)
    if [ "$FAILED_SERVICES" -gt 0 ]; then
        log_message "WARNING: $FAILED_SERVICES services are in failed state"
        systemctl list-units --type=service --state=failed --no-pager >> "$LOG_FILE"
    fi
}

check_network() {
    # 检查网络连通性
    if ! ping -c 1 8.8.8.8 >/dev/null 2>&1; then
        log_message "WARNING: Network connectivity issue detected"
    fi
    
    # 检查DNS
    if ! nslookup google.com >/dev/null 2>&1; then
        log_message "WARNING: DNS resolution issue detected"
    fi
}

# 主监控函数
main() {
    log_message "Starting system monitoring check"
    
    check_cpu
    check_memory
    check_disk
    check_services
    check_network
    
    log_message "System monitoring check completed"
}

# 如果以脚本方式运行
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
```

## 2 网络管理脚本

### 2.1 网络诊断脚本
```bash
#!/bin/bash
# network-diagnostic.sh - 网络诊断脚本

REPORT_FILE="/tmp/network-diagnostic-$(date +%Y%m%d-%H%M%S).txt"
TARGET_HOST="${1:-google.com}"

echo "网络诊断报告" > "$REPORT_FILE"
echo "目标主机: $TARGET_HOST" >> "$REPORT_FILE"
echo "诊断时间: $(date)" >> "$REPORT_FILE"
echo "="*50 >> "$REPORT_FILE"

# 基本网络信息
echo -e "\n=== 基本网络信息 ===" >> "$REPORT_FILE"
echo "主机名: $(hostname)" >> "$REPORT_FILE"
echo "IP地址:" >> "$REPORT_FILE"
ip addr show >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"
echo "路由表:" >> "$REPORT_FILE"
ip route show >> "$REPORT_FILE"

# DNS信息
echo -e "\n=== DNS信息 ===" >> "$REPORT_FILE"
echo "DNS服务器:" >> "$REPORT_FILE"
cat /etc/resolv.conf >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"
echo "主机名解析:" >> "$REPORT_FILE"
nslookup "$TARGET_HOST" >> "$REPORT_FILE" 2>&1

# 连通性测试
echo -e "\n=== 连通性测试 ===" >> "$REPORT_FILE"
echo "Ping测试:" >> "$REPORT_FILE"
ping -c 4 "$TARGET_HOST" >> "$REPORT_FILE" 2>&1
echo "" >> "$REPORT_FILE"
echo "Traceroute:" >> "$REPORT_FILE"
traceroute "$TARGET_HOST" >> "$REPORT_FILE" 2>&1

# 端口测试
echo -e "\n=== 端口测试 ===" >> "$REPORT_FILE"
COMMON_PORTS="80 443 22 21 25 53 110 143"
for port in $COMMON_PORTS; do
    echo "测试端口 $port:" >> "$REPORT_FILE"
    timeout 3 nc -zv "$TARGET_HOST" "$port" >> "$REPORT_FILE" 2>&1
done

# 网络接口统计
echo -e "\n=== 网络接口统计 ===" >> "$REPORT_FILE"
echo "接口统计:" >> "$REPORT_FILE"
cat /proc/net/dev >> "$REPORT_FILE"

# 网络连接
echo -e "\n=== 网络连接 ===" >> "$REPORT_FILE"
echo "活跃连接:" >> "$REPORT_FILE"
netstat -tuln >> "$REPORT_FILE"

echo "网络诊断完成，报告保存在: $REPORT_FILE"
```

### 2.2 带宽监控脚本
```bash
#!/bin/bash
# bandwidth-monitor.sh - 带宽监控脚本

INTERFACE="${1:-eth0}"
LOG_FILE="/var/log/bandwidth-${INTERFACE}.log"
INTERVAL=60  # 监控间隔（秒）

# 创建日志文件
touch "$LOG_FILE"

get_bytes() {
    cat /proc/net/dev | grep "$INTERFACE:" | awk '{print $2 " " $10}'
}

calculate_speed() {
    local bytes1="$1"
    local bytes2="$2"
    local time_diff="$3"
    
    local speed=$(echo "scale=2; ($bytes2 - $bytes1) / $time_diff * 8 / 1024 / 1024" | bc)
    echo "$speed"
}

monitor_bandwidth() {
    echo "开始监控接口 $INTERFACE 的带宽使用情况..."
    echo "时间,接收速度(Mbps),发送速度(Mbps),总接收(GB),总发送(GB)" >> "$LOG_FILE"
    
    local prev_rx=$(get_bytes | awk '{print $1}')
    local prev_tx=$(get_bytes | awk '{print $2}')
    local start_time=$(date +%s)
    
    while true; do
        sleep "$INTERVAL"
        
        local current_rx=$(get_bytes | awk '{print $1}')
        local current_tx=$(get_bytes | awk '{print $2}')
        local current_time=$(date +%s)
        local time_diff=$((current_time - start_time))
        
        if [ "$time_diff" -gt 0 ]; then
            local rx_speed=$(calculate_speed "$prev_rx" "$current_rx" "$time_diff")
            local tx_speed=$(calculate_speed "$prev_tx" "$current_tx" "$time_diff")
            
            local total_rx_gb=$(echo "scale=2; $current_rx / 1024 / 1024 / 1024" | bc)
            local total_tx_gb=$(echo "scale=2; $current_tx / 1024 / 1024 / 1024" | bc)
            
            local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
            echo "$timestamp,$rx_speed,$tx_speed,$total_rx_gb,$total_tx_gb" >> "$LOG_FILE"
            
            echo "[$timestamp] RX: ${rx_speed} Mbps, TX: ${tx_speed} Mbps, Total RX: ${total_rx_gb} GB, Total TX: ${total_tx_gb} GB"
        fi
        
        prev_rx="$current_rx"
        prev_tx="$current_tx"
        start_time="$current_time"
    done
}

# 显示实时带宽
show_realtime() {
    while true; do
        clear
        echo "=== 实时带宽监控 ($INTERFACE) ==="
        echo "时间: $(date)"
        echo ""
        
        local stats=$(get_bytes)
        local rx_bytes=$(echo "$stats" | awk '{print $1}')
        local tx_bytes=$(echo "$stats" | awk '{print $2}')
        
        local rx_mb=$(echo "scale=2; $rx_bytes / 1024 / 1024" | bc)
        local tx_mb=$(echo "scale=2; $tx_bytes / 1024 / 1024" | bc)
        
        echo "总接收: $rx_mb MB"
        echo "总发送: $tx_mb MB"
        
        sleep 2
    done
}

# 主函数
case "${1:-monitor}" in
    "monitor")
        monitor_bandwidth
        ;;
    "realtime")
        show_realtime
        ;;
    "log")
        if [ -f "$LOG_FILE" ]; then
            echo "最近的带宽使用记录:"
            tail -20 "$LOG_FILE"
        else
            echo "没有找到日志文件: $LOG_FILE"
        fi
        ;;
    *)
        echo "用法: $0 [monitor|realtime|log] [interface]"
        echo "默认接口: eth0"
        exit 1
        ;;
esac
```

## 3 安全相关脚本

### 3.1 安全检查脚本
```bash
#!/bin/bash
# security-check.sh - 安全检查脚本

REPORT_FILE="/tmp/security-check-$(date +%Y%m%d-%H%M%S).txt"

echo "安全检查报告" > "$REPORT_FILE"
echo "检查时间: $(date)" >> "$REPORT_FILE"
echo "主机名: $(hostname)" >> "$REPORT_FILE"
echo "="*50 >> "$REPORT_FILE"

# 用户账户检查
echo -e "\n=== 用户账户检查 ===" >> "$REPORT_FILE"
echo "系统用户:" >> "$REPORT_FILE"
cat /etc/passwd | awk -F: '{print $1 ":" $3 ":" $7}' >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"
echo "UID为0的用户:" >> "$REPORT_FILE"
cat /etc/passwd | awk -F: '$3 == 0 {print $1}' >> "$REPORT_FILE"

# 密码策略检查
echo -e "\n=== 密码策略检查 ===" >> "$REPORT_FILE"
echo "密码文件权限:" >> "$REPORT_FILE"
ls -l /etc/passwd /etc/shadow >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"
echo "空密码用户:" >> "$REPORT_FILE"
cat /etc/shadow | awk -F: '$2 == "" {print $1}' >> "$REPORT_FILE"

# SSH配置检查
echo -e "\n=== SSH配置检查 ===" >> "$REPORT_FILE"
if [ -f "/etc/ssh/sshd_config" ]; then
    echo "SSH端口:" >> "$REPORT_FILE"
    grep "^Port" /etc/ssh/sshd_config >> "$REPORT_FILE" 2>&1
    echo "" >> "$REPORT_FILE"
    echo "Root登录:" >> "$REPORT_FILE"
    grep "^PermitRootLogin" /etc/ssh/sshd_config >> "$REPORT_FILE" 2>&1
    echo "" >> "$REPORT_FILE"
    echo "密码认证:" >> "$REPORT_FILE"
    grep "^PasswordAuthentication" /etc/ssh/sshd_config >> "$REPORT_FILE" 2>&1
fi

# 文件权限检查
echo -e "\n=== 文件权限检查 ===" >> "$REPORT_FILE"
echo "重要文件权限:" >> "$REPORT_FILE"
ls -l /etc/passwd /etc/shadow /etc/group /etc/gshadow >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"
echo "世界可写文件:" >> "$REPORT_FILE"
find / -type f -perm -002 2>/dev/null | head -20 >> "$REPORT_FILE"

# SUID/SGID文件检查
echo -e "\n=== SUID/SGID文件检查 ===" >> "$REPORT_FILE"
echo "SUID文件:" >> "$REPORT_FILE"
find / -type f -perm -4000 2>/dev/null | head -20 >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"
echo "SGID文件:" >> "$REPORT_FILE"
find / -type f -perm -2000 2>/dev/null | head -20 >> "$REPORT_FILE"

# 网络服务检查
echo -e "\n=== 网络服务检查 ===" >> "$REPORT_FILE"
echo "监听端口:" >> "$REPORT_FILE"
netstat -tuln >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"
echo "运行服务:" >> "$REPORT_FILE"
systemctl list-units --type=service --state=running | grep -E "(ssh|http|ftp|telnet)" >> "$REPORT_FILE"

# 防火墙检查
echo -e "\n=== 防火墙检查 ===" >> "$REPORT_FILE"
if command -v ufw >/dev/null 2>&1; then
    echo "UFW状态:" >> "$REPORT_FILE"
    ufw status >> "$REPORT_FILE" 2>&1
fi
if command -v iptables >/dev/null 2>&1; then
    echo "iptables规则:" >> "$REPORT_FILE"
    iptables -L -n >> "$REPORT_FILE" 2>&1
fi

# 系统更新检查
echo -e "\n=== 系统更新检查 ===" >> "$REPORT_FILE"
if command -v apt >/dev/null 2>&1; then
    echo "可用更新:" >> "$REPORT_FILE"
    apt list --upgradable 2>/dev/null | wc -l >> "$REPORT_FILE"
fi
if command -v yum >/dev/null 2>&1; then
    echo "可用更新:" >> "$REPORT_FILE"
    yum check-update 2>/dev/null | wc -l >> "$REPORT_FILE"
fi

echo "安全检查完成，报告保存在: $REPORT_FILE"
```

### 3.2 自动安全更新脚本
```bash
#!/bin/bash
# security-updates.sh - 自动安全更新脚本

LOG_FILE="/var/log/security-updates.log"
EMAIL="admin@example.com"

log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 更新包列表
log_message "开始更新包列表..."
if command -v apt >/dev/null 2>&1; then
    apt update >> "$LOG_FILE" 2>&1
elif command -v yum >/dev/null 2>&1; then
    yum check-update >> "$LOG_FILE" 2>&1
fi

# 安装安全更新
log_message "开始安装安全更新..."
if command -v apt >/dev/null 2>&1; then
    apt -y upgrade >> "$LOG_FILE" 2>&1
    apt -y autoremove >> "$LOG_FILE" 2>&1
elif command -v yum >/dev/null 2>&1; then
    yum -y update --security >> "$LOG_FILE" 2>&1
    yum -y autoremove >> "$LOG_FILE" 2>&1
fi

# 重启需要重启的服务
log_message "检查需要重启的服务..."
if command -v needrestart >/dev/null 2>&1; then
    needrestart -r a >> "$LOG_FILE" 2>&1
fi

# 检查系统状态
log_message "检查系统状态..."
if systemctl is-system-running >/dev/null 2>&1; then
    log_message "系统运行正常"
else
    log_message "WARNING: 系统状态异常"
    echo "系统状态异常，请检查" | mail -s "系统状态警告" "$EMAIL"
fi

# 发送更新报告
if command -v mail >/dev/null 2>&1; then
    echo "安全更新已完成，详细信息请查看日志文件: $LOG_FILE" | \
    mail -s "安全更新报告 - $(hostname)" "$EMAIL"
fi

log_message "安全更新过程完成"
```

## 4 数据库管理脚本

### 4.1 MySQL数据库备份脚本
```bash
#!/bin/bash
# mysql-backup.sh - MySQL数据库备份脚本

BACKUP_DIR="/backup/mysql"
DATE=$(date +%Y%m%d-%H%M%S)
MYSQL_USER="backup"
MYSQL_PASSWORD="backup_password"
RETENTION_DAYS=7

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 获取所有数据库列表
DATABASES=$(mysql -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" -e "SHOW DATABASES;" | grep -Ev "(Database|information_schema|performance_schema|mysql|sys)")

# 备份每个数据库
for db in $DATABASES; do
    echo "正在备份数据库: $db"
    
    # 创建数据库备份
    mysqldump \
        --user="$MYSQL_USER" \
        --password="$MYSQL_PASSWORD" \
        --single-transaction \
        --routines \
        --triggers \
        --databases "$db" \
        > "$BACKUP_DIR/${db}_${DATE}.sql"
    
    # 压缩备份文件
    gzip "$BACKUP_DIR/${db}_${DATE}.sql"
    
    echo "数据库 $db 备份完成"
done

# 备份所有数据库
mysqldump \
    --user="$MYSQL_USER" \
    --password="$MYSQL_PASSWORD" \
    --all-databases \
    --single-transaction \
    > "$BACKUP_DIR/all_databases_${DATE}.sql"

gzip "$BACKUP_DIR/all_databases_${DATE}.sql"

# 清理旧备份
echo "清理超过$RETENTION_DAYS天的旧备份..."
find "$BACKUP_DIR" -name "*.sql.gz" -mtime +$RETENTION_DAYS -delete

# 生成备份报告
echo "MySQL备份完成时间: $(date)" > "$BACKUP_DIR/backup-report-${DATE}.txt"
echo "备份文件列表:" >> "$BACKUP_DIR/backup-report-${DATE}.txt"
ls -lh "$BACKUP_DIR"/*${DATE}*.sql.gz >> "$BACKUP_DIR/backup-report-${DATE}.txt"

echo "MySQL备份完成！备份文件保存在: $BACKUP_DIR"
```

### 4.2 数据库性能监控脚本
```bash
#!/bin/bash
# mysql-performance.sh - MySQL性能监控脚本

LOG_FILE="/var/log/mysql-performance.log"
MYSQL_USER="monitor"
MYSQL_PASSWORD="monitor_password"

log_query() {
    local query="$1"
    local description="$2"
    local result=$(mysql -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" -e "$query" 2>/dev/null)
    echo "[$description]" >> "$LOG_FILE"
    echo "$result" >> "$LOG_FILE"
    echo "" >> "$LOG_FILE"
}

monitor_mysql() {
    echo "MySQL性能监控 - $(date)" > "$LOG_FILE"
    
    # 连接信息
    log_query "SHOW STATUS LIKE 'Threads_%';" "连接线程信息"
    log_query "SHOW STATUS LIKE 'Connections';" "总连接数"
    log_query "SHOW STATUS LIKE 'Max_used_connections';" "最大使用连接数"
    
    # 查询缓存
    log_query "SHOW STATUS LIKE 'Qcache_%';" "查询缓存状态"
    
    # InnoDB状态
    log_query "SHOW STATUS LIKE 'Innodb_%';" "InnoDB状态" | head -20
    
    # 慢查询
    log_query "SHOW STATUS LIKE 'Slow_queries';" "慢查询数量"
    
    # 表锁状态
    log_query "SHOW STATUS LIKE 'Table_locks_%';" "表锁状态"
    
    # 二进制日志
    log_query "SHOW MASTER STATUS;" "主库状态"
    
    # 复制状态（如果是从库）
    log_query "SHOW SLAVE STATUS\G" "从库状态"
    
    # 当前连接
    log_query "SHOW PROCESSLIST;" "当前连接列表"
    
    # InnoDB引擎状态
    echo "InnoDB引擎详细状态:" >> "$LOG_FILE"
    mysql -u "$MYSQL_USER" -p"$MYSQL_PASSWORD" -e "SHOW ENGINE INNODB STATUS\G" >> "$LOG_FILE" 2>/dev/null
}

# 分析慢查询日志
analyze_slow_log() {
    local slow_log="/var/log/mysql/slow.log"
    if [ -f "$slow_log" ]; then
        echo "" >> "$LOG_FILE"
        echo "慢查询日志分析:" >> "$LOG_FILE"
        echo "最近10条慢查询:" >> "$LOG_FILE"
        tail -20 "$slow_log" >> "$LOG_FILE"
    fi
}

# 主函数
main() {
    monitor_mysql
    analyze_slow_log
    
    echo "MySQL性能监控完成，日志保存在: $LOG_FILE"
}

# 如果以脚本方式运行
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
```

## 5 Web服务器管理脚本

### 5.1 虚拟主机管理脚本
```bash
#!/bin/bash
# vhost-manager.sh - 虚拟主机管理脚本

SITES_AVAILABLE="/etc/nginx/sites-available"
SITES_ENABLED="/etc/nginx/sites-enabled"
WEB_ROOT="/var/www"
LOG_DIR="/var/log/nginx"

# 函数：创建虚拟主机
create_vhost() {
    local domain="$1"
    local username="$2"
    
    if [ -z "$domain" ] || [ -z "$username" ]; then
        echo "用法: $0 create <domain> <username>"
        exit 1
    fi
    
    # 创建用户
    if ! id "$username" >/dev/null 2>&1; then
        useradd -m -s /bin/bash "$username"
        echo "用户 $username 已创建"
    fi
    
    # 创建网站目录
    local site_dir="$WEB_ROOT/$domain"
    mkdir -p "$site_dir/public_html"
    mkdir -p "$site_dir/logs"
    
    # 设置权限
    chown -R "$username:$username" "$site_dir"
    chmod 755 "$site_dir"
    chmod 755 "$site_dir/public_html"
    
    # 创建默认页面
    cat > "$site_dir/public_html/index.html" << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <title>Welcome to $domain</title>
</head>
<body>
    <h1>Welcome to $domain</h1>
    <p>This is the default page for your new website.</p>
</body>
</html>
EOF
    
    # 创建Nginx配置
    cat > "$SITES_AVAILABLE/$domain" << EOF
server {
    listen 80;
    listen [::]:80;
    
    server_name $domain www.$domain;
    
    root $site_dir/public_html;
    index index.html index.htm index.php;
    
    access_log $site_dir/logs/access.log;
    error_log $site_dir/logs/error.log;
    
    location / {
        try_files \$uri \$uri/ =404;
    }
    
    location ~ \\.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;
    }
    
    location ~ /\.ht {
        deny all;
    }
}
EOF
    
    # 启用站点
    ln -sf "$SITES_AVAILABLE/$domain" "$SITES_ENABLED/"
    
    # 测试配置
    nginx -t && systemctl reload nginx
    
    echo "虚拟主机 $domain 已创建并启用"
    echo "网站目录: $site_dir/public_html"
    echo "日志目录: $site_dir/logs"
}

# 函数：删除虚拟主机
delete_vhost() {
    local domain="$1"
    
    if [ -z "$domain" ]; then
        echo "用法: $0 delete <domain>"
        exit 1
    fi
    
    # 禁用站点
    rm -f "$SITES_ENABLED/$domain"
    
    # 删除配置
    rm -f "$SITES_AVAILABLE/$domain"
    
    # 可选：删除网站目录
    read -p "是否删除网站目录 $WEB_ROOT/$domain? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        rm -rf "$WEB_ROOT/$domain"
        echo "网站目录已删除"
    fi
    
    # 重载Nginx
    nginx -t && systemctl reload nginx
    
    echo "虚拟主机 $domain 已删除"
}

# 函数：列出虚拟主机
list_vhosts() {
    echo "已启用的虚拟主机:"
    ls -1 "$SITES_ENABLED"
    echo ""
    echo "可用的虚拟主机:"
    ls -1 "$SITES_AVAILABLE"
}

# 主函数
case "$1" in
    "create")
        create_vhost "$2" "$3"
        ;;
    "delete")
        delete_vhost "$2"
        ;;
    "list")
        list_vhosts
        ;;
    *)
        echo "用法: $0 {create|delete|list} [参数...]"
        echo ""
        echo "命令:"
        echo "  create <domain> <username>  - 创建虚拟主机"
        echo "  delete <domain>             - 删除虚拟主机"
        echo "  list                        - 列出虚拟主机"
        exit 1
        ;;
esac
```

### 5.2 SSL证书管理脚本
```bash
#!/bin/bash
# ssl-manager.sh - SSL证书管理脚本

CERT_DIR="/etc/ssl/certs"
KEY_DIR="/etc/ssl/private"
NGINX_SITES="/etc/nginx/sites-enabled"

# 函数：生成自签名证书
generate_self_signed() {
    local domain="$1"
    
    if [ -z "$domain" ]; then
        echo "用法: $0 generate-self-signed <domain>"
        exit 1
    fi
    
    # 创建证书目录
    mkdir -p "$CERT_DIR"
    mkdir -p "$KEY_DIR"
    chmod 700 "$KEY_DIR"
    
    # 生成私钥
    openssl genrsa -out "$KEY_DIR/$domain.key" 2048
    chmod 600 "$KEY_DIR/$domain.key"
    
    # 生成证书签名请求
    openssl req -new -key "$KEY_DIR/$domain.key" -out "/tmp/$domain.csr" \
        -subj "/C=US/ST=State/L=City/O=Organization/CN=$domain"
    
    # 生成自签名证书
    openssl x509 -req -days 365 -in "/tmp/$domain.csr" \
        -signkey "$KEY_DIR/$domain.key" -out "$CERT_DIR/$domain.crt"
    
    # 清理临时文件
    rm -f "/tmp/$domain.csr"
    
    echo "自签名证书已生成:"
    echo "证书: $CERT_DIR/$domain.crt"
    echo "私钥: $KEY_DIR/$domain.key"
}

# 函数：配置Nginx SSL
configure_nginx_ssl() {
    local domain="$1"
    
    if [ -z "$domain" ]; then
        echo "用法: $0 configure-nginx <domain>"
        exit 1
    fi
    
    # 检查证书文件
    if [ ! -f "$CERT_DIR/$domain.crt" ] || [ ! -f "$KEY_DIR/$domain.key" ]; then
        echo "错误: 找不到证书文件"
        exit 1
    fi
    
    # 检查Nginx配置文件
    local nginx_conf="$NGINX_SITES/$domain"
    if [ ! -f "$nginx_conf" ]; then
        echo "错误: 找不到Nginx配置文件: $nginx_conf"
        exit 1
    fi
    
    # 创建SSL配置
    cat > "$nginx_conf.ssl" << EOF
server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    
    server_name $domain www.$domain;
    
    ssl_certificate $CERT_DIR/$domain.crt;
    ssl_certificate_key $KEY_DIR/$domain.key;
    
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384;
    ssl_prefer_server_ciphers off;
    
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_stapling on;
    ssl_stapling_verify on;
    
    # 其他配置与HTTP相同
    include $nginx_conf;
}

server {
    listen 80;
    listen [::]:80;
    
    server_name $domain www.$domain;
    
    # 重定向到HTTPS
    return 301 https://\$server_name\$request_uri;
}
EOF
    
    echo "SSL配置已创建: $nginx_conf.ssl"
    echo "请检查配置并重启Nginx: nginx -t && systemctl restart nginx"
}

# 函数：获取Let's Encrypt证书
get_letsencrypt_cert() {
    local domain="$1"
    
    if [ -z "$domain" ]; then
        echo "用法: $0 letsencrypt <domain>"
        exit 1
    fi
    
    # 检查是否安装了certbot
    if ! command -v certbot >/dev/null 2>&1; then
        echo "错误: 未安装certbot"
        echo "请安装: apt install certbot python3-certbot-nginx"
        exit 1
    fi
    
    # 获取证书
    certbot --nginx -d "$domain" -d "www.$domain" --agree-tos --non-interactive --email admin@$domain
    
    if [ $? -eq 0 ]; then
        echo "Let's Encrypt证书获取成功"
        echo "证书将自动续期（certbot会自动配置cron任务）"
    else
        echo "证书获取失败"
        exit 1
    fi
}

# 函数：检查证书有效期
check_cert_expiry() {
    local domain="$1"
    
    if [ -z "$domain" ]; then
        echo "用法: $0 check-expiry <domain>"
        exit 1
    fi
    
    if [ -f "$CERT_DIR/$domain.crt" ]; then
        echo "检查证书有效期: $domain"
        openssl x509 -in "$CERT_DIR/$domain.crt" -noout -dates
        
        # 计算剩余天数
        expiry_date=$(openssl x509 -in "$CERT_DIR/$domain.crt" -noout -enddate | cut -d= -f2)
        expiry_epoch=$(date -d "$expiry_date" +%s)
        current_epoch=$(date +%s)
        days_left=$(( (expiry_epoch - current_epoch) / 86400 ))
        
        echo "剩余天数: $days_left"
        
        if [ "$days_left" -lt 30 ]; then
            echo "警告: 证书将在30天内过期！"
        fi
    else
        echo "错误: 找不到证书文件: $CERT_DIR/$domain.crt"
    fi
}

# 主函数
case "$1" in
    "generate-self-signed")
        generate_self_signed "$2"
        ;;
    "configure-nginx")
        configure_nginx_ssl "$2"
        ;;
    "letsencrypt")
        get_letsencrypt_cert "$2"
        ;;
    "check-expiry")
        check_cert_expiry "$2"
        ;;
    *)
        echo "用法: $0 {generate-self-signed|configure-nginx|letsencrypt|check-expiry} <domain>"
        echo ""
        echo "命令:"
        echo "  generate-self-signed <domain>  - 生成自签名证书"
        echo "  configure-nginx <domain>       - 配置Nginx SSL"
        echo "  letsencrypt <domain>           - 获取Let's Encrypt证书"
        echo "  check-expiry <domain>          - 检查证书有效期"
        exit 1
        ;;
esac
```

这些常用脚本涵盖了系统管理、网络管理、安全检查、数据库管理和Web服务器管理等多个方面，可以作为日常Linux系统管理的工具集合。每个脚本都包含了详细的使用说明和错误处理，可以根据实际需求进行修改和扩展。