# mv命令详解

## 1. 命令概述

`mv`命令是Linux系统中的一个基本命令，用于移动或重命名文件和目录（move）。通过`mv`命令，用户可以在文件系统中移动文件和目录，或者更改它们的名称。这个命令在日常文件管理中非常常用，既可以用于文件的组织整理，也可以用于文件的备份和归档。

### 命令用途

- 重命名文件或目录
- 移动文件或目录到另一个位置
- 批量移动文件
- 强制移动文件或目录
- 交互式移动文件或目录
- 移动文件时保留文件属性

## 2. 命令语法

`mv`命令的基本语法如下：

```bash
mv [选项] 源文件 目标文件
mv [选项] 源文件... 目标目录
```

其中：
- `选项`：用于修改命令的行为，可选
- `源文件`：指定要移动或重命名的源文件或目录
- `目标文件`：指定移动或重命名后的目标文件
- `目标目录`：指定移动后的目标目录

## 3. 常用选项

`mv`命令支持众多选项，以下是最常用的一些选项：

| 选项 | 长选项 | 描述 |
|------|--------|------|
| `-f` | `--force` | 强制移动，覆盖已存在的目标文件，不提示 |
| `-i` | `--interactive` | 交互式移动，覆盖已存在的目标文件前提示确认 |
| `-n` | `--no-clobber` | 不覆盖已存在的目标文件 |
| `-u` | `--update` | 仅当源文件比目标文件新或者目标文件不存在时才移动 |
| `-v` | `--verbose` | 显示详细的移动过程信息 |
| `-b` | `--backup` | 创建目标文件的备份，而不是直接覆盖 |
| `--suffix=SUFFIX` |  | 为备份文件指定后缀（默认是"~") |
| `-t` | `--target-directory=DIRECTORY` | 将所有源文件移动到指定的目标目录 |
| `-T` | `--no-target-directory` | 将目标视为普通文件，而不是目录 |

## 4. 使用示例

### 4.1 基本用法

```bash
# 创建一个测试文件
touch file1.txt

# 重命名文件
mv file1.txt file2.txt

# 验证文件是否被重命名
ls -l file1.txt file2.txt

# 创建一个测试目录
mkdir documents

# 将文件移动到另一个目录
mv file2.txt documents/

# 验证文件是否被移动
ls -l file2.txt documents/file2.txt

# 移动多个文件到指定目录
mkdir pictures
touch photo1.jpg photo2.jpg
mv photo1.jpg photo2.jpg pictures/

# 验证文件是否被移动
ls -l photo1.jpg photo2.jpg pictures/
```

### 4.2 交互式移动

使用`-i`选项可以在覆盖已存在的文件前提示用户确认：

```bash
# 创建两个文件
cat > file1.txt << 'EOF'
这是第一个文件。
EOF

cat > file2.txt << 'EOF'
这是第二个文件。
EOF

# 交互式移动文件，覆盖已存在的文件前会提示
mv -i file1.txt file2.txt
# 输出：mv: overwrite 'file2.txt'?
# 输入y或Y确认覆盖，输入n或N取消操作

# 检查文件内容是否被覆盖
cat file2.txt
```

### 4.3 强制移动

使用`-f`选项可以强制移动文件，覆盖已存在的文件，不提示确认：

```bash
# 重新创建两个文件
cat > file1.txt << 'EOF'
这是新的内容。
EOF

cat > file2.txt << 'EOF'
这是要被覆盖的内容。
EOF

# 强制移动，不提示确认
mv -f file1.txt file2.txt

# 检查文件内容是否被覆盖
cat file2.txt
```

### 4.4 移动目录

`mv`命令可以直接移动目录，不需要额外的递归选项：

```bash
# 创建一个测试目录及其内容
mkdir -p src_dir/{subdir1,subdir2}
touch src_dir/file1.txt src_dir/subdir1/file2.txt src_dir/subdir2/file3.txt

# 移动整个目录
mv src_dir dest_dir

# 验证目录是否被移动
ls -l src_dir dest_dir
find dest_dir -type f | sort

# 重命名目录
mv dest_dir renamed_dir

# 验证目录是否被重命名
ls -l dest_dir renamed_dir
```

### 4.5 显示详细的移动过程

使用`-v`选项可以显示文件移动的详细过程：

```bash
# 创建一些测试文件和目录
mkdir -p test_dir
touch test_dir/file1.txt test_dir/file2.txt test_dir/file3.txt
mkdir destination

# 使用-v选项显示详细移动过程
mv -v test_dir/* destination/
# 输出类似：
# 'test_dir/file1.txt' -> 'destination/file1.txt'
# 'test_dir/file2.txt' -> 'destination/file2.txt'
# 'test_dir/file3.txt' -> 'destination/file3.txt'

# 移动目录时显示详细过程
mv -v test_dir empty_dir
# 输出类似：'test_dir' -> 'empty_dir'
```

### 4.6 仅移动更新的文件

使用`-u`选项可以仅移动比目标文件新或者目标文件不存在的文件：

```bash
# 创建测试文件
mkdir -p source_dir target_dir
touch -d "2023-01-01 12:00:00" source_dir/old_file.txt
touch -d "2023-09-01 12:00:00" source_dir/new_file.txt
cp -p source_dir/old_file.txt target_dir/  # 复制旧文件到目标目录

# 使用-u选项移动，只会移动新文件
mv -uv source_dir/* target_dir/
# 输出类似：'source_dir/new_file.txt' -> 'target_dir/new_file.txt'

# 验证结果
ls -l target_dir/
```

### 4.7 创建备份文件

使用`-b`选项可以在覆盖文件前创建备份：

```bash
# 创建测试文件
cat > file.txt << 'EOF'
原始内容
EOF

# 移动文件，创建备份
mv -b file.txt backup.txt

# 更改原始文件内容
cat > file.txt << 'EOF'
新内容
EOF

# 再次移动文件，会创建备份文件
mv -b file.txt backup.txt

# 验证备份文件是否创建
ls -l file.txt backup.txt backup.txt~

# 查看备份文件的内容
cat backup.txt~
```

### 4.8 使用通配符移动文件

可以使用通配符来移动符合特定模式的文件：

```bash
# 创建一些测试文件
touch file1.txt file2.txt file3.txt doc1.pdf doc2.pdf image1.jpg image2.jpg

# 使用通配符移动所有.txt文件
mkdir text_files
mv *.txt text_files/

# 验证文件是否被移动
ls -l *.txt text_files/

# 使用通配符移动所有.pdf和.jpg文件
mkdir media_files
mv *.pdf *.jpg media_files/

# 验证文件是否被移动
ls -l *.pdf *.jpg media_files/

# 使用复杂的通配符模式
mkdir specific_files
mv file[1-3].txt specific_files/
ls -l specific_files/
```

### 4.9 使用-t选项指定目标目录

使用`-t`选项可以在命令开头指定目标目录，这在脚本中特别有用：

```bash
# 创建测试文件和目录
mkdir -p destination_dir

touch file1.txt file2.txt file3.txt

# 普通方式：先指定源文件，最后指定目标目录
mv file1.txt file2.txt file3.txt destination_dir/

# 使用-t选项：先指定目标目录，再指定源文件
mv -t destination_dir/ file1.txt file2.txt file3.txt

# 在脚本中结合find命令使用-t选项
find . -name "*.log" -type f -exec mv -t logs_dir/ {} +
```

### 4.10 移动隐藏文件

默认情况下，使用`mv *`命令不会移动以`.`开头的隐藏文件。可以使用以下方法移动隐藏文件：

```bash
# 移动所有文件（包括隐藏文件）
mv -v .[!.]* * /path/to/destination/

# 解释：
# .[!.]* 匹配所有以.开头但不是..的文件（即所有隐藏文件）
# * 匹配所有非隐藏文件

# 或者使用find命令移动隐藏文件
find . -maxdepth 1 -name '.*' -type f -exec mv -v {} /path/to/destination/ \;
```

## 5. 高级用法

### 5.1 批量重命名文件

`mv`命令可以结合其他命令（如`find`、`awk`、`sed`等）进行批量重命名：

```bash
# 创建测试文件
touch file1.txt file2.txt file3.txt
touch document1.pdf document2.pdf document3.pdf

# 使用for循环批量重命名文件
for file in file*.txt; do
  new_name="text_${file}"
  mv -v "$file" "$new_name"
done

# 验证结果
ls -l text_*.txt

# 使用sed命令进行更复杂的重命名
for file in document*.pdf; do
  new_name=$(echo "$file" | sed 's/document/report/')
  mv -v "$file" "$new_name"
done

# 验证结果
ls -l report*.pdf

# 使用find命令结合xargs进行批量重命名
find . -name "*.txt" -type f | xargs -I {} bash -c 'mv "{}" "text_$(basename "{}")"'
```

### 5.2 移动文件时保留文件属性

`mv`命令在同一文件系统中移动文件时，默认会保留文件的所有权和权限。但如果需要明确指定或在不同文件系统间移动，可以使用`rsync`命令：

```bash
# 安装rsync命令（通常已经预装）
sudo apt install rsync

sudo yum install rsync

# 创建测试文件，并设置特定的权限和时间戳
cat > preserve_test.txt << 'EOF'
测试保留属性
EOF
chmod 755 preserve_test.txt
sudo touch -d "2022-01-01 12:00:00" preserve_test.txt

sudo chown nobody:nogroup preserve_test.txt  # 更改所有者

# 检查源文件的属性
ls -l preserve_test.txt
stat preserve_test.txt

# 使用rsync命令移动文件并保留所有属性
rsync -av --remove-source-files preserve_test.txt destination/

# 验证属性是否被保留
ls -l destination/preserve_test.txt
stat destination/preserve_test.txt
```

### 5.3 移动大文件时显示进度

对于大文件的移动，可以结合`pv`命令显示移动进度（如果系统中安装了`pv`命令）：

```bash
# 安装pv命令（以Ubuntu为例）
sudo apt install pv

# 创建一个大文件用于测试
fallocate -l 1G test_large_file.bin

# 使用pv命令显示移动进度
pv test_large_file.bin > destination/large_file.bin && rm test_large_file.bin

# 或者使用rsync命令显示移动进度
rsync -ah --progress test_large_file.bin destination/
```

### 5.4 移动文件并自动创建目录结构

可以创建一个函数，在移动文件时自动创建不存在的目标目录：

```bash
# 在~/.bashrc或~/.zshrc中添加以下函数
function mv_mkdir() {
  if [ $# -lt 2 ]; then
    echo "用法: mv_mkdir 源文件... 目标目录"
    return 1
  fi
  
  # 获取目标目录
  DEST_DIR="${@: -1}"
  
  # 检查目标是否为目录
  if [ ! -d "$DEST_DIR" ]; then
    # 如果目标不是目录，且只有一个源文件，则创建目标文件的父目录
    if [ $# -eq 2 ]; then
      DEST_PARENT="$(dirname "$DEST_DIR")"
      mkdir -p "$DEST_PARENT"
      mv -iv "$@"
    else
      echo "错误：当指定多个源文件时，目标必须是一个目录"
      return 1
    fi
  else
    # 目标是目录，确保它存在
    mkdir -p "$DEST_DIR"
    mv -iv "$@"
  fi
}

alias mvm='mv_mkdir'

source ~/.bashrc  # 重新加载配置文件

# 使用这个函数
touch test.txt
mvm test.txt non_existent_dir/
ls -l non_existent_dir/test.txt

mvm file1.txt file2.txt new_dir/
ls -l new_dir/
```

### 5.5 移动文件时排除特定文件或目录

可以使用`rsync`命令（而不是`mv`命令）来排除特定的文件或目录：

```bash
# 安装rsync命令（通常已经预装）
sudo apt install rsync

# 创建测试目录结构
mkdir -p exclude_test/{dir1,dir2,dir3}
touch exclude_test/file1.txt exclude_test/file2.log exclude_test/dir1/file3.txt exclude_test/dir2/file4.log exclude_test/dir3/file5.txt

# 使用rsync命令移动，并排除.log文件
rsync -av --exclude='*.log' --remove-source-files exclude_test/ exclude_dest/

# 验证结果
find exclude_dest -type f | sort  # 应该不包含.log文件
find exclude_test -type f | sort  # 源目录中应该只剩下.log文件

# 排除多个模式
rsync -av --exclude='*.log' --exclude='dir3' --remove-source-files exclude_test/ exclude_dest2/

# 验证结果
find exclude_dest2 -type f | sort  # 应该不包含.log文件和dir3目录
```

## 6. 实用技巧

### 6.1 创建一个安全的移动函数

可以创建一个函数，在移动文件时进行额外的检查，增加操作的安全性：

```bash
# 在~/.bashrc或~/.zshrc中添加以下函数
function mv_safe() {
  # 检查参数数量
  if [ $# -lt 2 ]; then
    echo "用法: mv_safe 源文件/目录... 目标文件/目录"
    return 1
  fi
  
  # 检查最后一个参数是否为目录
  last_arg="${@: -1}"
  if [ -d "$last_arg" ]; then
    # 目标是目录，检查是否有多个源文件
    if [ $# -gt 2 ]; then
      echo "正在将多个文件移动到目录 '$last_arg'..."
      mv -iv "$@"
    else
      echo "正在将文件移动到目录 '$last_arg'..."
      mv -iv "$@"
    fi
  else
    # 目标是文件，检查是否已存在
    if [ -f "$last_arg" ]; then
      echo "警告：文件 '$last_arg' 已存在"
      echo "  源文件大小: $(ls -lh "$1" | awk '{print $5}')"
      echo "  目标文件大小: $(ls -lh "$last_arg" | awk '{print $5}')"
      echo "  源文件修改时间: $(stat -c %y "$1")"
      echo "  目标文件修改时间: $(stat -c %y "$last_arg")"
      read -p "确定要覆盖吗？(y/n): " confirm
      if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
        mv -iv "$@"
      else
        echo "移动操作已取消"
        return 1
      fi
    else
      echo "正在创建新文件 '$last_arg'..."
      mv -iv "$@"
    fi
  fi
}

alias mva='mv_safe'

source ~/.bashrc  # 重新加载配置文件

# 使用这个函数
mva file1.txt file2.txt
mva file1.txt file2.txt backup_dir/
```

### 6.2 按文件类型整理文件

可以创建一个脚本，自动按文件类型整理文件到不同的目录：

```bash
# 创建文件整理脚本
cat > organize_files.sh << 'EOF'
#!/bin/bash
# 按文件类型整理文件到不同的目录

# 定义目标目录
TARGET_DIR="$1"
if [ -z "$TARGET_DIR" ]; then
  TARGET_DIR="./organized"
fi

# 创建目标目录结构
mkdir -p "$TARGET_DIR"/{docs,images,videos,audio,archives,scripts,others}

# 移动文件到相应的目录

# 文档文件
echo "移动文档文件..."
mv -v *.{doc,docx,pdf,txt,ppt,pptx,xls,xlsx,odt,ods,odp} "$TARGET_DIR/docs/" 2>/dev/null

# 图片文件
echo "移动图片文件..."
mv -v *.{jpg,jpeg,png,gif,bmp,svg,tiff} "$TARGET_DIR/images/" 2>/dev/null

# 视频文件
echo "移动视频文件..."
mv -v *.{mp4,mkv,avi,mov,wmv,flv} "$TARGET_DIR/videos/" 2>/dev/null

# 音频文件
echo "移动音频文件..."
mv -v *.{mp3,wav,ogg,flac,aac} "$TARGET_DIR/audio/" 2>/dev/null

# 压缩文件
echo "移动压缩文件..."
mv -v *.{zip,tar.gz,tgz,rar,7z} "$TARGET_DIR/archives/" 2>/dev/null

# 脚本文件
echo "移动脚本文件..."
mv -v *.{sh,py,pl,rb,js} "$TARGET_DIR/scripts/" 2>/dev/null

# 其他文件（如果需要）
# echo "移动其他文件..."
# mv -v * "$TARGET_DIR/others/" 2>/dev/null

echo "文件整理完成！请查看 '$TARGET_DIR/' 目录。"
EOF

# 使脚本可执行
chmod +x organize_files.sh

# 运行脚本进行文件整理
./organize_files.sh  # 使用默认目标目录
# 或指定目标目录
# ./organize_files.sh /path/to/target_dir
```

### 6.3 创建日期标记的备份目录

可以创建一个脚本，自动创建日期标记的备份目录，并移动文件进行备份：

```bash
# 创建备份脚本
cat > backup_with_date.sh << 'EOF'
#!/bin/bash
# 创建日期标记的备份目录并移动文件

# 定义源文件和目录
BACKUP_SOURCES=("$HOME/Documents/important" "$HOME/Pictures" "$HOME/.bashrc")

# 定义备份根目录
BACKUP_ROOT="$HOME/backups"

# 创建带日期标记的备份目录
DATE_STAMP=$(date '+%Y%m%d')
BACKUP_DIR="$BACKUP_ROOT/backup_$DATE_STAMP"
mkdir -p "$BACKUP_DIR"

# 移动文件到备份目录
for SOURCE in "${BACKUP_SOURCES[@]}"; do
  if [ -e "$SOURCE" ]; then
    SOURCE_NAME="$(basename "$SOURCE")"
    echo "正在备份 '$SOURCE' 到 '$BACKUP_DIR/$SOURCE_NAME'..."
    mv -v "$SOURCE" "$BACKUP_DIR/"
  else
    echo "警告：源 '$SOURCE' 不存在，跳过"
  fi
done

echo "备份完成！备份文件保存在 '$BACKUP_DIR/'"
EOF

# 使脚本可执行
chmod +x backup_with_date.sh

# 运行脚本进行备份
./backup_with_date.sh
```

### 6.4 批量移动文件并更改大小写

可以创建一个脚本，批量移动文件并更改文件名的大小写：

```bash
# 创建大小写转换脚本
cat > case_conversion.sh << 'EOF'
#!/bin/bash
# 批量移动文件并更改文件名的大小写

# 检查参数
ACTION="$1"
DEST_DIR="$2"

if [ -z "$ACTION" ] || [ -z "$DEST_DIR" ]; then
  echo "用法: $0 [upper|lower] 目标目录"
  echo "  upper: 转换为大写"
  echo "  lower: 转换为小写"
  return 1
fi

# 创建目标目录
mkdir -p "$DEST_DIR"

# 根据操作转换大小写并移动文件
if [ "$ACTION" = "upper" ]; then
  echo "将文件名转换为大写并移动到 '$DEST_DIR'..."
  for file in *; do
    if [ -f "$file" ]; then
      new_name="$(echo "$file" | tr '[:lower:]' '[:upper:]')"
      mv -v "$file" "$DEST_DIR/$new_name"
    fi
  done
elif [ "$ACTION" = "lower" ]; then
  echo "将文件名转换为小写并移动到 '$DEST_DIR'..."
  for file in *; do
    if [ -f "$file" ]; then
      new_name="$(echo "$file" | tr '[:upper:]' '[:lower:]')"
      mv -v "$file" "$DEST_DIR/$new_name"
    fi
  done
else
  echo "错误：操作必须是 'upper' 或 'lower'"
  return 1
fi

echo "操作完成！"
EOF

# 使脚本可执行
chmod +x case_conversion.sh

# 创建测试文件
touch File1.txt FILE2.txt file3.TXT Document.PDF Image.JPG

# 运行脚本转换为大写
./case_conversion.sh upper upper_case_files/

# 验证结果
ls -l upper_case_files/

# 运行脚本转换为小写
./case_conversion.sh lower lower_case_files/

# 验证结果
ls -l lower_case_files/
```

### 6.5 使用mv命令恢复文件

可以结合备份文件，使用`mv`命令恢复误删除或损坏的文件：

```bash
# 假设我们有一个备份目录
BACKUP_DIR="/path/to/backup"

# 恢复单个文件
mv -iv "$BACKUP_DIR/path/to/file.txt" "/path/to/file.txt"

# 恢复整个目录
mv -iv "$BACKUP_DIR/etc/" /etc/

# 只恢复比目标文件新的文件
# 使用rsync命令
rsync -auv --progress "$BACKUP_DIR/" /path/to/destination/
```

## 7. 常见问题与解决方案

### 7.1 权限被拒绝

问题：执行`mv`命令时出现"Permission denied"错误

解决方案：这意味着你没有权限读取源文件或写入目标位置。可以尝试以下方法：

```bash
# 检查源文件的权限
ls -l source_file

# 检查目标位置的权限
ls -ld destination_directory

# 如果权限不足，可以使用sudo（需要管理员权限）
sudo mv source_file destination

# 或者更改文件/目录的权限
chmod +r source_file
chmod +w destination_directory
```

### 7.2 无法移动文件

问题：尝试移动文件时出现"Device or resource busy"错误

解决方案：这意味着文件正在被其他程序使用。可以尝试以下方法：

```bash
# 找出正在使用该文件的进程
lsof /path/to/file

# 终止使用该文件的进程（谨慎操作）
kill -9 PID  # 替换PID为实际的进程ID

# 或者等待进程完成后再移动文件

# 在某些情况下，可以使用强制移动（可能会导致程序异常）
sudo mv -f /path/to/file /new/path/
```

### 7.3 磁盘空间不足

问题：移动文件到其他分区时出现"No space left on device"错误

解决方案：这意味着目标磁盘没有足够的空间。可以尝试以下方法：

```bash
# 检查目标磁盘的可用空间
df -h /path/to/destination

# 查找并删除目标磁盘上不需要的文件

# 或者压缩文件后再移动
zip -r archive.zip source_file
mv archive.zip /path/to/destination

# 到达目标位置后解压缩
cd /path/to/destination
unzip archive.zip
```

### 7.4 跨文件系统移动

问题：在不同文件系统间移动文件时，文件的权限和所有权可能会发生变化

解决方案：可以使用`rsync`命令来保留文件属性：

```bash
# 安装rsync命令

sudo apt install rsync

sudo yum install rsync

# 使用rsync命令在不同文件系统间移动文件并保留属性
rsync -av --remove-source-files source_file destination/
```

### 7.5 文件名包含特殊字符

问题：文件名包含空格、引号或其他特殊字符，无法正确移动

解决方案：使用引号或转义字符来处理特殊字符：

```bash
# 使用双引号处理包含空格的文件名
mv "file with spaces.txt" "destination directory/"

# 使用单引号处理包含双引号的文件名
mv 'file with "quotes".txt' destination/

# 使用转义字符处理特殊字符
mv file\ with\ spaces.txt destination/
mv report\ \(2023\).pdf destination/

# 对于以连字符开头的文件名，可以使用--选项
mv -- -file_with_dash.txt destination/

# 或者使用绝对路径或相对路径
mv ./-file_with_dash.txt destination/
```

## 8. 实践练习

### 练习1：基本用法

```bash
# 创建测试文件
touch file1.txt

# 重命名文件
mv file1.txt file2.txt

# 验证文件是否被重命名
ls -l file1.txt file2.txt

# 创建测试目录
mkdir documents

# 将文件移动到目录
mv file2.txt documents/

# 验证文件是否被移动
ls -l file2.txt documents/file2.txt

# 移动多个文件到目录
touch file3.txt file4.txt
mv file3.txt file4.txt documents/

# 验证文件是否被移动
ls -l file3.txt file4.txt documents/
```

### 练习2：交互式和强制移动

```bash
# 创建两个文件
cat > file1.txt << 'EOF'
这是第一个文件。
EOF

cat > file2.txt << 'EOF'
这是第二个文件。
EOF

# 交互式移动文件，覆盖前会提示
mv -i file1.txt file2.txt

# 检查文件内容
cat file2.txt

# 重新创建文件
cat > file1.txt << 'EOF'
这是新的内容。
EOF

cat > file2.txt << 'EOF'
这是要被覆盖的内容。
EOF

# 强制移动，不提示确认
mv -f file1.txt file2.txt

# 检查文件内容
cat file2.txt
```

### 练习3：移动目录

```bash
# 创建测试目录及其内容
mkdir -p dir1/{subdir1,subdir2}
touch dir1/file1.txt dir1/subdir1/file2.txt dir1/subdir2/file3.txt

# 移动整个目录
mv dir1 dir2

# 验证目录是否被移动
ls -l dir1 dir2
find dir2 -type f | sort

# 重命名目录
mv dir2 renamed_dir

# 验证目录是否被重命名
ls -l dir2 renamed_dir
```

### 练习4：使用通配符和高级选项

```bash
# 创建各种类型的测试文件
touch file1.txt file2.txt doc1.pdf doc2.pdf image1.jpg image2.jpg

# 使用通配符移动文件
mkdir txt_files pdf_files img_files
mv *.txt txt_files/
mv *.pdf pdf_files/
mv *.jpg img_files/

# 验证结果
ls -l txt_files/ pdf_files/ img_files/

# 使用-v选项显示详细移动过程
mkdir verbose_dir
touch test1.txt test2.txt
mv -v test*.txt verbose_dir/

# 使用-t选项指定目标目录
mkdir target_dir
touch item1.txt item2.txt item3.txt
mv -t target_dir/ item1.txt item2.txt item3.txt

# 验证结果
ls -l target_dir/
```

### 练习5：创建和使用自定义函数

```bash
# 在~/.bashrc文件中添加mv_safe函数
cat >> ~/.bashrc << 'EOF'
function mv_safe() {
  if [ $# -lt 2 ]; then
    echo "用法: mv_safe 源文件/目录... 目标文件/目录"
    return 1
  fi
  
  last_arg="${@: -1}"
  if [ -d "$last_arg" ]; then
    mv -iv "$@"
  else
    if [ -f "$last_arg" ]; then
      echo "警告：文件 '$last_arg' 已存在"
      read -p "确定要覆盖吗？(y/n): " confirm
      if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
        mv -iv "$@"
      else
        echo "移动操作已取消"
        return 1
      fi
    else
      mv -iv "$@"
    fi
  fi
}

alias mva='mv_safe'
EOF

source ~/.bashrc  # 重新加载配置文件

# 创建测试文件和目录
touch file1.txt file2.txt
mkdir test_dir
touch test_dir/file3.txt

# 使用mv_safe函数
mva file1.txt file2.txt
mva file2.txt test_dir/

# 尝试覆盖已存在的文件
mva file3.txt file2.txt
```

通过本章的学习，我们详细了解了`mv`命令的各种用法、选项和技巧。`mv`命令是Linux系统中用于移动和重命名文件和目录的基本工具，在日常文件管理中有着广泛的应用。通过灵活运用其选项和结合其他命令，可以高效地组织和管理文件系统中的数据。在使用`mv`命令时，尤其是在覆盖文件时，应当格外小心，避免误操作造成数据丢失。