# sar命令详解

## 1 命令概述

`sar`（System Activity Reporter）是一个强大的系统性能监控工具，用于收集、报告和保存系统活动信息。它可以提供关于CPU、内存、磁盘、网络、系统调用、文件系统、NFS和进程等方面的详细性能数据。

### 1.1 功能特点

- 收集并保存系统活动数据，便于长期性能分析和趋势监控
- 生成详细的报告，包括CPU使用率、内存使用、I/O性能、网络流量等
- 支持实时监控和历史数据分析
- 可配置的数据收集间隔和保存期限
- 丰富的选项和参数，可定制监控内容和输出格式

### 1.2 应用场景

- 系统性能基准测试和监控
- 识别系统瓶颈和性能问题
- 计划系统资源升级和容量规划
- 分析系统故障和异常行为
- 监控系统稳定性和可靠性
- 生成定期性能报告

## 2 语法格式

`sar`命令的基本语法格式如下：

```bash
sar [选项] [时间间隔] [次数] [-o 文件名] [-f 文件名]
```

参数说明：

- `选项`：控制监控内容和输出格式
- `时间间隔`：数据收集的时间间隔（秒）
- `次数`：收集数据的次数
- `-o 文件名`：将收集的数据保存到指定文件
- `-f 文件名`：从指定文件读取数据并显示

## 3 常用选项

`sar`命令提供了丰富的选项，用于指定要监控的系统资源类型和输出格式。以下是最常用的选项：

| 选项 | 说明 |
|------|------|
| `-A` | 显示所有报告内容 |
| `-u` | 显示CPU使用率统计信息 |
| `-r` | 显示内存和交换空间使用率统计信息 |
| `-B` | 显示内存分页统计信息 |
| `-b` | 显示I/O和传输速率统计信息 |
| `-d` | 显示磁盘使用率统计信息 |
| `-n` | 显示网络统计信息，可指定DEV、EDEV、NFS、NFSD、SOCK等子选项 |
| `-q` | 显示系统负载统计信息 |
| `-w` | 显示系统交换活动统计信息 |
| `-c` | 显示系统调用统计信息 |
| `-v` | 显示inode、文件和其他内核表的统计信息 |
| `-p` | 以易读的格式显示设备名称 |
| `-x` | 显示指定进程的统计信息 |
| `-o 文件名` | 将数据保存到二进制文件 |
| `-f 文件名` | 从二进制文件读取数据 |
| `-s 时间` | 设置开始时间（HH:MM:SS格式） |
| `-e 时间` | 设置结束时间（HH:MM:SS格式） |
| `-P` | 显示指定CPU的统计信息 |
| `-i 间隔` | 设置数据采样间隔（秒） |
| `-1` | 显示1分钟平均负载 |
| `-5` | 显示5分钟平均负载 |
| `-15` | 显示15分钟平均负载 |

### 3.1 选项组合示例

`sar`命令的选项可以组合使用，以获取更全面的系统状态视图。以下是一些常用的选项组合示例：

- 显示CPU、内存和I/O统计信息：`sar -u -r -b 1 5`
- 显示磁盘和网络统计信息：`sar -d -n DEV 1 5`
- 以易读格式显示所有统计信息：`sar -A -p`
- 查看特定时间范围的历史数据：`sar -f /var/log/sa/saXX -s 10:00:00 -e 12:00:00`

## 4 常用示例

### 4.1 基本系统监控

显示系统整体性能数据，每秒采集一次，共采集5次：

```bash
sar 1 5
```

输出示例：

```
Linux 5.4.0-70-generic (hostname)  06/01/2023  _x86_64_    (4 CPU)

10:00:01 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle
10:00:02 AM     all      5.25      0.00      2.75      0.50      0.00     91.50
10:00:03 AM     all      4.75      0.00      2.50      0.25      0.00     92.50
10:00:04 AM     all      6.00      0.00      3.00      0.75      0.00     90.25
10:00:05 AM     all      4.50      0.00      2.25      0.00      0.00     93.25
10:00:06 AM     all      5.75      0.00      3.25      0.50      0.00     90.50
Average:        all      5.25      0.00      2.75      0.40      0.00     91.60
```

### 4.2 CPU使用率监控

显示CPU使用率的详细统计信息：

```bash
sar -u 1 5
```

输出示例：

```
Linux 5.4.0-70-generic (hostname)  06/01/2023  _x86_64_    (4 CPU)

10:00:01 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle
10:00:02 AM     all      5.25      0.00      2.75      0.50      0.00     91.50
10:00:03 AM     all      4.75      0.00      2.50      0.25      0.00     92.50
10:00:04 AM     all      6.00      0.00      3.00      0.75      0.00     90.25
10:00:05 AM     all      4.50      0.00      2.25      0.00      0.00     93.25
10:00:06 AM     all      5.75      0.00      3.25      0.50      0.00     90.50
Average:        all      5.25      0.00      2.75      0.40      0.00     91.60
```

### 4.3 内存使用监控

显示内存和交换空间的使用情况：

```bash
sar -r 1 5
```

输出示例：

```
Linux 5.4.0-70-generic (hostname)  06/01/2023  _x86_64_    (4 CPU)

10:00:01 AM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty
10:00:02 AM   1024000   3072000     75.00    128000    512000   1536000     37.50   1536000   1024000      4096
10:00:03 AM   1020000   3076000     75.10    128000    512000   1536000     37.50   1536000   1024000      4096
10:00:04 AM   1016000   3080000     75.20    128000    512000   1536000     37.50   1536000   1024000      4096
10:00:05 AM   1012000   3084000     75.30    128000    512000   1536000     37.50   1536000   1024000      4096
10:00:06 AM   1008000   3088000     75.40    128000    512000   1536000     37.50   1536000   1024000      4096
Average:      1016000   3080000     75.20    128000    512000   1536000     37.50   1536000   1024000      4096
```

### 4.4 I/O性能监控

显示I/O传输速率和性能统计信息：

```bash
sar -b 1 5
```

输出示例：

```
Linux 5.4.0-70-generic (hostname)  06/01/2023  _x86_64_    (4 CPU)

10:00:01 AM       tps      rtps      wtps   bread/s   bwrtn/s
10:00:02 AM      12.5       2.5      10.0     20.00   1280.00
10:00:03 AM      10.0       1.0       9.0      8.00   1152.00
10:00:04 AM      15.0       3.0      12.0     24.00   1536.00
10:00:05 AM       8.0       0.0       8.0      0.00   1024.00
10:00:06 AM      13.0       2.0      11.0     16.00   1408.00
Average:         11.7       1.7      10.0     13.60   1280.00
```

### 4.5 磁盘使用率监控

显示磁盘使用情况统计信息：

```bash
sar -d -p 1 5
```

输出示例：

```
Linux 5.4.0-70-generic (hostname)  06/01/2023  _x86_64_    (4 CPU)

10:00:01 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util
10:00:02 AM       sda      12.5      20.0    1280.0    104.00      0.03      2.40      1.20      1.50
10:00:03 AM       sda      10.0       8.0    1152.0    116.00      0.02      2.00      1.00      1.00
10:00:04 AM       sda      15.0      24.0    1536.0    104.00      0.04      2.67      1.33      2.00
10:00:05 AM       sda       8.0       0.0    1024.0    128.00      0.02      2.50      1.25      1.00
10:00:06 AM       sda      13.0      16.0    1408.0    109.54      0.03      2.31      1.15      1.50
Average:          sda      11.7      13.6    1280.0    111.11      0.03      2.38      1.19      1.40
```

### 4.6 网络流量监控

显示网络接口的流量统计信息：

```bash
sar -n DEV 1 5
```

输出示例：

```
Linux 5.4.0-70-generic (hostname)  06/01/2023  _x86_64_    (4 CPU)

10:00:01 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
10:00:02 AM      eth0     125.0     100.0      8.00      6.00       0.0       0.0       0.0      0.10
10:00:03 AM      eth0     130.0     105.0      8.50      6.30       0.0       0.0       0.0      0.11
10:00:04 AM      eth0     145.0     120.0      9.50      7.20       0.0       0.0       0.0      0.12
10:00:05 AM      eth0     120.0      95.0      7.80      5.70       0.0       0.0       0.0      0.09
10:00:06 AM      eth0     135.0     110.0      8.80      6.60       0.0       0.0       0.0      0.11
Average:         eth0     131.0     106.0      8.52      6.36       0.0       0.0       0.0      0.11
```

### 4.7 系统负载监控

显示系统负载和运行队列统计信息：

```bash
sar -q 1 5
```

输出示例：

```
Linux 5.4.0-70-generic (hostname)  06/01/2023  _x86_64_    (4 CPU)

10:00:01 AM   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked
10:00:02 AM         2       200      0.50      0.75      0.90         0
10:00:03 AM         2       200      0.50      0.75      0.90         0
10:00:04 AM         3       200      0.55      0.75      0.90         0
10:00:05 AM         2       200      0.55      0.75      0.90         0
10:00:06 AM         3       200      0.60      0.75      0.90         0
Average:            2       200      0.54      0.75      0.90         0
```

### 4.8 内存分页监控

显示内存分页活动统计信息：

```bash
sar -B 1 5
```

输出示例：

```
Linux 5.4.0-70-generic (hostname)  06/01/2023  _x86_64_    (4 CPU)

10:00:01 AM  pgpgin/s pgpgout/s   fault/s  majflt/s  pgfree/s pgscank/s pgscand/s pgsteal/s    %vmeff
10:00:02 AM       0.0     100.0      50.0       0.0      80.0       0.0       0.0       0.0      0.00
10:00:03 AM       0.0      90.0      45.0       0.0      75.0       0.0       0.0       0.0      0.00
10:00:04 AM       0.0     110.0      55.0       0.0      85.0       0.0       0.0       0.0      0.00
10:00:05 AM       0.0      80.0      40.0       0.0      70.0       0.0       0.0       0.0      0.00
10:00:06 AM       0.0     105.0      52.0       0.0      82.0       0.0       0.0       0.0      0.00
Average:          0.0      97.0      48.4       0.0      78.4       0.0       0.0       0.0      0.00
```

### 4.9 保存数据到文件

将系统活动数据保存到指定文件：

```bash
sar -o /tmp/sar_data 1 5
```

这个命令会将采集的数据保存到`/tmp/sar_data`文件中，供后续分析使用。

### 4.10 读取历史数据

从之前保存的文件中读取并显示系统活动数据：

```bash
sar -f /tmp/sar_data
```

也可以使用选项来过滤和格式化显示的内容：

```bash
sar -f /tmp/sar_data -u -r
```

## 5 高级用法

### 5.1 系统资源监控与告警系统

以下是一个基于`sar`命令的系统资源监控与告警系统，可以监控CPU、内存、磁盘和网络的性能指标，并在超过阈值时发送告警：

```bash
#!/bin/bash
# system_monitor.sh
# 基于sar命令的系统资源监控与告警系统

# 配置参数
MONITOR_INTERVAL=60        # 监控间隔（秒）
ALERT_EMAIL="admin@example.com"  # 告警邮件接收地址
LOG_FILE="/var/log/system_monitor.log"  # 日志文件路径

# 告警阈值配置
CPU_THRESHOLD=90           # CPU使用率阈值（%）
MEMORY_THRESHOLD=90        # 内存使用率阈值（%）
DISK_THRESHOLD=90          # 磁盘使用率阈值（%）
NETWORK_IN_THRESHOLD=1024  # 网络入站流量阈值（KB/s）
NETWORK_OUT_THRESHOLD=1024 # 网络出站流量阈值（KB/s）

# 确保必要的工具已安装
check_dependencies() {
    local missing_tools=()
    
    if ! command -v sar &> /dev/null; then
        missing_tools+=('sar')
    fi
    
    if ! command -v awk &> /dev/null; then
        missing_tools+=('awk')
    fi
    
    if ! command -v grep &> /dev/null; then
        missing_tools+=('grep')
    fi
    
    if ! command -v mail &> /dev/null && ! command -v sendmail &> /dev/null; then
        echo "警告: 未找到邮件发送工具，将只记录告警日志"
    fi
    
    if [ ${#missing_tools[@]} -gt 0 ]; then
        echo "错误: 缺少必要的工具: ${missing_tools[*]}"
        exit 1
    fi
}

# 记录日志
log_message() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    echo "[$timestamp] [$level] $message" | tee -a $LOG_FILE
}

# 发送告警邮件
send_alert() {
    local subject="$1"
    local body="$2"
    
    if command -v mail &> /dev/null; then
        echo -e "$body" | mail -s "$subject" $ALERT_EMAIL
        log_message "INFO" "告警邮件已发送至 $ALERT_EMAIL"
    elif command -v sendmail &> /dev/null; then
        echo -e "Subject: $subject\n\n$body" | sendmail $ALERT_EMAIL
        log_message "INFO" "告警邮件已发送至 $ALERT_EMAIL"
    else
        log_message "WARN" "无法发送邮件: 未找到mail或sendmail命令"
    fi
}

# 监控CPU使用率
monitor_cpu() {
    local cpu_usage=$(sar -u 1 1 | tail -n 1 | awk '{print 100 - $NF}')
    local cpu_usage_int=$(printf "%.0f" $cpu_usage)
    
    if [ $cpu_usage_int -gt $CPU_THRESHOLD ]; then
        local subject="系统告警: CPU使用率过高"
        local body="警告: CPU使用率超过阈值\n\n详细信息:\nCPU使用率: $cpu_usage_int%\n阈值: $CPU_THRESHOLD%\n\n主机名: $(hostname)\n时间: $(date '+%Y-%m-%d %H:%M:%S')\n\n可能原因: 系统负载过高、进程占用过多CPU资源\n建议: 检查系统进程，必要时增加CPU资源"
        
        log_message "WARN" "CPU使用率过高: $cpu_usage_int% (阈值: $CPU_THRESHOLD%)"
        send_alert "$subject" "$body"
    else
        log_message "DEBUG" "CPU使用率正常: $cpu_usage_int% (阈值: $CPU_THRESHOLD%)"
    fi
}

# 监控内存使用率
monitor_memory() {
    local mem_used=$(sar -r 1 1 | tail -n 1 | awk '{print $3}')
    local mem_total=$(($(sar -r 1 1 | tail -n 1 | awk '{print $2}') + $mem_used))
    local mem_usage=$(echo "scale=2; $mem_used / $mem_total * 100" | bc)
    local mem_usage_int=$(printf "%.0f" $mem_usage)
    
    if [ $mem_usage_int -gt $MEMORY_THRESHOLD ]; then
        local subject="系统告警: 内存使用率过高"
        local body="警告: 内存使用率超过阈值\n\n详细信息:\n内存使用率: $mem_usage_int%\n阈值: $MEMORY_THRESHOLD%\n已用内存: $(printf "%.2f" $(echo "$mem_used / 1024 / 1024" | bc)) GB\n总内存: $(printf "%.2f" $(echo "$mem_total / 1024 / 1024" | bc)) GB\n\n主机名: $(hostname)\n时间: $(date '+%Y-%m-%d %H:%M:%S')\n\n可能原因: 内存泄漏、应用程序内存需求增加\n建议: 检查内存使用进程，考虑增加物理内存或启用交换空间"
        
        log_message "WARN" "内存使用率过高: $mem_usage_int% (阈值: $MEMORY_THRESHOLD%)"
        send_alert "$subject" "$body"
    else
        log_message "DEBUG" "内存使用率正常: $mem_usage_int% (阈值: $MEMORY_THRESHOLD%)"
    fi
}

# 监控磁盘性能
monitor_disk() {
    # 获取所有磁盘的使用率
    local disk_output=$(sar -d -p 1 1 | tail -n +3)
    
    while read -r line; do
        local disk_name=$(echo $line | awk '{print $2}')
        local disk_util=$(echo $line | awk '{print $NF}')
        local disk_util_int=$(printf "%.0f" $disk_util)
        
        if [ $disk_util_int -gt $DISK_THRESHOLD ]; then
            local subject="系统告警: 磁盘使用率过高"
            local body="警告: 磁盘使用率超过阈值\n\n详细信息:\n磁盘: $disk_name\n使用率: $disk_util_int%\n阈值: $DISK_THRESHOLD%\n\n主机名: $(hostname)\n时间: $(date '+%Y-%m-%d %H:%M:%S')\n\n可能原因: 磁盘I/O负载过高、磁盘性能下降\n建议: 检查磁盘I/O情况，考虑优化查询或升级磁盘系统"
            
            log_message "WARN" "磁盘 $disk_name 使用率过高: $disk_util_int% (阈值: $DISK_THRESHOLD%)"
            send_alert "$subject" "$body"
        else
            log_message "DEBUG" "磁盘 $disk_name 使用率正常: $disk_util_int% (阈值: $DISK_THRESHOLD%)"
        fi
    done <<< "$disk_output"
}

# 监控网络流量
monitor_network() {
    # 获取所有网络接口的流量
    local network_output=$(sar -n DEV 1 1 | tail -n +3 | grep -v lo)
    
    while read -r line; do
        local iface=$(echo $line | awk '{print $2}')
        local rx_kb=$(echo $line | awk '{print $5}')
        local tx_kb=$(echo $line | awk '{print $6}')
        
        # 检查入站流量
        if (( $(echo "$rx_kb > $NETWORK_IN_THRESHOLD" | bc -l) )); then
            local subject="系统告警: 网络入站流量过高"
            local body="警告: 网络入站流量超过阈值\n\n详细信息:\n接口: $iface\n入站流量: $(printf "%.2f" $rx_kb) KB/s\n阈值: $NETWORK_IN_THRESHOLD KB/s\n\n主机名: $(hostname)\n时间: $(date '+%Y-%m-%d %H:%M:%S')\n\n可能原因: DDoS攻击、异常流量、大量下载\n建议: 检查网络连接，必要时使用防火墙限制流量"
            
            log_message "WARN" "接口 $iface 入站流量过高: $(printf "%.2f" $rx_kb) KB/s (阈值: $NETWORK_IN_THRESHOLD KB/s)"
            send_alert "$subject" "$body"
        else
            log_message "DEBUG" "接口 $iface 入站流量正常: $(printf "%.2f" $rx_kb) KB/s (阈值: $NETWORK_IN_THRESHOLD KB/s)"
        fi
        
        # 检查出站流量
        if (( $(echo "$tx_kb > $NETWORK_OUT_THRESHOLD" | bc -l) )); then
            local subject="系统告警: 网络出站流量过高"
            local body="警告: 网络出站流量超过阈值\n\n详细信息:\n接口: $iface\n出站流量: $(printf "%.2f" $tx_kb) KB/s\n阈值: $NETWORK_OUT_THRESHOLD KB/s\n\n主机名: $(hostname)\n时间: $(date '+%Y-%m-%d %H:%M:%S')\n\n可能原因: 数据泄露、异常上传、恶意软件活动\n建议: 检查网络连接和进程，必要时使用防火墙限制流量"
            
            log_message "WARN" "接口 $iface 出站流量过高: $(printf "%.2f" $tx_kb) KB/s (阈值: $NETWORK_OUT_THRESHOLD KB/s)"
            send_alert "$subject" "$body"
        else
            log_message "DEBUG" "接口 $iface 出站流量正常: $(printf "%.2f" $tx_kb) KB/s (阈值: $NETWORK_OUT_THRESHOLD KB/s)"
        fi
    done <<< "$network_output"
}

# 生成每日性能报告
generate_daily_report() {
    local report_file="/var/log/system_performance_report_$(date +%Y%m%d).txt"
    local yesterday=$(date --date="yesterday" +%Y%m%d)
    local sa_file="/var/log/sa/sa${yesterday:6:2}"
    
    # 检查是否存在昨天的sar数据文件
    if [ ! -f $sa_file ]; then
        log_message "WARN" "未找到昨天的sar数据文件: $sa_file"
        return
    fi
    
    echo "==================== 系统性能每日报告 ====================" > $report_file
    echo "报告生成时间: $(date '+%Y-%m-%d %H:%M:%S')" >> $report_file
    echo "报告日期: $(date --date="yesterday" '+%Y-%m-%d')" >> $report_file
    echo "主机名: $(hostname)" >> $report_file
    echo "=====================================================" >> $report_file
    echo "" >> $report_file
    
    # CPU使用率统计
    echo "--- CPU使用率统计 ---" >> $report_file
    sar -f $sa_file -u | tail -n +3 | awk 'NR==1 || $NF < min || $NF > max {if(NR>1) {min=($NF<min)?$NF:min; max=($NF>max)?$NF:max}; sum+=$NF; count++} END {print "平均CPU使用率: " 100 - sum/count "%"; print "最低CPU使用率: " 100 - max "%"; print "最高CPU使用率: " 100 - min "%"}' >> $report_file
    echo "" >> $report_file
    
    # 内存使用统计
    echo "--- 内存使用统计 ---" >> $report_file
    sar -f $sa_file -r | tail -n +3 | awk 'NR==1 {mem_total=$2+$3} NR>1 {sum+=$3; count++} END {print "平均内存使用率: " sum/count/mem_total*100 "%"}' >> $report_file
    echo "" >> $report_file
    
    # 磁盘I/O统计
    echo "--- 磁盘I/O统计 ---" >> $report_file
    sar -f $sa_file -b | tail -n +3 | awk 'NR>1 {rtps_sum+=$3; wtps_sum+=$4; bread_sum+=$5; bwrtn_sum+=$6; count++} END {print "平均每秒读取次数: " rtps_sum/count; print "平均每秒写入次数: " wtps_sum/count; print "平均每秒读取数据量: " bread_sum/count " KB/s"; print "平均每秒写入数据量: " bwrtn_sum/count " KB/s"}' >> $report_file
    echo "" >> $report_file
    
    # 网络流量统计
    echo "--- 网络流量统计 ---" >> $report_file
    sar -f $sa_file -n DEV | grep -v lo | tail -n +3 | awk 'NR>1 {rx_sum+=$5; tx_sum+=$6; count++} END {print "平均每秒接收数据量: " rx_sum/count " KB/s"; print "平均每秒发送数据量: " tx_sum/count " KB/s"}' >> $report_file
    echo "" >> $report_file
    
    log_message "INFO" "每日性能报告已生成: $report_file"
    
    # 发送报告邮件
    if [ -n "$ALERT_EMAIL" ]; then
        cat $report_file | mail -s "系统性能每日报告 - $(date --date="yesterday" '+%Y-%m-%d')" $ALERT_EMAIL
        log_message "INFO" "每日性能报告已发送至 $ALERT_EMAIL"
    fi
}

# 显示帮助信息
show_help() {
    echo "系统资源监控与告警系统"
    echo "用法: $0 [选项]"
    echo ""
    echo "选项:"
    echo "  -h, --help            显示帮助信息"
    echo "  -i, --interval <n>    设置监控间隔(秒) (默认: $MONITOR_INTERVAL)"
    echo "  -e, --email <email>   设置告警邮件接收地址 (默认: $ALERT_EMAIL)"
    echo "  -l, --log <file>      设置日志文件路径 (默认: $LOG_FILE)"
    echo "  --cpu-threshold <n>   设置CPU使用率告警阈值(%) (默认: $CPU_THRESHOLD)"
    echo "  --mem-threshold <n>   设置内存使用率告警阈值(%) (默认: $MEMORY_THRESHOLD)"
    echo "  --disk-threshold <n>  设置磁盘使用率告警阈值(%) (默认: $DISK_THRESHOLD)"
    echo "  --net-in-threshold <n> 设置网络入站流量告警阈值(KB/s) (默认: $NETWORK_IN_THRESHOLD)"
    echo "  --net-out-threshold <n> 设置网络出站流量告警阈值(KB/s) (默认: $NETWORK_OUT_THRESHOLD)"
    echo "  --generate-report     生成昨天的性能报告并退出"
    echo ""
    echo "示例:"
    echo "  # 以默认配置启动监控"
    echo "  $0"
    echo ""
    echo "  # 自定义监控间隔和告警阈值"
    echo "  $0 -i 30 --cpu-threshold 85 --mem-threshold 85"
    echo ""
    echo "  # 配置告警邮件"
    echo "  $0 -e admin@example.com"
    echo ""
    echo "  # 生成昨天的性能报告"
    echo "  $0 --generate-report"
    echo ""
}

# 主函数
main() {
    # 解析命令行参数
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -i|--interval)
                MONITOR_INTERVAL=$2
                shift 2
                ;;
            -e|--email)
                ALERT_EMAIL=$2
                shift 2
                ;;
            -l|--log)
                LOG_FILE=$2
                shift 2
                ;;
            --cpu-threshold)
                CPU_THRESHOLD=$2
                shift 2
                ;;
            --mem-threshold)
                MEMORY_THRESHOLD=$2
                shift 2
                ;;
            --disk-threshold)
                DISK_THRESHOLD=$2
                shift 2
                ;;
            --net-in-threshold)
                NETWORK_IN_THRESHOLD=$2
                shift 2
                ;;
            --net-out-threshold)
                NETWORK_OUT_THRESHOLD=$2
                shift 2
                ;;
            --generate-report)
                generate_daily_report
                exit 0
                ;;
            *)
                echo "未知选项: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # 检查依赖工具
    check_dependencies
    
    # 确保日志目录存在
    mkdir -p $(dirname $LOG_FILE)
    
    # 记录启动信息
    log_message "INFO" "系统资源监控与告警系统已启动"
    log_message "INFO" "监控间隔: $MONITOR_INTERVAL 秒"
    log_message "INFO" "告警阈值设置:"
    log_message "INFO" "  CPU使用率: $CPU_THRESHOLD%"
    log_message "INFO" "  内存使用率: $MEMORY_THRESHOLD%"
    log_message "INFO" "  磁盘使用率: $DISK_THRESHOLD%"
    log_message "INFO" "  网络入站流量: $NETWORK_IN_THRESHOLD KB/s"
    log_message "INFO" "  网络出站流量: $NETWORK_OUT_THRESHOLD KB/s"
    
    if [ -n "$ALERT_EMAIL" ]; then
        log_message "INFO" "告警邮件将发送至: $ALERT_EMAIL"
    else
        log_message "INFO" "未配置告警邮件地址，将只记录告警日志"
    fi
    
    # 设置退出信号处理
    trap "log_message 'INFO' '系统资源监控与告警系统已停止'; exit 0" SIGINT SIGTERM
    
    # 初始化上次报告时间（用于每日报告）
    local last_report_day=$(date +%d)
    
    # 主监控循环
    while true; do
        # 执行各项监控
        monitor_cpu
        monitor_memory
        monitor_disk
        monitor_network
        
        # 检查是否需要生成每日报告（日期变更时）
        local current_day=$(date +%d)
        if [ $current_day -ne $last_report_day ]; then
            generate_daily_report
            last_report_day=$current_day
        fi
        
        # 等待下一次监控
        sleep $MONITOR_INTERVAL
    done
}

# 执行主函数
main "$@"

### 5.2 性能数据分析与可视化工具

以下是一个基于`sar`命令的性能数据分析与可视化工具，可以将历史性能数据转换为直观的图表展示：

```bash
#!/bin/bash
# perf_analyzer.sh
# 性能数据分析与可视化工具

# 配置参数
SA_DIR="/var/log/sa"          # sar数据文件目录
OUTPUT_DIR="/tmp/perf_analysis" # 分析结果输出目录
CHART_TYPE="ascii"           # 图表类型：ascii, csv
ANALYSIS_DAYS=7              # 分析天数

# 确保必要的工具已安装
check_dependencies() {
    local missing_tools=()
    
    if ! command -v sar &> /dev/null; then
        missing_tools+=('sar')
    fi
    
    if ! command -v awk &> /dev/null; then
        missing_tools+=('awk')
    fi
    
    if ! command -v grep &> /dev/null; then
        missing_tools+=('grep')
    fi
    
    if ! command -v sed &> /dev/null; then
        missing_tools+=('sed')
    fi
    
    if [ ${#missing_tools[@]} -gt 0 ]; then
        echo "错误: 缺少必要的工具: ${missing_tools[*]}"
        exit 1
    fi
}

# 创建输出目录
prepare_output_dir() {
    mkdir -p $OUTPUT_DIR
    echo "分析结果将保存至: $OUTPUT_DIR"
}

# 收集CPU使用率数据
collect_cpu_data() {
    local output_file="$OUTPUT_DIR/cpu_usage.csv"
    echo "收集CPU使用率数据..."
    
    # 添加表头
    echo "date,time,user,nice,system,iowait,steal,idle" > $output_file
    
    # 收集最近$ANALYSIS_DAYS天的数据
    for ((i=0; i<$ANALYSIS_DAYS; i++)); do
        local target_date=$(date --date="-$i day" +%Y%m%d)
        local sa_file="$SA_DIR/sa${target_date:6:2}"
        
        if [ ! -f $sa_file ]; then
            echo "警告: 未找到 $target_date 的sar数据文件: $sa_file"
            continue
        fi
        
        echo "处理 $target_date 的数据..."
        
        # 提取CPU使用率数据
        local cpu_data=$(sar -f $sa_file -u | tail -n +3)
        
        # 格式化数据并保存
        while read -r line; do
            local time=$(echo $line | awk '{print $1}')
            local user=$(echo $line | awk '{print $3}')
            local nice=$(echo $line | awk '{print $4}')
            local system=$(echo $line | awk '{print $5}')
            local iowait=$(echo $line | awk '{print $6}')
            local steal=$(echo $line | awk '{print $7}')
            local idle=$(echo $line | awk '{print $8}')
            
            # 跳过平均值行
            if [ "$time" != "Average:" ]; then
                echo "$target_date,$time,$user,$nice,$system,$iowait,$steal,$idle" >> $output_file
            fi
        done <<< "$cpu_data"
    done
    
    echo "CPU使用率数据已保存至: $output_file"
}

# 收集内存使用数据
collect_memory_data() {
    local output_file="$OUTPUT_DIR/memory_usage.csv"
    echo "收集内存使用数据..."
    
    # 添加表头
    echo "date,time,kbmemfree,kbmemused,memused,kbbuffers,kbcached,kbcommit,commit,kbactive,kbinact,kbdirty" > $output_file
    
    # 收集最近$ANALYSIS_DAYS天的数据
    for ((i=0; i<$ANALYSIS_DAYS; i++)); do
        local target_date=$(date --date="-$i day" +%Y%m%d)
        local sa_file="$SA_DIR/sa${target_date:6:2}"
        
        if [ ! -f $sa_file ]; then
            echo "警告: 未找到 $target_date 的sar数据文件: $sa_file"
            continue
        fi
        
        # 提取内存使用数据
        local mem_data=$(sar -f $sa_file -r | tail -n +3)
        
        # 格式化数据并保存
        while read -r line; do
            local time=$(echo $line | awk '{print $1}')
            local kbmemfree=$(echo $line | awk '{print $2}')
            local kbmemused=$(echo $line | awk '{print $3}')
            local memused=$(echo $line | awk '{print $4}')
            local kbbuffers=$(echo $line | awk '{print $5}')
            local kbcached=$(echo $line | awk '{print $6}')
            local kbcommit=$(echo $line | awk '{print $7}')
            local commit=$(echo $line | awk '{print $8}')
            local kbactive=$(echo $line | awk '{print $9}')
            local kbinact=$(echo $line | awk '{print $10}')
            local kbdirty=$(echo $line | awk '{print $11}')
            
            # 跳过平均值行
            if [ "$time" != "Average:" ]; then
                echo "$target_date,$time,$kbmemfree,$kbmemused,$memused,$kbbuffers,$kbcached,$kbcommit,$commit,$kbactive,$kbinact,$kbdirty" >> $output_file
            fi
        done <<< "$mem_data"
    done
    
    echo "内存使用数据已保存至: $output_file"
}

# 收集网络流量数据
collect_network_data() {
    local output_file="$OUTPUT_DIR/network_traffic.csv"
    echo "收集网络流量数据..."
    
    # 添加表头
    echo "date,time,iface,rxpck,txpck,rxkB,txkB,rxcmp,txcmp,rxmcst,ifutil" > $output_file
    
    # 收集最近$ANALYSIS_DAYS天的数据
    for ((i=0; i<$ANALYSIS_DAYS; i++)); do
        local target_date=$(date --date="-$i day" +%Y%m%d)
        local sa_file="$SA_DIR/sa${target_date:6:2}"
        
        if [ ! -f $sa_file ]; then
            echo "警告: 未找到 $target_date 的sar数据文件: $sa_file"
            continue
        fi
        
        # 提取网络流量数据（排除回环接口）
        local network_data=$(sar -f $sa_file -n DEV | grep -v lo | tail -n +3)
        
        # 格式化数据并保存
        while read -r line; do
            local time=$(echo $line | awk '{print $1}')
            local iface=$(echo $line | awk '{print $2}')
            local rxpck=$(echo $line | awk '{print $3}')
            local txpck=$(echo $line | awk '{print $4}')
            local rxkB=$(echo $line | awk '{print $5}')
            local txkB=$(echo $line | awk '{print $6}')
            local rxcmp=$(echo $line | awk '{print $7}')
            local txcmp=$(echo $line | awk '{print $8}')
            local rxmcst=$(echo $line | awk '{print $9}')
            local ifutil=$(echo $line | awk '{print $10}')
            
            # 跳过平均值行
            if [ "$time" != "Average:" ]; then
                echo "$target_date,$time,$iface,$rxpck,$txpck,$rxkB,$txkB,$rxcmp,$txcmp,$rxmcst,$ifutil" >> $output_file
            fi
        done <<< "$network_data"
    done
    
    echo "网络流量数据已保存至: $output_file"
}

# 生成ASCII图表
create_ascii_chart() {
    local input_file="$1"
    local output_file="$2"
    local title="$3"
    local data_column="$4"
    local y_label="$5"
    
    echo "生成ASCII图表: $title"
    
    # 获取数据范围
    local min_val=$(awk -F',' 'NR>1 {if(NR==2 || $'$data_column' < min) min=$'$data_column'} END {print min}' $input_file)
    local max_val=$(awk -F',' 'NR>1 {if($'$data_column' > max) max=$'$data_column'} END {print max}' $input_file)
    
    # 计算缩放因子
    local chart_height=20
    local scale=$(echo "scale=2; $chart_height / ($max_val - $min_val + 1)" | bc)
    
    # 生成图表
    echo "$title" > $output_file
    echo "Y轴: $y_label" >> $output_file
    echo "最小值: $min_val, 最大值: $max_val" >> $output_file
    echo "" >> $output_file
    
    # 绘制Y轴
    for ((i=chart_height; i>=0; i--)); do
        local y_val=$(echo "scale=2; $max_val - ($i * ($max_val - $min_val) / $chart_height)" | bc)
        printf "%8.2f |" $y_val >> $output_file
        
        # 每5个数据点绘制一个柱状图
        local counter=0
        while IFS=, read -r date time rest; do
            if [ $counter -eq 0 ]; then
                local value=$(echo $rest | cut -d',' -f$(($data_column - 2)))
                local bar_height=$(echo "scale=2; ($value - $min_val) * $scale" | bc)
                local bar_height_int=$(printf "%.0f" $bar_height)
                
                # 绘制柱状图
                for ((j=0; j<$bar_height_int; j++)); do
                    printf "*" >> $output_file
                done
            fi
            counter=$(( (counter + 1) % 5 ))
        done < <(tail -n +2 $input_file)
        
        echo "" >> $output_file
    done
    
    # 绘制X轴
    echo -n "          +" >> $output_file
    local data_points=$(wc -l $input_file | awk '{print $1 - 1}')
    local x_ticks=$(echo "$data_points / 5" | bc)
    for ((i=0; i<$x_ticks; i++)); do
        printf "--" >> $output_file
    done
    echo "" >> $output_file
    echo "          X轴: 时间（每5个数据点显示一个）" >> $output_file
    
    echo "ASCII图表已保存至: $output_file"
}

# 生成性能分析报告
generate_report() {
    local report_file="$OUTPUT_DIR/performance_analysis_report_$(date +%Y%m%d_%H%M%S).txt"
    
    echo "生成性能分析报告..."
    
    echo "==================== 系统性能分析报告 ====================" > $report_file
    echo "报告生成时间: $(date '+%Y-%m-%d %H:%M:%S')" >> $report_file
    echo "分析时间范围: $(date --date="-$ANALYSIS_DAYS day" '+%Y-%m-%d') 至 $(date '+%Y-%m-%d')" >> $report_file
    echo "主机名: $(hostname)" >> $report_file
    echo "=====================================================" >> $report_file
    echo "" >> $report_file
    
    # CPU使用率分析
    echo "--- CPU使用率分析 ---" >> $report_file
    if [ -f "$OUTPUT_DIR/cpu_usage.csv" ]; then
        local avg_user=$(awk -F',' 'NR>1 {sum+=$3} END {print sum/(NR-1)}' $OUTPUT_DIR/cpu_usage.csv)
        local avg_system=$(awk -F',' 'NR>1 {sum+=$5} END {print sum/(NR-1)}' $OUTPUT_DIR/cpu_usage.csv)
        local avg_iowait=$(awk -F',' 'NR>1 {sum+=$6} END {print sum/(NR-1)}' $OUTPUT_DIR/cpu_usage.csv)
        local avg_idle=$(awk -F',' 'NR>1 {sum+=$8} END {print sum/(NR-1)}' $OUTPUT_DIR/cpu_usage.csv)
        
        echo "平均用户CPU使用率: $(printf "%.2f" $avg_user)%" >> $report_file
        echo "平均系统CPU使用率: $(printf "%.2f" $avg_system)%" >> $report_file
        echo "平均I/O等待CPU使用率: $(printf "%.2f" $avg_iowait)%" >> $report_file
        echo "平均空闲CPU使用率: $(printf "%.2f" $avg_idle)%" >> $report_file
        echo "" >> $report_file
    else
        echo "警告: 未找到CPU使用率数据文件" >> $report_file
        echo "" >> $report_file
    fi
    
    # 内存使用分析
    echo "--- 内存使用分析 ---" >> $report_file
    if [ -f "$OUTPUT_DIR/memory_usage.csv" ]; then
        local avg_memused=$(awk -F',' 'NR>1 {sum+=$4} END {print sum/(NR-1)}' $OUTPUT_DIR/memory_usage.csv)
        
        echo "平均内存使用率: $(printf "%.2f" $avg_memused)%" >> $report_file
        echo "" >> $report_file
    else
        echo "警告: 未找到内存使用数据文件" >> $report_file
        echo "" >> $report_file
    fi
    
    # 网络流量分析
    echo "--- 网络流量分析 ---" >> $report_file
    if [ -f "$OUTPUT_DIR/network_traffic.csv" ]; then
        local avg_rx=$(awk -F',' 'NR>1 {sum+=$7} END {print sum/(NR-1)}' $OUTPUT_DIR/network_traffic.csv)
        local avg_tx=$(awk -F',' 'NR>1 {sum+=$8} END {print sum/(NR-1)}' $OUTPUT_DIR/network_traffic.csv)
        
        echo "平均每秒接收数据量: $(printf "%.2f" $avg_rx) KB/s" >> $report_file
        echo "平均每秒发送数据量: $(printf "%.2f" $avg_tx) KB/s" >> $report_file
        echo "" >> $report_file
    else
        echo "警告: 未找到网络流量数据文件" >> $report_file
        echo "" >> $report_file
    fi
    
    # 性能建议
    echo "--- 性能建议 ---" >> $report_file
    if [ -f "$OUTPUT_DIR/cpu_usage.csv" ] && (( $(echo "$avg_idle < 20" | bc -l) )); then
        echo "1. CPU使用率较高（平均空闲率 < 20%），建议检查系统负载和进程使用情况，考虑优化或升级CPU资源。" >> $report_file
    fi
    
    if [ -f "$OUTPUT_DIR/memory_usage.csv" ] && (( $(echo "$avg_memused > 80" | bc -l) )); then
        echo "2. 内存使用率较高（平均使用率 > 80%），建议检查内存使用进程，考虑增加物理内存或启用交换空间。" >> $report_file
    fi
    
    if [ -f "$OUTPUT_DIR/cpu_usage.csv" ] && (( $(echo "$avg_iowait > 10" | bc -l) )); then
        echo "3. I/O等待时间较长（平均 > 10%），建议检查磁盘性能和I/O操作，考虑优化查询或升级存储系统。" >> $report_file
    fi
    
    echo "" >> $report_file
    echo "详细数据和图表请查看 $OUTPUT_DIR 目录下的文件" >> $report_file
    
    echo "性能分析报告已保存至: $report_file"
}

# 显示帮助信息
show_help() {
    echo "性能数据分析与可视化工具"
    echo "用法: $0 [选项]"
    echo ""
    echo "选项:"
    echo "  -h, --help            显示帮助信息"
    echo "  -d, --days <n>        设置分析天数 (默认: $ANALYSIS_DAYS)"
    echo "  -s, --sa-dir <dir>    设置sar数据文件目录 (默认: $SA_DIR)"
    echo "  -o, --output <dir>    设置分析结果输出目录 (默认: $OUTPUT_DIR)"
    echo "  -c, --chart <type>    设置图表类型 (ascii, csv) (默认: $CHART_TYPE)"
    echo "  --cpu                 仅分析CPU使用率数据"
    echo "  --memory              仅分析内存使用数据"
    echo "  --network             仅分析网络流量数据"
    echo "  --all                 分析所有数据类型（默认）"
    echo ""
    echo "示例:"
    echo "  # 分析最近7天的所有性能数据"
    echo "  $0"
    echo ""
    echo "  # 分析最近3天的CPU使用率数据"
    echo "  $0 -d 3 --cpu"
    echo ""
    echo "  # 自定义数据目录和输出目录"
    echo "  $0 -s /path/to/sa -o /path/to/output"
    echo ""
}

# 主函数
main() {
    # 默认分析所有数据类型
    local analyze_cpu=true
    local analyze_memory=true
    local analyze_network=true
    
    # 解析命令行参数
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -d|--days)
                ANALYSIS_DAYS=$2
                shift 2
                ;;
            -s|--sa-dir)
                SA_DIR=$2
                shift 2
                ;;
            -o|--output)
                OUTPUT_DIR=$2
                shift 2
                ;;
            -c|--chart)
                CHART_TYPE=$2
                shift 2
                ;;
            --cpu)
                analyze_cpu=true
                analyze_memory=false
                analyze_network=false
                shift 1
                ;;
            --memory)
                analyze_cpu=false
                analyze_memory=true
                analyze_network=false
                shift 1
                ;;
            --network)
                analyze_cpu=false
                analyze_memory=false
                analyze_network=true
                shift 1
                ;;
            --all)
                analyze_cpu=true
                analyze_memory=true
                analyze_network=true
                shift 1
                ;;
            *)
                echo "未知选项: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # 检查依赖工具
    check_dependencies
    
    # 创建输出目录
    prepare_output_dir
    
    # 收集性能数据
    if [ "$analyze_cpu" = true ]; then
        collect_cpu_data
        
        # 生成CPU使用率图表
        if [ "$CHART_TYPE" = "ascii" ] && [ -f "$OUTPUT_DIR/cpu_usage.csv" ]; then
            create_ascii_chart "$OUTPUT_DIR/cpu_usage.csv" "$OUTPUT_DIR/cpu_usage_chart.txt" "CPU使用率趋势图" 3 "用户CPU使用率(%)"
        fi
    fi
    
    if [ "$analyze_memory" = true ]; then
        collect_memory_data
        
        # 生成内存使用率图表
        if [ "$CHART_TYPE" = "ascii" ] && [ -f "$OUTPUT_DIR/memory_usage.csv" ]; then
            create_ascii_chart "$OUTPUT_DIR/memory_usage.csv" "$OUTPUT_DIR/memory_usage_chart.txt" "内存使用率趋势图" 4 "内存使用率(%)"
        fi
    fi
    
    if [ "$analyze_network" = true ]; then
        collect_network_data
        
        # 生成网络流量图表（仅以第一个网络接口为例）
        if [ "$CHART_TYPE" = "ascii" ] && [ -f "$OUTPUT_DIR/network_traffic.csv" ]; then
            local first_interface=$(awk -F',' 'NR>1 {print $3; exit}' $OUTPUT_DIR/network_traffic.csv)
            grep "$first_interface" $OUTPUT_DIR/network_traffic.csv > $OUTPUT_DIR/network_traffic_${first_interface}.csv
            
            create_ascii_chart "$OUTPUT_DIR/network_traffic_${first_interface}.csv" "$OUTPUT_DIR/network_rx_chart.txt" "网络入站流量趋势图（接口: $first_interface）" 7 "入站流量(KB/s)"
            create_ascii_chart "$OUTPUT_DIR/network_traffic_${first_interface}.csv" "$OUTPUT_DIR/network_tx_chart.txt" "网络出站流量趋势图（接口: $first_interface）" 8 "出站流量(KB/s)"
        fi
    fi
    
    # 生成性能分析报告
    generate_report
}

# 执行主函数
main "$@"

### 5.3 系统性能基准测试工具

以下是一个基于`sar`命令的系统性能基准测试工具，可以对系统进行全面的性能测试并生成基准报告：

```bash
#!/bin/bash
# system_benchmark.sh
# 系统性能基准测试工具

# 配置参数
BENCHMARK_DURATION=300      # 基准测试持续时间（秒）
WORKLOAD_TYPE="mixed"       # 工作负载类型：cpu, memory, io, mixed
OUTPUT_FILE="system_benchmark_$(date +%Y%m%d_%H%M%S).log"  # 测试结果文件
SA_SAMPLE_INTERVAL=5        # sar采样间隔（秒）

# 确保必要的工具已安装
check_dependencies() {
    local missing_tools=()
    
    if ! command -v sar &> /dev/null; then
        missing_tools+=('sar')
    fi
    
    if ! command -v awk &> /dev/null; then
        missing_tools+=('awk')
    fi
    
    if ! command -v stress &> /dev/null; then
        echo "警告: 未找到stress工具，某些性能测试可能无法执行"
    fi
    
    if ! command -v dd &> /dev/null; then
        missing_tools+=('dd')
    fi
    
    if [ ${#missing_tools[@]} -gt 0 ]; then
        echo "错误: 缺少必要的工具: ${missing_tools[*]}"
        exit 1
    fi
}

# 启动sar数据收集
start_sar_collection() {
    local sar_output="/tmp/sar_benchmark_data.$$"
    echo "开始sar数据收集，采样间隔: $SA_SAMPLE_INTERVAL 秒"
    
    # 启动sar后台收集数据
    sar -o $sar_output $SA_SAMPLE_INTERVAL $(($BENCHMARK_DURATION / $SA_SAMPLE_INTERVAL + 1)) > /dev/null 2>&1 &
    
    echo $! > "/tmp/sar_benchmark_pid.$$"
    echo "sar进程ID: $(cat /tmp/sar_benchmark_pid.$$)"
    echo "sar数据将保存至: $sar_output"
    
    # 返回sar输出文件路径
    echo $sar_output
}

# 停止sar数据收集
stop_sar_collection() {
    local sar_pid_file="/tmp/sar_benchmark_pid.$$"
    
    if [ -f $sar_pid_file ]; then
        local sar_pid=$(cat $sar_pid_file)
        echo "停止sar数据收集..."
        kill $sar_pid
        rm -f $sar_pid_file
    fi
}

# 运行CPU压力测试
run_cpu_benchmark() {
    echo "开始CPU压力测试..."
    
    if command -v stress &> /dev/null; then
        # 获取CPU核心数
        local cpu_cores=$(nproc)
        echo "系统CPU核心数: $cpu_cores"
        echo "运行CPU压力测试 $BENCHMARK_DURATION 秒，使用 $cpu_cores 个核心..."
        
        # 启动CPU压力测试
        stress --cpu $cpu_cores --timeout $BENCHMARK_DURATION > /dev/null 2>&1 &
    else
        echo "警告: stress工具不可用，将使用替代方法进行CPU测试"
        
        # 使用替代方法进行CPU测试
        local cpu_cores=$(nproc)
        for ((i=0; i<$cpu_cores; i++)); do
            (while true; do :; done) &
            echo $! >> /tmp/cpu_benchmark_pids.$$
        done
        
        sleep $BENCHMARK_DURATION
        
        # 停止替代CPU测试
        if [ -f /tmp/cpu_benchmark_pids.$$ ]; then
            while read -r pid; do
                kill $pid
            done < /tmp/cpu_benchmark_pids.$$
            rm -f /tmp/cpu_benchmark_pids.$$
        fi
    fi
}

# 运行内存压力测试
run_memory_benchmark() {
    echo "开始内存压力测试..."
    
    if command -v stress &> /dev/null; then
        # 获取可用内存（MB）
        local available_memory=$(free -m | awk '/Mem:/ {print $7}')
        # 使用80%的可用内存进行测试
        local test_memory=$((available_memory * 80 / 100))
        
        echo "可用内存: $available_memory MB"
        echo "测试内存: $test_memory MB"
        echo "运行内存压力测试 $BENCHMARK_DURATION 秒..."
        
        # 启动内存压力测试
        stress --vm 1 --vm-bytes ${test_memory}M --timeout $BENCHMARK_DURATION > /dev/null 2>&1 &
    else
        echo "警告: stress工具不可用，将使用dd命令进行简单的内存测试"
        
        # 使用dd命令进行简单的内存测试
        echo "使用dd命令测试内存读写性能..."
        
        # 测试内存写入速度
        local write_speed=$(dd if=/dev/zero of=/dev/shm/benchmark bs=1M count=100 2>&1 | grep copied | awk '{print $8 " " $9}')
        
        # 测试内存读取速度
        local read_speed=$(dd if=/dev/shm/benchmark of=/dev/null bs=1M count=100 2>&1 | grep copied | awk '{print $8 " " $9}')
        
        # 清理测试文件
        rm -f /dev/shm/benchmark
        
        echo "内存写入速度: $write_speed"
        echo "内存读取速度: $read_speed"
        
        # 由于无法进行长时间的内存压力测试，这里等待剩余时间
        sleep $BENCHMARK_DURATION
    fi
}

# 运行I/O压力测试
run_io_benchmark() {
    echo "开始I/O压力测试..."
    
    if command -v stress &> /dev/null; then
        echo "运行I/O压力测试 $BENCHMARK_DURATION 秒..."
        
        # 启动I/O压力测试
        stress --io 4 --timeout $BENCHMARK_DURATION > /dev/null 2>&1 &
    else
        echo "警告: stress工具不可用，将使用dd命令进行简单的I/O测试"
        
        # 使用dd命令进行简单的I/O测试
        echo "使用dd命令测试磁盘I/O性能..."
        
        # 测试磁盘写入速度
        local write_speed=$(dd if=/dev/zero of=/tmp/benchmark bs=1M count=100 2>&1 | grep copied | awk '{print $8 " " $9}')
        
        # 测试磁盘读取速度
        local read_speed=$(dd if=/tmp/benchmark of=/dev/null bs=1M count=100 2>&1 | grep copied | awk '{print $8 " " $9}')
        
        # 清理测试文件
        rm -f /tmp/benchmark
        
        echo "磁盘写入速度: $write_speed"
        echo "磁盘读取速度: $read_speed"
        
        # 由于无法进行长时间的I/O压力测试，这里等待剩余时间
        sleep $BENCHMARK_DURATION
    fi
}

# 运行混合负载测试
run_mixed_benchmark() {
    echo "开始混合负载测试..."
    
    # 同时运行CPU、内存和I/O测试
    run_cpu_benchmark
    run_memory_benchmark
    run_io_benchmark
    
    # 等待所有测试完成
    sleep $BENCHMARK_DURATION
}

# 分析sar测试数据
analyze_benchmark_data() {
    local sar_file="$1"
    
    echo "分析测试数据..."
    echo "==================== 系统性能基准测试报告 ====================" > $OUTPUT_FILE
    echo "报告生成时间: $(date '+%Y-%m-%d %H:%M:%S')" >> $OUTPUT_FILE
    echo "测试持续时间: $BENCHMARK_DURATION 秒" >> $OUTPUT_FILE
    echo "工作负载类型: $WORKLOAD_TYPE" >> $OUTPUT_FILE
    echo "主机名: $(hostname)" >> $OUTPUT_FILE
    echo "=====================================================" >> $OUTPUT_FILE
    echo "" >> $OUTPUT_FILE
    
    # CPU性能分析
    echo "--- CPU性能分析 ---" >> $OUTPUT_FILE
    local cpu_data=$(sar -f $sar_file -u)
    echo "$cpu_data" >> $OUTPUT_FILE
    echo "" >> $OUTPUT_FILE
    
    # 计算CPU性能指标
    local avg_cpu_idle=$(echo "$cpu_data" | tail -n 1 | awk '{print $8}')
    local avg_cpu_used=$(echo "scale=2; 100 - $avg_cpu_idle" | bc)
    echo "平均CPU使用率: $(printf "%.2f" $avg_cpu_used)%" >> $OUTPUT_FILE
    echo "" >> $OUTPUT_FILE
    
    # 内存性能分析
    echo "--- 内存性能分析 ---" >> $OUTPUT_FILE
    local mem_data=$(sar -f $sar_file -r)
    echo "$mem_data" >> $OUTPUT_FILE
    echo "" >> $OUTPUT_FILE
    
    # 计算内存性能指标
    local avg_mem_used=$(echo "$mem_data" | tail -n 1 | awk '{print $4}')
    echo "平均内存使用率: $(printf "%.2f" $avg_mem_used)%" >> $OUTPUT_FILE
    echo "" >> $OUTPUT_FILE
    
    # I/O性能分析
    echo "--- I/O性能分析 ---" >> $OUTPUT_FILE
    local io_data=$(sar -f $sar_file -b)
    echo "$io_data" >> $OUTPUT_FILE
    echo "" >> $OUTPUT_FILE
    
    # 计算I/O性能指标
    local avg_tps=$(echo "$io_data" | tail -n 1 | awk '{print $2}')
    local avg_bread=$(echo "$io_data" | tail -n 1 | awk '{print $5}')
    local avg_bwrtn=$(echo "$io_data" | tail -n 1 | awk '{print $6}')
    echo "平均每秒I/O事务数: $(printf "%.2f" $avg_tps)" >> $OUTPUT_FILE
    echo "平均每秒读取数据量: $(printf "%.2f" $avg_bread) KB/s" >> $OUTPUT_FILE
    echo "平均每秒写入数据量: $(printf "%.2f" $avg_bwrtn) KB/s" >> $OUTPUT_FILE
    echo "" >> $OUTPUT_FILE
    
    # 系统性能评分（简单计算）
    echo "--- 系统性能评分 ---" >> $OUTPUT_FILE
    
    # CPU评分（空闲率越低，评分越高）
    local cpu_score=$(echo "scale=2; 100 - $avg_cpu_idle" | bc)
    
    # 内存评分（基于内存压力下的系统响应）
    local mem_score=$(echo "scale=2; 100 - $avg_mem_used / 2" | bc)  # 假设80%内存使用率时得60分
    if (( $(echo "$mem_score < 0" | bc -l) )); then
        mem_score=0
    fi
    
    # I/O评分（基于吞吐量）
    local io_score=0
    if (( $(echo "$avg_tps > 0" | bc -l) )); then
        io_score=$(echo "scale=2; $avg_bread + $avg_bwrtn" | bc)
        if (( $(echo "$io_score > 100" | bc -l) )); then
            io_score=100
        fi
    fi
    
    # 综合评分（加权平均）
    local overall_score=$(echo "scale=2; ($cpu_score * 0.4) + ($mem_score * 0.3) + ($io_score * 0.3)" | bc)
    
    echo "CPU性能评分: $(printf "%.2f" $cpu_score)/100" >> $OUTPUT_FILE
    echo "内存性能评分: $(printf "%.2f" $mem_score)/100" >> $OUTPUT_FILE
    echo "I/O性能评分: $(printf "%.2f" $io_score)/100" >> $OUTPUT_FILE
    echo "系统综合评分: $(printf "%.2f" $overall_score)/100" >> $OUTPUT_FILE
    echo "" >> $OUTPUT_FILE
    
    # 性能建议
    echo "--- 性能建议 ---" >> $OUTPUT_FILE
    if (( $(echo "$overall_score >= 80" | bc -l) )); then
        echo "系统性能优秀，能够满足大多数工作负载需求。"
    elif (( $(echo "$overall_score >= 60" | bc -l) )); then
        echo "系统性能良好，能够满足一般工作负载需求，但在高负载下可能出现性能下降。"
    elif (( $(echo "$overall_score >= 40" | bc -l) )); then
        echo "系统性能一般，在高负载下可能出现明显的性能瓶颈，建议进行系统优化或考虑硬件升级。"
    else
        echo "系统性能较差，无法满足基本的工作负载需求，建议立即进行系统优化或硬件升级。"
    fi
    
    if (( $(echo "$cpu_score < 50" | bc -l) )); then
        echo "CPU性能较低，建议升级CPU或减少CPU密集型任务。"
    fi
    
    if (( $(echo "$mem_score < 50" | bc -l) )); then
        echo "内存性能较低，建议增加物理内存或优化内存使用。"
    fi
    
    if (( $(echo "$io_score < 50" | bc -l) )); then
        echo "I/O性能较低，建议升级存储系统（如使用SSD）或优化I/O操作。"
    fi
    
    echo "" >> $OUTPUT_FILE
    echo "测试结果已保存至: $OUTPUT_FILE"
}

# 显示帮助信息
show_help() {
    echo "系统性能基准测试工具"
    echo "用法: $0 [选项]"
    echo ""
    echo "选项:"
    echo "  -h, --help            显示帮助信息"
    echo "  -d, --duration <n>    设置测试持续时间(秒) (默认: $BENCHMARK_DURATION)"
    echo "  -t, --type <type>     设置工作负载类型(cpu, memory, io, mixed) (默认: $WORKLOAD_TYPE)"
    echo "  -o, --output <file>   设置测试结果文件路径 (默认: system_benchmark_YYYYMMDD_HHMMSS.log)"
    echo "  -i, --interval <n>    设置sar采样间隔(秒) (默认: $SA_SAMPLE_INTERVAL)"
    echo ""
    echo "示例:"
    echo "  # 以默认配置运行基准测试"
    echo "  $0"
    echo ""
    echo "  # 运行CPU压力测试，持续60秒"
    echo "  $0 -d 60 -t cpu"
    echo ""
    echo "  # 运行混合负载测试，并指定输出文件"
    echo "  $0 -t mixed -o my_benchmark.log"
    echo ""
}

# 主函数
main() {
    # 解析命令行参数
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -d|--duration)
                BENCHMARK_DURATION=$2
                shift 2
                ;;
            -t|--type)
                WORKLOAD_TYPE=$2
                shift 2
                ;;
            -o|--output)
                OUTPUT_FILE=$2
                shift 2
                ;;
            -i|--interval)
                SA_SAMPLE_INTERVAL=$2
                shift 2
                ;;
            *)
                echo "未知选项: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # 检查依赖工具
    check_dependencies
    
    # 记录系统基本信息
    echo "==================== 系统基本信息 ===================="
    echo "主机名: $(hostname)"
    echo "操作系统: $(uname -a)"
    echo "CPU核心数: $(nproc)"
    echo "总内存: $(free -h | awk '/Mem:/ {print $2}')"
    echo "磁盘空间: $(df -h / | tail -n 1 | awk '{print $2}')"
    echo "测试开始时间: $(date '+%Y-%m-%d %H:%M:%S')"
    echo "====================================================="
    echo ""
    
    # 启动sar数据收集
    local sar_file=$(start_sar_collection)
    
    # 注册退出信号处理，确保在脚本退出时停止sar收集
    trap "stop_sar_collection; echo '测试被中断'; exit 1" SIGINT SIGTERM
    
    # 运行相应类型的性能测试
    case $WORKLOAD_TYPE in
        cpu)
            run_cpu_benchmark
            ;;
        memory)
            run_memory_benchmark
            ;;
        io)
            run_io_benchmark
            ;;
        mixed)
            run_mixed_benchmark
            ;;
        *)
            echo "错误: 不支持的工作负载类型: $WORKLOAD_TYPE"
            echo "支持的类型: cpu, memory, io, mixed"
            stop_sar_collection
            exit 1
            ;;
    esac
    
    # 停止sar数据收集
    stop_sar_collection
    
    # 分析测试数据并生成报告
    analyze_benchmark_data $sar_file
    
    # 清理临时文件
    rm -f $sar_file
    
    echo "系统性能基准测试已完成"
    echo "测试结束时间: $(date '+%Y-%m-%d %H:%M:%S')"
}

# 执行主函数
main "$@"

## 6 常见问题与解决方案

### 6.1 sar命令不可用或找不到

**问题描述**：在某些Linux发行版上，运行`sar`命令时提示"command not found"。

**解决方案**：

- 在基于Debian/Ubuntu的系统上，安装sysstat包：
  ```bash
  sudo apt-get update && sudo apt-get install sysstat
  ```

- 在基于CentOS/RHEL的系统上，安装sysstat包：
  ```bash
  sudo yum install sysstat
  ```

- 在基于Arch Linux的系统上，安装sysstat包：
  ```bash
  sudo pacman -S sysstat
  ```

### 6.2 没有sar数据文件或数据不完整

**问题描述**：当尝试查看历史数据时，找不到sar数据文件或数据不完整。

**解决方案**：

- 检查sysstat服务是否已启动：
  ```bash
  sudo systemctl status sysstat
  ```

- 如果服务未启动，启动它并设置开机自启：
  ```bash
  sudo systemctl start sysstat
  sudo systemctl enable sysstat
  ```

- 检查sar数据收集配置：
  ```bash
  cat /etc/default/sysstat  # Debian/Ubuntu
  cat /etc/sysconfig/sysstat  # CentOS/RHEL
  ```

- 确保配置中的`ENABLED="true"`（Debian/Ubuntu）或`ENABLED="true"`（CentOS/RHEL）

- 检查数据收集间隔配置：
  ```bash
  cat /etc/cron.d/sysstat
  ```

### 6.3 sar数据文件占用过多磁盘空间

**问题描述**：随着时间推移，sar数据文件可能会占用大量磁盘空间。

**解决方案**：

- 查看当前sar数据文件大小：
  ```bash
  du -sh /var/log/sa/*
  ```

- 调整sysstat配置中的数据保留时间：
  ```bash
  sudo nano /etc/default/sysstat  # Debian/Ubuntu
  # 或
  sudo nano /etc/sysconfig/sysstat  # CentOS/RHEL
  ```
  修改`HISTORY`参数（单位为天）

- 手动删除旧的数据文件：
  ```bash
  sudo rm -f /var/log/sa/sa[0-9][0-9]
  ```

### 6.4 如何理解sar输出中的各种指标

**问题描述**：sar输出包含大量指标，初学者可能难以理解这些指标的含义和重要性。

**解决方案**：

- 参考本章节的各个示例部分，了解不同选项下输出的指标含义

- 使用`man sar`命令查看完整的手册页，了解每个指标的详细解释

- 关注关键指标：
  - CPU：关注`%user`、`%system`、`%iowait`和`%idle`
  - 内存：关注`%memused`、`kbbuffers`和`kbcached`
  - I/O：关注`tps`、`bread/s`和`bwrtn/s`
  - 网络：关注`rxkB/s`和`txkB/s`

- 对于特定应用场景，重点关注与该场景相关的指标

### 6.5 sar命令输出格式混乱或显示不全

**问题描述**：在某些终端窗口中，sar的输出格式可能会混乱或被截断，特别是当显示大量数据时。

**解决方案**：

- 使用`-P ALL`选项以更清晰的格式显示CPU数据：
  ```bash
  sar -u -P ALL
  ```

- 使用`-p`选项以易读的格式显示设备名称：
  ```bash
  sar -d -p
  ```

- 调整终端窗口的大小以适应输出

- 使用管道将输出重定向到文件，然后在编辑器中查看：
  ```bash
  sar > sar_output.txt
  ```

- 使用`less`或`more`命令分页查看输出：
  ```bash
  sar | less
  ```

### 6.6 如何将sar数据导出为其他格式用于分析

**问题描述**：如何将sar收集的数据导出为CSV、JSON或其他格式，以便使用Excel、Python或其他工具进行进一步分析？

**解决方案**：

- 使用`-o`选项将数据保存为二进制格式，然后使用`sar -f`读取并格式化输出：
  ```bash
  sar -o /tmp/sar_data
  sar -f /tmp/sar_data > sar_text_output.txt
  ```

- 使用`awk`命令处理sar输出，转换为CSV格式：
  ```bash
  sar -u | tail -n +3 | awk 'NR==1 {print "time,user,nice,system,iowait,steal,idle"} NR>1 && $1 != "Average:" {print $1","$3","$4","$5","$6","$7","$8"}' > cpu_usage.csv
  ```

- 使用本章5.2节的性能数据分析与可视化工具，可以直接将sar数据导出为CSV格式

- 对于更复杂的数据处理和分析，可以使用Python脚本结合pandas库来处理sar数据

### 6.7 如何比较不同时间段的sar数据

**问题描述**：如何比较不同时间段（如今天和昨天、本周和上周）的sar数据，以分析系统性能变化？

**解决方案**：

- 查看两天的数据并手动比较：
  ```bash
  sar -f /var/log/sa/sa$(date +%d -d yesterday) > yesterday.txt
  sar -f /var/log/sa/sa$(date +%d) > today.txt
  diff yesterday.txt today.txt
  ```

- 使用`-s`和`-e`选项指定时间范围，比较不同时间段的数据：
  ```bash
  sar -f /var/log/sa/sa$(date +%d) -s 10:00:00 -e 11:00:00 > morning.txt
  sar -f /var/log/sa/sa$(date +%d) -s 14:00:00 -e 15:00:00 > afternoon.txt
  ```

- 使用本章5.2节的性能数据分析与可视化工具，可以生成多日数据的趋势图，便于比较分析

- 编写自定义脚本，提取并比较关键指标的平均值、最大值等统计数据

### 6.8 sar与其他性能监控工具的区别

**问题描述**：sar与其他性能监控工具（如top、htop、vmstat或iostat）有什么区别？

**解决方案**：

- **sar**：专注于长期性能数据收集和历史趋势分析，提供全面的系统活动报告

- **top/htop**：提供实时的进程级资源使用情况，适合交互式监控

- **vmstat**：提供系统整体性能概览，包括进程、内存、交换空间、I/O和CPU活动

- **iostat**：专注于I/O统计，提供详细的磁盘和分区I/O性能信息

- **建议**：根据具体需求选择合适的工具，或结合使用多个工具以获得更全面的系统状态视图。对于长期性能监控和趋势分析，sar是首选工具

## 7 总结与注意事项

### 7.1 功能总结

`sar`是一个功能强大的系统性能监控工具，具有以下主要功能：

- 收集、报告和保存系统活动数据，支持长期性能监控
- 提供全面的性能指标，包括CPU、内存、磁盘、网络等多个方面
- 支持实时监控和历史数据分析
- 可配置的数据收集间隔和保存期限
- 丰富的选项和参数，可定制监控内容和输出格式
- 适合用于系统性能基准测试、瓶颈分析和容量规划

### 7.2 使用注意事项

在使用`sar`命令时，需要注意以下几点：

- **数据存储**：sar数据文件默认保存在`/var/log/sa/`目录下，需要确保该目录有足够的磁盘空间

- **数据保留**：默认情况下，sar数据会保留一定天数（通常为28天），可以通过配置文件调整保留期限

- **服务状态**：确保sysstat服务已启动并设置为开机自启，否则无法自动收集历史数据

- **性能影响**：虽然sar本身对系统性能影响较小，但过于频繁的数据收集可能会增加系统负载

- **权限要求**：查看和管理sar数据文件通常需要root权限

- **数据解读**：正确解读sar输出中的各项指标非常重要，需要了解每个指标的含义和正常范围

### 7.3 最佳实践

以下是一些使用`sar`命令的最佳实践：

- **定期监控**：配置sysstat服务自动收集系统性能数据，建立性能基准

- **问题排查**：当系统出现性能问题时，使用sar查看历史数据，帮助定位问题原因

- **容量规划**：分析长期性能趋势，预测系统资源需求，为容量规划提供依据

- **报表生成**：定期生成性能报告，如本章5.1节的系统资源监控与告警系统，可以自动生成每日性能报告

- **对比分析**：在系统变更前后使用sar进行对比分析，评估变更对系统性能的影响

- **性能优化**：根据sar的分析结果，有针对性地进行系统性能优化

- **数据可视化**：使用本章5.2节的性能数据分析与可视化工具，将sar数据转换为直观的图表展示

- **基准测试**：使用本章5.3节的系统性能基准测试工具，定期评估系统性能

通过合理使用`sar`命令，系统管理员可以全面了解系统的性能状况，及时发现并解决潜在的性能问题，确保系统的稳定运行和最佳性能。