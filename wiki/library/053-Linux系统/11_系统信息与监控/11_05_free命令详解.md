# 11.5 free命令详解

## 1. 命令概述

free命令是Linux/Unix系统中用于显示系统内存使用情况的命令。它提供了关于系统物理内存、交换空间和内核缓冲区内存的详细信息。free命令是系统管理员监控系统内存使用状况、排查内存相关问题的重要工具。

### 1.1 功能特点
- 显示系统物理内存的总量、已使用量、空闲量
- 显示交换空间（swap）的使用情况
- 显示内核缓冲区和页缓存的使用情况
- 支持以不同单位（KB、MB、GB等）显示内存信息
- 支持显示总计信息和进程使用的内存情况
- 可以持续监控内存使用变化

### 1.2 应用场景
- 检查系统当前内存使用状况
- 识别内存不足的情况
- 监控内存泄漏问题
- 在系统性能调优中评估内存需求
- 在自动化脚本中收集内存使用数据
- 排查系统响应缓慢或不稳定的问题

## 2. 语法格式

free命令的基本语法格式如下：

```bash
# 显示内存使用情况
$ free [选项]
```

### 2.1 语法说明
- **free**：命令名称
- **选项**：可选参数，用于控制输出格式、单位和显示内容
- free命令可以不带任何选项运行，默认以KB为单位显示内存信息
- 输出通常分为物理内存（Mem）、交换空间（Swap）和内核缓冲区（Buffers/Cache）三部分

## 3. 常用选项

free命令提供了多个选项，可以用于调整输出格式、单位和显示内容。以下是free命令的常用选项：

### 3.1 选项列表

| 选项 | 功能说明 |
|------|----------|
| `-b`, `--bytes` | 以字节为单位显示内存使用情况 |
| `-k`, `--kilo` | 以KB（千字节）为单位显示内存使用情况（默认） |
| `-m`, `--mega` | 以MB（兆字节）为单位显示内存使用情况 |
| `-g`, `--giga` | 以GB（吉字节）为单位显示内存使用情况 |
| `-h`, `--human` | 以人类可读的格式显示内存使用情况（自动选择合适的单位） |
| `-t`, `--total` | 在输出中添加一行总计信息 |
| `-s N`, `--seconds N` | 持续显示内存使用情况，每N秒更新一次 |
| `-c N`, `--count N` | 与-s选项一起使用，显示N次后停止 |
| `-w`, `--wide` | 以宽格式显示输出，包括更多详细信息 |
| `--help` | 显示帮助信息 |
| `--version` | 显示free命令的版本信息 |

## 4. 常用示例

### 4.1 显示基本内存信息

显示系统内存的基本使用情况：

```bash
# 默认以KB为单位显示内存信息
$ free
              total        used        free      shared  buff/cache   available
Mem:        8158184     2152372     1245632      327680     4760180     5363568
Swap:       2097148           0     2097148

# 输出解释：
# total: 总内存量
# used: 已使用的内存量
# free: 空闲的内存量
# shared: 多个进程共享的内存量
# buff/cache: 缓冲区和页缓存的内存量
# available: 估计可用于启动新应用程序的内存量，不包括交换空间
```

### 4.2 以人类可读格式显示内存信息

使用-h选项以更友好的格式显示内存信息：

```bash
# 以人类可读的格式显示内存信息
$ free -h
              total        used        free      shared  buff/cache   available
Mem:          7.8Gi       2.1Gi       1.2Gi       320Mi       4.5Gi       5.1Gi
Swap:         2.0Gi          0B       2.0Gi

# 这种格式会自动选择合适的单位（KB、MB、GB等），使输出更易读
```

### 4.3 显示总计信息

使用-t选项在输出中添加一行总计信息：

```bash
# 显示内存和交换空间的总计信息
$ free -ht
              total        used        free      shared  buff/cache   available
Mem:          7.8Gi       2.1Gi       1.2Gi       320Mi       4.5Gi       5.1Gi
Swap:         2.0Gi          0B       2.0Gi
Total:        9.8Gi       2.1Gi       3.2Gi

# Total行显示了物理内存和交换空间的总和
```

### 4.4 持续监控内存使用情况

使用-s选项持续监控内存使用情况，适合观察内存变化趋势：

```bash
# 每2秒更新一次内存使用情况
$ free -h -s 2
              total        used        free      shared  buff/cache   available
Mem:          7.8Gi       2.1Gi       1.2Gi       320Mi       4.5Gi       5.1Gi
Swap:         2.0Gi          0B       2.0Gi

              total        used        free      shared  buff/cache   available
Mem:          7.8Gi       2.2Gi       1.1Gi       320Mi       4.5Gi       5.0Gi
Swap:         2.0Gi          0B       2.0Gi

# 按Ctrl+C可以停止监控
```

### 4.5 指定监控次数

结合-s和-c选项，指定监控的次数和间隔：

```bash
# 每1秒更新一次，共显示5次内存使用情况
$ free -h -s 1 -c 5
              total        used        free      shared  buff/cache   available
Mem:          7.8Gi       2.1Gi       1.2Gi       320Mi       4.5Gi       5.1Gi
Swap:         2.0Gi          0B       2.0Gi

              total        used        free      shared  buff/cache   available
Mem:          7.8Gi       2.1Gi       1.2Gi       320Mi       4.5Gi       5.1Gi
Swap:         2.0Gi          0B       2.0Gi

              total        used        free      shared  buff/cache   available
Mem:          7.8Gi       2.1Gi       1.2Gi       320Mi       4.5Gi       5.1Gi
Swap:         2.0Gi          0B       2.0Gi

              total        used        free      shared  buff/cache   available
Mem:          7.8Gi       2.1Gi       1.2Gi       320Mi       4.5Gi       5.1Gi
Swap:         2.0Gi          0B       2.0Gi

              total        used        free      shared  buff/cache   available
Mem:          7.8Gi       2.1Gi       1.2Gi       320Mi       4.5Gi       5.1Gi
Swap:         2.0Gi          0B       2.0Gi

# 显示5次后自动退出
```

### 4.6 以宽格式显示详细信息

使用-w选项以宽格式显示更详细的内存信息：

```bash
# 以宽格式显示内存信息
$ free -hw
              total        used        free      shared     buffers       cache   available
Mem:          7.8Gi       2.1Gi       1.2Gi       320Mi       128Mi       4.4Gi       5.1Gi
Swap:         2.0Gi          0B       2.0Gi

# 宽格式将buff/cache分开显示为buffers和cache，提供更详细的信息
```

### 4.7 在脚本中使用free命令

在Shell脚本中获取和处理内存使用信息：

```bash
#!/bin/bash

# 获取内存使用情况的详细信息
mem_info=$(free -m)

echo "=== 系统内存使用报告 ==="
echo "生成时间: $(date '+%Y-%m-%d %H:%M:%S')"
echo ""

# 显示原始输出
echo "原始内存信息:"
echo "$mem_info"
echo ""

# 提取关键内存指标
total_mem=$(echo "$mem_info" | grep Mem: | awk '{print $2}')
used_mem=$(echo "$mem_info" | grep Mem: | awk '{print $3}')
free_mem=$(echo "$mem_info" | grep Mem: | awk '{print $4}')
buff_cache=$(echo "$mem_info" | grep Mem: | awk '{print $6}')
avail_mem=$(echo "$mem_info" | grep Mem: | awk '{print $7}')

# 计算内存使用率
mem_usage_percent=$(echo "scale=2; $used_mem / $total_mem * 100" | bc)

echo "关键内存指标（MB）:"
echo "总内存: $total_mem MB"
echo "已用内存: $used_mem MB ($mem_usage_percent%)"
echo "空闲内存: $free_mem MB"
echo "缓冲区和缓存: $buff_cache MB"
echo "可用内存: $avail_mem MB"
echo ""

# 检查内存使用是否过高（假设阈值为80%）
if (( $(echo "$mem_usage_percent > 80" | bc -l) )); then
    echo "警告: 内存使用率 ($mem_usage_percent%) 超过80%，系统内存压力较大！"
    
    # 显示占用内存最多的前5个进程
    echo "\n占用内存最多的前5个进程:"
    ps aux --sort=-%mem | head -6
else
    echo "内存使用情况正常 ($mem_usage_percent% < 80%)"
fi

# 检查交换空间使用情况
swap_total=$(echo "$mem_info" | grep Swap: | awk '{print $2}')
swap_used=$(echo "$mem_info" | grep Swap: | awk '{print $3}')

if [ $swap_used -gt 0 ]; then
    swap_usage_percent=$(echo "scale=2; $swap_used / $swap_total * 100" | bc)
    echo "\n交换空间使用情况:"
    echo "总交换空间: $swap_total MB"
    echo "已用交换空间: $swap_used MB ($swap_usage_percent%)"
    echo "警告: 系统正在使用交换空间，可能表示物理内存不足"
else
    echo "\n交换空间使用情况:"
    echo "未使用交换空间，系统内存充足"
fi
```

## 5. 高级用法

### 5.1 内存使用趋势分析

创建脚本持续监控内存使用情况，并记录数据用于趋势分析：

```bash
#!/bin/bash

# 内存使用趋势监控脚本

# 配置参数
LOG_FILE="/var/log/memory_usage.log"
CHECK_INTERVAL=300  # 检查间隔（秒），这里设置为5分钟
MAX_LOG_SIZE=1048576  # 最大日志文件大小（字节），这里设置为1MB

# 确保日志文件存在
touch $LOG_FILE
chmod 644 $LOG_FILE

# 检查并旋转日志文件
if [ $(stat -c%s $LOG_FILE) -ge $MAX_LOG_SIZE ]; then
    mv $LOG_FILE $LOG_FILE.old
    touch $LOG_FILE
    chmod 644 $LOG_FILE
fi

# 记录内存使用数据
while true; do
    # 获取当前时间和内存信息
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    mem_info=$(free -m)
    
    # 提取内存指标
total_mem=$(echo "$mem_info" | grep Mem: | awk '{print $2}')
used_mem=$(echo "$mem_info" | grep Mem: | awk '{print $3}')
avail_mem=$(echo "$mem_info" | grep Mem: | awk '{print $7}')
swap_used=$(echo "$mem_info" | grep Swap: | awk '{print $3}')
    
    # 计算内存使用率
    mem_usage_percent=$(echo "scale=2; $used_mem / $total_mem * 100" | bc)
    
    # 写入日志文件
    echo "$timestamp,$total_mem,$used_mem,$avail_mem,$swap_used,$mem_usage_percent" >> $LOG_FILE
    
    # 等待下一次检查
    sleep $CHECK_INTERVAL
done

# 使用方法: 将脚本保存为memory_monitor.sh，然后运行：nohup ./memory_monitor.sh &
# 数据分析: 可以使用awk、gnuplot等工具分析日志文件中的数据
```

### 5.2 内存使用告警系统

创建自动化脚本监控内存使用情况，并在内存不足时发送告警：

```bash
#!/bin/bash

# 内存使用监控和告警脚本

# 配置参数
MEM_THRESHOLD=80  # 内存使用率阈值（%）
SWAP_THRESHOLD=50  # 交换空间使用率阈值（%）
CHECK_INTERVAL=60  # 检查间隔（秒）
LOG_FILE="/var/log/mem_alert.log"
ALERT_EMAIL="admin@example.com"

# 确保日志文件存在
touch $LOG_FILE
chmod 644 $LOG_FILE

# 记录监控开始信息
echo "[$(date '+%Y-%m-%d %H:%M:%S')] 内存监控告警脚本启动 - 内存阈值: $MEM_THRESHOLD%, 交换空间阈值: $SWAP_THRESHOLD%" >> $LOG_FILE

while true; do
    # 获取内存信息
    mem_info=$(free -m)
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # 提取内存指标
total_mem=$(echo "$mem_info" | grep Mem: | awk '{print $2}')
used_mem=$(echo "$mem_info" | grep Mem: | awk '{print $3}')
avail_mem=$(echo "$mem_info" | grep Mem: | awk '{print $7}')
total_swap=$(echo "$mem_info" | grep Swap: | awk '{print $2}')
used_swap=$(echo "$mem_info" | grep Swap: | awk '{print $3}')
    
    # 计算使用率
    mem_usage_percent=$(echo "scale=2; $used_mem / $total_mem * 100" | bc)
    
    if [ $total_swap -gt 0 ]; then
        swap_usage_percent=$(echo "scale=2; $used_swap / $total_swap * 100" | bc)
    else
        swap_usage_percent=0
    fi
    
    # 记录当前状态
    echo "[$timestamp] 内存使用率: $mem_usage_percent%, 交换空间使用率: $swap_usage_percent%" >> $LOG_FILE
    
    # 检查内存使用率是否超过阈值
    if (( $(echo "$mem_usage_percent > $MEM_THRESHOLD" | bc -l) )); then
        ALERT_MESSAGE="警告: 内存使用率过高！\n时间: $timestamp\n主机: $(hostname)\n总内存: $total_mem MB\n已用内存: $used_mem MB ($mem_usage_percent%)\n可用内存: $avail_mem MB\n阈值: $MEM_THRESHOLD%"
        
        # 记录警报
        echo "[$timestamp] 警报: 内存使用率过高！" >> $LOG_FILE
        echo "$ALERT_MESSAGE" >> $LOG_FILE
        echo "------------------------------------" >> $LOG_FILE
        
        # 发送邮件警报（需要配置邮件服务）
        # echo "$ALERT_MESSAGE" | mail -s "[警报] 内存使用率过高" $ALERT_EMAIL
        
        # 输出到控制台
        echo "$ALERT_MESSAGE"
    fi
    
    # 检查交换空间使用率是否超过阈值
    if (( $(echo "$swap_usage_percent > $SWAP_THRESHOLD" | bc -l) )); then
        ALERT_MESSAGE="警告: 交换空间使用率过高！\n时间: $timestamp\n主机: $(hostname)\n总交换空间: $total_swap MB\n已用交换空间: $used_swap MB ($swap_usage_percent%)\n阈值: $SWAP_THRESHOLD%"
        
        # 记录警报
        echo "[$timestamp] 警报: 交换空间使用率过高！" >> $LOG_FILE
        echo "$ALERT_MESSAGE" >> $LOG_FILE
        echo "------------------------------------" >> $LOG_FILE
        
        # 发送邮件警报（需要配置邮件服务）
        # echo "$ALERT_MESSAGE" | mail -s "[警报] 交换空间使用率过高" $ALERT_EMAIL
        
        # 输出到控制台
        echo "$ALERT_MESSAGE"
    fi
    
    # 等待下一次检查
    sleep $CHECK_INTERVAL
done

# 使用方法: 将脚本保存为mem_alert.sh，然后运行：nohup ./mem_alert.sh &
```

### 5.3 内存使用分析和可视化

结合其他工具对内存使用情况进行深入分析和可视化：

```bash
#!/bin/bash

# 内存使用分析和可视化脚本

# 确保安装了必要的工具
echo "检查必要的工具是否安装..."
for tool in bc awk ps grep; do
    if ! command -v $tool &> /dev/null; then
        echo "错误: 工具 $tool 未安装，请先安装" >&2
        exit 1
    fi
done

# 创建临时目录存储分析结果
temp_dir=$(mktemp -d)
echo "使用临时目录: $temp_dir"

# 收集当前内存使用数据
echo "收集当前内存使用数据..."
free -h > $temp_dir/free_output.txt
free -w > $temp_dir/free_wide_output.txt

# 收集进程内存使用数据
echo "收集进程内存使用数据..."
ps aux --sort=-%mem | head -20 > $temp_dir/top_mem_processes.txt

# 分析和显示数据
echo "\n=== 内存使用分析报告 ==="
echo "生成时间: $(date '+%Y-%m-%d %H:%M:%S')"
echo "主机名: $(hostname)"
echo "\n--- 基本内存信息 ---"
cat $temp_dir/free_output.txt

# 计算关键内存指标
total_mem=$(free -m | grep Mem: | awk '{print $2}')
used_mem=$(free -m | grep Mem: | awk '{print $3}')
avail_mem=$(free -m | grep Mem: | awk '{print $7}')

mem_usage_percent=$(echo "scale=2; $used_mem / $total_mem * 100" | bc)
avail_percent=$(echo "scale=2; $avail_mem / $total_mem * 100" | bc)

echo "\n--- 内存使用汇总 ---"
echo "总内存: $total_mem MB"
echo "已用内存: $used_mem MB ($mem_usage_percent%)"
echo "可用内存: $avail_mem MB ($avail_percent%)"

# 分析内存使用状态
if (( $(echo "$mem_usage_percent < 60" | bc -l) )); then
    echo "内存状态: 充足"
elif (( $(echo "$mem_usage_percent < 80" | bc -l) )); then
    echo "内存状态: 适中"
elif (( $(echo "$mem_usage_percent < 90" | bc -l) )); then
    echo "内存状态: 紧张"
else
    echo "内存状态: 严重不足"
fi

# 显示占用内存最多的进程
echo "\n--- 占用内存最多的前10个进程 ---"
head -11 $temp_dir/top_mem_processes.txt | column -t

# 检查交换空间使用情况
echo "\n--- 交换空间使用情况 ---"
total_swap=$(free -m | grep Swap: | awk '{print $2}')
used_swap=$(free -m | grep Swap: | awk '{print $3}')

if [ $total_swap -gt 0 ]; then
    swap_usage_percent=$(echo "scale=2; $used_swap / $total_swap * 100" | bc)
    echo "总交换空间: $total_swap MB"
    echo "已用交换空间: $used_swap MB ($swap_usage_percent%)"
    
    if (( $(echo "$swap_usage_percent > 50" | bc -l) )); then
        echo "警告: 交换空间使用率过高，可能表示物理内存不足"
    fi
else
    echo "系统未配置交换空间"
fi

# 建议操作
echo "\n--- 建议操作 ---"
if (( $(echo "$mem_usage_percent > 80" | bc -l) )); then
    echo "1. 检查并关闭不必要的进程"
    echo "2. 考虑增加物理内存"
    echo "3. 检查是否存在内存泄漏的进程"
    echo "4. 可以使用 'top' 或 'htop' 命令进一步分析进程内存使用情况"
elif (( $(echo "$swap_usage_percent > 50" | bc -l) )); then
    echo "1. 考虑增加物理内存以减少交换空间的使用"
    echo "2. 检查是否存在内存泄漏的进程"
else
    echo "1. 当前内存使用情况正常"
    echo "2. 定期监控内存使用情况以预防潜在问题"
fi

# 清理临时文件
echo "\n清理临时文件..."
rm -rf $temp_dir

echo "\n内存分析报告生成完成！"
```

## 6. 常见问题与解决方案

### 6.1 内存使用率过高

**问题**：free命令显示系统内存使用率持续过高。

**解决方案**：
1. 使用`top`或`htop`命令查看哪些进程占用了最多的内存
2. 检查是否有内存泄漏的进程：观察进程内存使用是否随时间持续增长
3. 关闭不必要的服务和应用程序，释放内存
4. 考虑增加系统物理内存或启用交换空间
5. 对于缓存占用过多内存的情况，可以使用`echo 3 > /proc/sys/vm/drop_caches`清除缓存（需要root权限，谨慎使用）

### 6.2 可用内存与空闲内存差异大

**问题**：free命令显示的"available"与"free"内存数值差异较大。

**解决方案**：
1. 理解Linux内存管理机制：Linux会利用空闲内存作为文件系统缓存，以提高系统性能
2. "free"表示完全未使用的内存，而"available"包括可回收的缓存内存
3. 当应用程序需要更多内存时，Linux会自动释放缓存，因此实际可用内存比"free"列显示的要多
4. 关注"available"列更能准确反映系统可用于新应用程序的内存量

### 6.3 交换空间频繁使用

**问题**：系统频繁使用交换空间，即使有一定的物理内存可用。

**解决方案**：
1. 检查系统的交换设置：`cat /proc/sys/vm/swappiness`，该值决定了系统使用交换空间的积极程度
2. 调整swappiness值：`sudo sysctl vm.swappiness=10`（临时调整）或修改`/etc/sysctl.conf`文件（永久调整）
3. 考虑增加物理内存，特别是在交换空间使用率持续超过50%的情况下
4. 检查是否有内存密集型进程，可以考虑优化或迁移这些进程

### 6.4 内存使用增长但找不到占用内存的进程

**问题**：free命令显示内存使用持续增长，但使用top命令找不到明显占用大量内存的进程。

**解决方案**：
1. 检查内核内存使用情况：`cat /proc/meminfo | grep Slab`查看内核缓存使用
2. 检查tmpfs文件系统使用：`df -h | grep tmpfs`查看临时文件系统占用
3. 检查共享内存使用：`ipcs -m`查看共享内存段
4. 使用`smem`工具进行更详细的内存使用分析（可能需要安装）
5. 可能是内存泄漏问题，检查是否有内核模块或驱动程序异常

### 6.5 无法正确解释free命令输出

**问题**：不理解free命令输出中的各个字段含义，导致无法正确评估系统内存状况。

**解决方案**：
1. 学习free命令输出字段的含义，特别是Mem行中的total、used、free、shared、buff/cache和available字段
2. 使用`free -h`以人类可读的格式显示，更易于理解
3. 关注available字段而不是free字段，因为available更能反映系统可用于新应用程序的内存量
4. 了解Linux内存管理的基本原理，特别是缓存和缓冲区的作用
5. 使用其他工具如htop、atop等提供的图形化界面，可以更直观地查看内存使用情况

## 7. 总结与注意事项

### 7.1 总结

free命令是Linux/Unix系统中用于显示和监控内存使用情况的重要工具。它提供了关于系统物理内存、交换空间和内核缓冲区的详细信息，帮助系统管理员了解系统内存状况、识别内存不足问题和监控内存使用趋势。通过结合其他工具和脚本，可以实现更复杂的内存监控和分析功能。

### 7.2 注意事项

- free命令的输出需要正确理解，特别是Linux系统中的缓存机制会影响空闲内存的显示
- 在评估系统内存状况时，应主要关注available字段而非free字段
- 持续监控内存使用情况有助于及时发现潜在问题
- 交换空间的频繁使用可能表示物理内存不足，应考虑增加内存或优化应用程序
- 不同版本的free命令输出格式可能略有不同，特别是在较新的Linux发行版中
- 在脚本中解析free命令输出时，应考虑不同系统和版本可能存在的格式差异
- 定期清理不必要的缓存和临时文件可以释放部分内存，但在大多数情况下，Linux会自动管理内存资源