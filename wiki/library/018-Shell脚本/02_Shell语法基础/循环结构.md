# 循环结构

## 什么是循环结构

循环结构是编程中的基本控制结构之一，它允许程序重复执行一段代码，直到满足特定条件为止。在Shell脚本中，循环结构可以帮助我们自动化重复性任务，处理大量数据，或者等待某个条件的满足。

## for循环

for循环用于已知循环次数或需要遍历一系列值的情况。

### 基本语法

```bash
for variable in list
do
    # 循环体
    commands
done
```

### 遍历数字列表

```bash
#!/bin/bash

# 遍历指定数字
for i in 1 2 3 4 5
do
    echo "数字: $i"
done

# 使用大括号扩展
for i in {1..5}
do
    echo "数字: $i"
done

# 使用seq命令生成数字序列
for i in $(seq 1 5)
do
    echo "数字: $i"
done

# 指定步长的数字序列
for i in $(seq 1 2 10)  # 从1开始，步长为2，到10结束
do
    echo "奇数: $i"
done
```

### 遍历字符串列表

```bash
#!/bin/bash

# 遍历字符串列表
for color in red green blue yellow
do
    echo "颜色: $color"
done

# 遍历数组
fruits=("苹果" "香蕉" "橙子" "葡萄")
for fruit in "${fruits[@]}"
do
    echo "水果: $fruit"
done

# 遍历命令输出结果
for file in $(ls *.txt)
do
    echo "文本文件: $file"
done
```

### C风格for循环

Bash还支持类似C语言的for循环语法：

```bash
#!/bin/bash

# C风格for循环
for ((i=1; i<=5; i++))
do
    echo "计数: $i"
done

# 嵌套循环
for ((i=1; i<=3; i++))
do
    for ((j=1; j<=3; j++))
    do
        echo "i=$i, j=$j"
    done
done
```

## while循环

while循环在条件为真时重复执行，适用于未知循环次数的情况。

### 基本语法

```bash
while condition
do
    # 循环体
    commands
done
```

### 基本示例

```bash
#!/bin/bash

# 计数循环
count=1
while [ $count -le 5 ]
do
    echo "计数: $count"
    count=$((count + 1))
done

# 读取用户输入直到满足条件
while true
do
    read -p "请输入 'yes' 继续: " input
    if [ "$input" = "yes" ]
    then
        echo "输入正确！"
        break
    else
        echo "输入错误，请重新输入"
    fi
done
```

### 文件处理示例

```bash
#!/bin/bash

# 逐行读取文件
file="data.txt"
if [ -f "$file" ]
then
    while IFS= read -r line
    do
        echo "读取到: $line"
    done < "$file"
else
    echo "文件 $file 不存在"
fi

# 读取并处理命令输出
while read user uid gid home
do
    echo "用户: $user, UID: $uid, 主目录: $home"
done < <(cut -d: -f1,3,4,6 /etc/passwd)
```

## until循环

until循环与while循环相反，在条件为假时重复执行。

### 基本语法

```bash
until condition
do
    # 循环体
    commands
done
```

### 基本示例

```bash
#!/bin/bash

# 计数示例
count=1
until [ $count -gt 5 ]
do
    echo "计数: $count"
    count=$((count + 1))
done

# 等待文件创建
file="test.txt"
until [ -f "$file" ]
do
    echo "等待文件 $file 创建..."
    sleep 1
done
echo "文件 $file 已创建"
```

## 循环控制语句

Shell提供了几种循环控制语句来改变循环的执行流程。

### break语句

break语句用于立即退出循环：

```bash
#!/bin/bash

# 在for循环中使用break
for i in {1..10}
do
    if [ $i -eq 5 ]
    then
        echo "到达5，退出循环"
        break
    fi
    echo "数字: $i"
done

# 在嵌套循环中使用break
for i in {1..3}
do
    for j in {1..3}
    do
        if [ $i -eq 2 ] && [ $j -eq 2 ]
        then
            echo "i=$i, j=$j，退出内层循环"
            break 2  # 退出两层循环
        fi
        echo "i=$i, j=$j"
    done
done
```

### continue语句

continue语句用于跳过当前循环的剩余部分，直接进入下一次循环：

```bash
#!/bin/bash

# 跳过偶数
for i in {1..10}
do
    if [ $((i % 2)) -eq 0 ]
    then
        echo "跳过偶数: $i"
        continue
    fi
    echo "奇数: $i"
done

# 处理文件列表，跳过特定文件
for file in *.txt
do
    if [ "$file" = "temp.txt" ]
    then
        echo "跳过临时文件: $file"
        continue
    fi
    echo "处理文件: $file"
    # 实际处理文件的命令
done
```

## 实际应用示例

### 系统监控脚本

```bash
#!/bin/bash

# 系统监控示例
monitor_system() {
    local max_attempts=5
    local attempt=1
    
    while [ $attempt -le $max_attempts ]
    do
        echo "=== 系统监控第 $attempt 次 ==="
        
        # 检查CPU使用率
        cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
        echo "CPU使用率: ${cpu_usage}%"
        
        # 检查内存使用率
        memory_usage=$(free | grep Mem | awk '{printf("%.0f", $3/$2 * 100.0)}')
        echo "内存使用率: ${memory_usage}%"
        
        # 检查磁盘使用率
        disk_usage=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
        echo "磁盘使用率: ${disk_usage}%"
        
        # 如果任何资源使用率超过阈值，发出警告
        if [ $(echo "$cpu_usage > 80" | bc) -eq 1 ] || 
           [ $memory_usage -gt 80 ] || 
           [ $disk_usage -gt 80 ]
        then
            echo "警告: 系统资源使用率过高！"
        else
            echo "系统状态正常"
        fi
        
        echo  # 空行
        
        # 如果是最后一次检查，退出循环
        if [ $attempt -eq $max_attempts ]
        then
            break
        fi
        
        # 等待10秒后继续下一次检查
        echo "等待10秒后继续检查..."
        sleep 10
        attempt=$((attempt + 1))
    done
}

# 运行监控
monitor_system
```

### 文件批量处理脚本

```bash
#!/bin/bash

# 文件批量处理示例
process_files() {
    local directory=${1:-.}  # 默认为当前目录
    local processed_count=0
    local error_count=0
    
    # 检查目录是否存在
    if [ ! -d "$directory" ]
    then
        echo "错误: 目录 $directory 不存在"
        return 1
    fi
    
    echo "开始处理目录: $directory"
    
    # 遍历目录中的所有文件
    for file in "$directory"/*
    do
        # 检查是否为普通文件
        if [ ! -f "$file" ]
        then
            continue
        fi
        
        echo "处理文件: $(basename "$file")"
        
        # 获取文件信息
        file_size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
        file_type=$(file -b "$file")
        
        echo "  大小: $file_size 字节"
        echo "  类型: $file_type"
        
        # 根据文件类型进行处理
        case "$file_type" in
            *text*)
                echo "  这是一个文本文件"
                line_count=$(wc -l < "$file")
                echo "  行数: $line_count"
                ;;
            *image*)
                echo "  这是一个图像文件"
                # 可以调用图像处理工具
                ;;
            *directory*)
                echo "  这是一个目录（跳过）"
                continue
                ;;
            *)
                echo "  未知文件类型"
                ;;
        esac
        
        processed_count=$((processed_count + 1))
        
        # 每处理10个文件暂停一下
        if [ $((processed_count % 10)) -eq 0 ]
        then
            echo "已处理 $processed_count 个文件，按回车继续..."
            read -r
        fi
    done
    
    echo "处理完成: 共处理 $processed_count 个文件，$error_count 个错误"
}

# 调用函数处理当前目录
process_files "."
```

### 用户菜单循环

```bash
#!/bin/bash

# 用户菜单循环示例
show_menu() {
    echo "========== 系统管理工具 =========="
    echo "1. 查看系统信息"
    echo "2. 查看网络状态"
    echo "3. 查看磁盘使用情况"
    echo "4. 查看进程信息"
    echo "5. 退出"
    echo "================================"
}

get_system_info() {
    echo "=== 系统信息 ==="
    uname -a
    echo "当前用户: $(whoami)"
    echo "系统时间: $(date)"
    echo "运行时间: $(uptime)"
}

get_network_status() {
    echo "=== 网络状态 ==="
    echo "网络接口:"
    ip link show 2>/dev/null | head -10 || ifconfig 2>/dev/null | head -10
    echo "网络连接:"
    netstat -an | head -10
}

get_disk_usage() {
    echo "=== 磁盘使用情况 ==="
    df -h
}

get_process_info() {
    echo "=== 进程信息 ==="
    echo "进程总数: $(ps aux | wc -l)"
    echo "前10个占用CPU最多的进程:"
    ps aux --sort=-%cpu | head -11
}

# 主循环
while true
do
    show_menu
    read -p "请选择操作 (1-5): " choice
    
    case $choice in
        1)
            get_system_info
            ;;
        2)
            get_network_status
            ;;
        3)
            get_disk_usage
            ;;
        4)
            get_process_info
            ;;
        5)
            echo "再见！"
            exit 0
            ;;
        *)
            echo "无效选择，请输入1-5之间的数字"
            ;;
    esac
    
    echo  # 空行
    echo "按回车键返回菜单..."
    read -r
    clear  # 清屏
done
```

## 嵌套循环

循环可以嵌套使用，用于处理多维数据或复杂的重复任务：

```bash
#!/bin/bash

# 打印乘法表
echo "=== 乘法表 ==="
for i in {1..9}
do
    for j in {1..$i}
    do
        result=$((i * j))
        printf "%d×%d=%-2d " $j $i $result
    done
    echo  # 换行
done

# 处理二维数据
declare -A matrix
matrix[0,0]=1
matrix[0,1]=2
matrix[1,0]=3
matrix[1,1]=4

echo "=== 矩阵数据 ==="
for i in 0 1
do
    for j in 0 1
    do
        echo "matrix[$i,$j] = ${matrix[$i,$j]}"
    done
done
```

## 最佳实践

1. **选择合适的循环类型**：已知次数用for，未知次数用while
2. **避免无限循环**：确保循环条件最终会变为假
3. **合理使用循环控制语句**：善用break和continue提高效率
4. **注意变量作用域**：在循环中修改的变量在循环外仍然有效
5. **处理空值和边界情况**：确保循环能正确处理空列表或异常情况
6. **添加进度提示**：对于长时间运行的循环，提供进度反馈

## 总结

循环结构是Shell脚本中处理重复任务的重要工具。通过本章的学习，你应该掌握了：

1. for循环的各种使用方式
2. while循环和until循环的特点和应用
3. 循环控制语句（break、continue）的使用
4. 嵌套循环的实现
5. 实际应用示例

结合之前学习的变量、运算符、输入输出和条件语句，你现在可以编写功能完整的Shell脚本来处理各种自动化任务。在下一章中，我们将学习函数的定义与调用，进一步提高脚本的模块化和可重用性。