# 进程管理命令

## 进程管理概述

在Linux/Unix系统中，进程是正在运行的程序实例。有效的进程管理对于系统性能优化、故障排查和资源监控至关重要。Shell提供了丰富的进程管理命令，帮助用户查看、控制和管理系统中的进程。

## 进程查看命令

### ps命令

ps命令用于显示当前系统中的进程信息。

```bash
#!/bin/bash

echo "=== ps命令示例 ==="

echo "基本用法 - 显示当前终端的进程:"
ps

echo -e "\n显示所有进程:"
ps -e  # 或 ps aux

echo -e "\nBSD风格显示 (常用):"
ps aux
echo "字段说明:"
echo "  USER: 进程所有者"
echo "  PID: 进程ID"
echo "  %CPU: CPU使用率"
echo "  %MEM: 内存使用率"
echo "  VSZ: 虚拟内存大小"
echo "  RSS: 物理内存使用量"
echo "  TTY: 终端类型"
echo "  STAT: 进程状态"
echo "  START: 启动时间"
echo "  TIME: CPU时间"
echo "  COMMAND: 命令行"

echo -e "\n自定义输出格式:"
ps -eo pid,ppid,cmd,%cpu,%mem --sort=-%cpu | head -10

echo -e "\n显示进程树:"
ps -ef --forest

echo -e "\n显示特定用户的进程:"
ps -u $USER

echo -e "\n显示特定进程:"
ps -p $$  # 显示当前shell进程

echo -e "\n显示进程的线程:"
ps -eLf
```

### pstree命令

pstree命令以树状图显示进程之间的父子关系。

```bash
#!/bin/bash

echo "=== pstree命令示例 ==="

echo "基本用法 - 显示进程树:"
pstree

echo -e "\n显示PID:"
pstree -p

echo -e "\n显示用户:"
pstree -u

echo -e "\n显示特定进程的子树:"
pstree $$  # 显示当前shell的子进程树

echo -e "\n合并相同进程:"
pstree -c
```

### top命令

top命令提供动态的进程监控界面。

```bash
#!/bin/bash

echo "=== top命令示例 ==="
echo "top命令提供实时进程监控界面"
echo "常用快捷键:"
echo "  q - 退出"
echo "  h - 显示帮助"
echo "  k - 终止进程"
echo "  r - 调整进程优先级"
echo "  M - 按内存使用率排序"
echo "  P - 按CPU使用率排序"
echo "  T - 按运行时间排序"
echo "  u - 显示特定用户的进程"
echo "  f - 添加或删除显示字段"

echo -e "\n批处理模式:"
echo "top -b -n 1  # 运行一次并输出到标准输出"

echo -e "\n显示特定用户的进程:"
echo "top -u $USER"
```

### htop命令

htop是top的增强版本，提供更友好的交互界面。

```bash
#!/bin/bash

echo "=== htop命令示例 ==="
echo "htop是top的交互式增强版本"
echo "特性:"
echo "  - 彩色显示"
echo "  - 可鼠标操作"
echo "  - 水平和垂直滚动"
echo "  - 进程树视图"
echo "  - 可直接杀死进程"
echo "  - 可调整进程优先级"

echo -e "\n常用快捷键:"
echo "  F1 - 帮助"
echo "  F2 - 设置"
echo "  F3 - 搜索"
echo "  F4 - 过滤"
echo "  F5 - 树状视图"
echo "  F6 - 排序"
echo "  F9 - 终止进程"
echo "  F10 - 退出"
```

## 进程控制命令

### kill命令

kill命令用于向进程发送信号，通常用于终止进程。

```bash
#!/bin/bash

echo "=== kill命令示例 ==="

echo "基本用法 - 终止进程:"
echo "kill PID"

echo -e "\n常用信号:"
echo "  SIGTERM (15) - 正常终止 (默认)"
echo "  SIGKILL (9) - 强制终止"
echo "  SIGHUP (1) - 重新加载配置"
echo "  SIGSTOP (17,19,23) - 暂停进程"
echo "  SIGCONT (18,20,24) - 继续进程"

echo -e "\n发送特定信号:"
echo "kill -9 PID    # 强制终止"
echo "kill -1 PID    # 重新加载"
echo "kill -STOP PID # 暂停进程"
echo "kill -CONT PID # 继续进程"

echo -e "\n按名称终止进程:"
echo "killall firefox  # 终止所有firefox进程"
echo "pkill chrome     # 终止所有包含chrome的进程"
```

### killall命令

killall命令通过进程名称终止进程。

```bash
#!/bin/bash

echo "=== killall命令示例 ==="

echo "按名称终止进程:"
echo "killall firefox"

echo -e "\n交互式终止:"
echo "killall -i firefox  # 终止前确认"

echo -e "\n等待进程终止:"
echo "killall -w firefox  # 等待直到所有进程终止"

echo -e "\n精确匹配:"
echo "killall -e firefox  # 精确匹配进程名"
```

### pkill命令

pkill命令通过进程名称或其他属性终止进程。

```bash
#!/bin/bash

echo "=== pkill命令示例 ==="

echo "按名称终止进程:"
echo "pkill firefox"

echo -e "\n按用户终止进程:"
echo "pkill -u username"

echo -e "\n按终端终止进程:"
echo "pkill -t pts/0"

echo -e "\n按父进程ID终止进程:"
echo "pkill -P 1234"

echo -e "\n使用正则表达式:"
echo "pkill 'fire.*'  # 终止名称匹配fire.*的进程"
```

## 进程优先级管理

### nice命令

nice命令用于启动具有指定优先级的进程。

```bash
#!/bin/bash

echo "=== nice命令示例 ==="

echo "进程优先级范围: -20 (最高) 到 19 (最低)"
echo "默认优先级: 0"

echo -e "\n以低优先级启动进程:"
echo "nice command"
echo "nice -n 10 command  # 设置优先级为10"

echo -e "\n查看进程优先级:"
echo "ps -eo pid,ni,comm | grep process_name"
```

### renice命令

renice命令用于修改正在运行进程的优先级。

```bash
#!/bin/bash

echo "=== renice命令示例 ==="

echo "修改进程优先级:"
echo "renice 5 PID  # 将PID进程的优先级设为5"

echo -e "\n修改用户所有进程的优先级:"
echo "renice 10 -u username"

echo -e "\n修改组所有进程的优先级:"
echo "renice 10 -g groupname"
```

## 后台进程管理

### jobs命令

jobs命令用于显示当前shell会话中的作业。

```bash
#!/bin/bash

echo "=== jobs命令示例 ==="

echo "显示后台作业:"
echo "jobs"

echo -e "\n显示作业的PID:"
echo "jobs -p"

echo -e "\n显示作业的进程组ID:"
echo "jobs -g"

echo -e "\n显示特定作业:"
echo "jobs %1  # 显示作业1"
```

### bg和fg命令

bg和fg命令用于在后台和前台之间切换作业。

```bash
#!/bin/bash

echo "=== bg和fg命令示例 ==="

echo "将作业放到后台运行:"
echo "bg %1  # 将作业1放到后台"

echo -e "\n将作业放到前台运行:"
echo "fg %1  # 将作业1放到前台"

echo -e "\n作业控制快捷键:"
echo "  Ctrl+Z - 暂停当前进程并放到后台"
echo "  Ctrl+C - 终止当前进程"
echo "  Ctrl+D - 发送EOF信号"
```

### nohup命令

nohup命令用于启动不受终端退出影响的进程。

```bash
#!/bin/bash

echo "=== nohup命令示例 ==="

echo "启动不受终端退出影响的进程:"
echo "nohup command &"

echo -e "\n输出重定向:"
echo "nohup command > output.log 2>&1 &"

echo -e "\n查看nohup进程:"
echo "ps aux | grep command"
```

## 系统资源监控

### uptime命令

uptime命令显示系统运行时间和负载平均值。

```bash
#!/bin/bash

echo "=== uptime命令示例 ==="

echo "基本用法:"
uptime

echo -e "\n输出说明:"
echo "  系统时间"
echo "  系统运行时间"
echo "  当前登录用户数"
echo "  系统负载平均值 (1分钟, 5分钟, 15分钟)"
```

### free命令

free命令显示系统内存使用情况。

```bash
#!/bin/bash

echo "=== free命令示例 ==="

echo "基本用法:"
free

echo -e "\n以人类可读格式显示:"
free -h

echo -e "\n显示总计行:"
free -t

echo -e "\n持续监控:"
echo "free -s 2  # 每2秒更新一次"
```

### vmstat命令

vmstat命令报告虚拟内存统计信息。

```bash
#!/bin/bash

echo "=== vmstat命令示例 ==="

echo "基本用法:"
vmstat

echo -e "\n指定间隔和次数:"
echo "vmstat 2 5  # 每2秒显示一次，共显示5次"

echo -e "\n显示详细信息:"
vmstat -s  # 显示内存统计数据
vmstat -d  # 显示磁盘统计数据
```

## 实际应用示例

### 进程监控脚本

```bash
#!/bin/bash

# 进程监控脚本
monitor_processes() {
    local process_name=$1
    local threshold=${2:-5}  # 默认CPU阈值为5%
    
    echo "=== 进程监控报告: $process_name ==="
    
    # 查找进程
    local pids=$(pgrep "$process_name")
    if [ -z "$pids" ]
    then
        echo "未找到进程: $process_name"
        return 1
    fi
    
    echo "找到进程ID: $pids"
    
    # 检查每个进程的资源使用情况
    for pid in $pids
    do
        # 获取进程信息
        local info=$(ps -p $pid -o pid,ppid,cmd,%cpu,%mem,etime --no-headers 2>/dev/null)
        if [ -n "$info" ]
        then
            echo "进程详情:"
            echo "$info"
            
            # 检查CPU使用率
            local cpu_usage=$(echo "$info" | awk '{print $4}')
            if (( $(echo "$cpu_usage > $threshold" | bc -l) ))
            then
                echo "警告: CPU使用率 ($cpu_usage%) 超过阈值 ($threshold%)"
            fi
            
            # 显示进程树
            echo "进程树:"
            pstree -p $pid
        fi
        echo "---"
    done
}

# 使用示例
# monitor_processes "bash" 1
```

### 系统资源监控脚本

```bash
#!/bin/bash

# 系统资源监控脚本
system_monitor() {
    local iterations=${1:-5}
    local interval=${2:-2}
    
    echo "=== 系统资源监控 ==="
    echo "监控次数: $iterations, 间隔: ${interval}秒"
    echo
    
    for i in $(seq 1 $iterations)
    do
        echo "--- 第 $i 次监控 (时间: $(date)) ---"
        
        # CPU使用率
        echo "CPU使用率:"
        top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1
        
        # 内存使用情况
        echo "内存使用情况:"
        free -h | grep Mem
        
        # 系统负载
        echo "系统负载:"
        uptime | awk -F'load average:' '{print $2}'
        
        # 磁盘使用情况
        echo "磁盘使用情况 (前3行):"
        df -h | head -3
        
        # 进程数
        echo "进程数: $(ps aux | wc -l)"
        
        echo
        if [ $i -lt $iterations ]
        then
            sleep $interval
        fi
    done
}

# 使用示例
# system_monitor 3 1
```

### 进程清理脚本

```bash
#!/bin/bash

# 僵尸进程清理脚本
cleanup_zombie_processes() {
    echo "=== 僵尸进程检查 ==="
    
    # 查找僵尸进程
    local zombie_processes=$(ps aux | awk '$8 ~ /^Z/ {print}')
    
    if [ -n "$zombie_processes" ]
    then
        echo "发现僵尸进程:"
        echo "$zombie_processes"
        
        # 获取僵尸进程的父进程
        echo "僵尸进程的父进程:"
        ps aux | awk '$8 ~ /^Z/ {print $2}' | while read pid
        do
            local ppid=$(ps -p $pid -o ppid= 2>/dev/null)
            if [ -n "$ppid" ]
            then
                echo "僵尸进程 $pid 的父进程: $ppid"
                ps -p $ppid -o pid,cmd 2>/dev/null
            fi
        done
    else
        echo "未发现僵尸进程"
    fi
}

# 长时间运行进程检查
check_long_running_processes() {
    local threshold=${1:-3600}  # 默认1小时(秒)
    
    echo "=== 长时间运行进程检查 (超过${threshold}秒) ==="
    
    ps -eo pid,cmd,etime,etime | awk -v threshold="$threshold" '
    NR>1 {
        # 解析运行时间
        etime = $3
        seconds = 0
        
        # 处理不同的时间格式
        if (etime ~ /-/) {
            # 包含天数的格式: days-hours:min:sec
            split(etime, parts, "-")
            days = parts[1]
            time_part = parts[2]
            split(time_part, time_parts, ":")
            hours = time_parts[1]
            minutes = time_parts[2]
            seconds = time_parts[3]
            total_seconds = days * 86400 + hours * 3600 + minutes * 60 + seconds
        } else {
            # 格式: hours:min:sec 或 min:sec
            split(etime, time_parts, ":")
            if (length(time_parts) == 3) {
                hours = time_parts[1]
                minutes = time_parts[2]
                seconds = time_parts[3]
                total_seconds = hours * 3600 + minutes * 60 + seconds
            } else if (length(time_parts) == 2) {
                minutes = time_parts[1]
                seconds = time_parts[2]
                total_seconds = minutes * 60 + seconds
            }
        }
        
        if (total_seconds > threshold) {
            print "进程 " $1 " (" $2 ") 已运行 " total_seconds " 秒"
        }
    }'
}

# 使用示例
# cleanup_zombie_processes
# check_long_running_processes 1800  # 检查运行超过30分钟的进程
```

## 最佳实践

1. **谨慎使用kill -9**：优先使用SIGTERM信号正常终止进程
2. **定期监控系统资源**：使用top、htop等工具监控系统性能
3. **合理设置进程优先级**：根据进程重要性调整nice值
4. **处理僵尸进程**：及时清理僵尸进程，查找并修复其父进程
5. **使用nohup运行长时间任务**：避免终端关闭导致任务中断
6. **后台运行耗时任务**：使用&将长时间运行的任务放到后台
7. **定期检查进程状态**：确保关键服务正常运行

## 总结

进程管理是系统管理的核心技能之一。通过本章的学习，你应该掌握了：

1. 进程查看命令（ps、pstree、top、htop）
2. 进程控制命令（kill、killall、pkill）
3. 进程优先级管理（nice、renice）
4. 后台进程管理（jobs、bg、fg、nohup）
5. 系统资源监控命令（uptime、free、vmstat）
6. 实际应用场景和最佳实践

熟练掌握这些进程管理命令，将帮助你更好地管理和优化系统性能。在下一章中，我们将学习系统信息命令，进一步增强系统诊断能力。