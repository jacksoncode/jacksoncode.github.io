# 系统维护脚本

## 系统维护脚本概述

系统维护是确保服务器和计算机系统稳定运行的关键任务。通过自动化脚本，我们可以定期执行系统检查、清理、备份等维护任务，减少人工干预，提高系统可靠性。本章将介绍一些常用的系统维护脚本实例。

## 系统监控脚本

### 系统资源监控脚本

```bash
#!/bin/bash

# 系统资源监控脚本
# 文件名: system_monitor.sh

# 配置参数
LOG_FILE="/var/log/system_monitor.log"
THRESHOLD_CPU=80
THRESHOLD_MEM=80
THRESHOLD_DISK=80

# 日志函数
log_message() {
    local level=$1
    local message=$2
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$level] $message" | tee -a "$LOG_FILE"
}

# 检查CPU使用率
check_cpu() {
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d'%' -f1)
    log_message "INFO" "CPU使用率: ${cpu_usage}%"
    
    if (( $(echo "$cpu_usage > $THRESHOLD_CPU" | bc -l) ))
    then
        log_message "WARNING" "CPU使用率过高: ${cpu_usage}% (阈值: ${THRESHOLD_CPU}%)"
    fi
}

# 检查内存使用率
check_memory() {
    local mem_usage=$(free | grep Mem | awk '{printf("%.0f", $3/$2 * 100.0)}')
    log_message "INFO" "内存使用率: ${mem_usage}%"
    
    if [ $mem_usage -gt $THRESHOLD_MEM ]
    then
        log_message "WARNING" "内存使用率过高: ${mem_usage}% (阈值: ${THRESHOLD_MEM}%)"
    fi
}

# 检查磁盘使用率
check_disk() {
    log_message "INFO" "磁盘使用情况:"
    df -h | grep -v tmpfs | while read line
    do
        log_message "INFO" "  $line"
        local usage=$(echo "$line" | awk '{print $5}' | sed 's/%//')
        local filesystem=$(echo "$line" | awk '{print $1}')
        
        if [ "$usage" != "Use" ] && [ $usage -gt $THRESHOLD_DISK ]
        then
            log_message "WARNING" "磁盘使用率过高: $filesystem ${usage}% (阈值: ${THRESHOLD_DISK}%)"
        fi
    done
}

# 检查系统负载
check_load() {
    local load_avg=$(uptime | awk -F'load average:' '{print $2}')
    local one_min_load=$(echo $load_avg | awk '{print $1}' | sed 's/,//')
    local cpu_cores=$(nproc)
    
    log_message "INFO" "系统负载: $load_avg"
    
    if (( $(echo "$one_min_load > $cpu_cores" | bc -l) ))
    then
        log_message "WARNING" "系统负载过高: ${one_min_load} (CPU核心数: ${cpu_cores})"
    fi
}

# 检查运行进程数
check_processes() {
    local process_count=$(ps aux | wc -l)
    local max_processes=$(ulimit -u)
    
    log_message "INFO" "运行进程数: $process_count (最大允许: $max_processes)"
    
    if [ $process_count -gt $((max_processes * 80 / 100)) ]
    then
        log_message "WARNING" "进程数接近上限: $process_count/$max_processes"
    fi
}

# 主函数
main() {
    log_message "INFO" "=== 系统监控开始 ==="
    
    check_cpu
    check_memory
    check_disk
    check_load
    check_processes
    
    log_message "INFO" "=== 系统监控结束 ==="
}

# 执行主函数
main "$@"
```

### 系统健康检查脚本

```bash
#!/bin/bash

# 系统健康检查脚本
# 文件名: health_check.sh

# 邮件配置（可选）
ADMIN_EMAIL="admin@example.com"
ENABLE_EMAIL=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 输出函数
print_status() {
    local status=$1
    local message=$2
    
    case $status in
        OK)
            echo -e "${GREEN}✓ OK${NC} $message"
            ;;
        WARNING)
            echo -e "${YELLOW}⚠ WARNING${NC} $message"
            ;;
        CRITICAL)
            echo -e "${RED}✗ CRITICAL${NC} $message"
            ;;
        *)
            echo "$message"
            ;;
    esac
}

# 检查系统服务
check_services() {
    local services=("sshd" "cron" "rsyslog")
    
    echo "=== 服务状态检查 ==="
    for service in "${services[@]}"
    do
        if systemctl is-active --quiet "$service" 2>/dev/null
        then
            print_status "OK" "$service 服务运行正常"
        else
            print_status "CRITICAL" "$service 服务未运行"
        fi
    done
    echo
}

# 检查磁盘空间
check_disk_space() {
    local threshold=80
    
    echo "=== 磁盘空间检查 ==="
    df -h | grep -v tmpfs | while read line
    do
        local usage=$(echo "$line" | awk '{print $5}' | sed 's/%//')
        local filesystem=$(echo "$line" | awk '{print $1}')
        
        if [ "$usage" != "Use" ]
        then
            if [ $usage -gt $threshold ]
            then
                print_status "CRITICAL" "$filesystem 使用率 ${usage}% (超过阈值 ${threshold}%)"
            elif [ $usage -gt $((threshold - 10)) ]
            then
                print_status "WARNING" "$filesystem 使用率 ${usage}%"
            else
                print_status "OK" "$filesystem 使用率 ${usage}%"
            fi
        fi
    done
    echo
}

# 检查内存使用
check_memory() {
    echo "=== 内存使用检查 ==="
    
    local mem_total=$(free -m | grep Mem | awk '{print $2}')
    local mem_used=$(free -m | grep Mem | awk '{print $3}')
    local mem_usage=$((mem_used * 100 / mem_total))
    
    if [ $mem_usage -gt 90 ]
    then
        print_status "CRITICAL" "内存使用率 ${mem_usage}% (${mem_used}MB/${mem_total}MB)"
    elif [ $mem_usage -gt 80 ]
    then
        print_status "WARNING" "内存使用率 ${mem_usage}% (${mem_used}MB/${mem_total}MB)"
    else
        print_status "OK" "内存使用率 ${mem_usage}% (${mem_used}MB/${mem_total}MB)"
    fi
    echo
}

# 检查CPU温度（如果有传感器）
check_temperature() {
    if command -v sensors &>/dev/null
    then
        echo "=== 系统温度检查 ==="
        sensors 2>/dev/null | grep -E "(Core|temp1)" | while read line
        do
            local temp=$(echo "$line" | grep -oE '[0-9]+\.[0-9]+' | head -1)
            if [ -n "$temp" ]
            then
                local temp_int=$(echo "$temp" | cut -d. -f1)
                if [ $temp_int -gt 80 ]
                then
                    print_status "CRITICAL" "$line"
                elif [ $temp_int -gt 70 ]
                then
                    print_status "WARNING" "$line"
                else
                    print_status "OK" "$line"
                fi
            fi
        done
        echo
    fi
}

# 检查登录用户
check_users() {
    echo "=== 用户登录检查 ==="
    
    local user_count=$(who | wc -l)
    print_status "OK" "当前登录用户数: $user_count"
    
    echo "登录用户详情:"
    who -u
    echo
}

# 检查系统更新（适用于Debian/Ubuntu系统）
check_updates() {
    if command -v apt &>/dev/null
    then
        echo "=== 系统更新检查 ==="
        local update_count=$(apt list --upgradable 2>/dev/null | grep -c upgradable)
        if [ $update_count -gt 0 ]
        then
            print_status "WARNING" "有 $update_count 个软件包可更新"
            if [ $update_count -gt 10 ]
            then
                print_status "CRITICAL" "建议尽快执行系统更新"
            fi
        else
            print_status "OK" "系统软件包已是最新版本"
        fi
        echo
    fi
}

# 发送邮件通知（可选）
send_notification() {
    local subject=$1
    local message=$2
    
    if [ "$ENABLE_EMAIL" = true ] && command -v mail &>/dev/null
    then
        echo "$message" | mail -s "$subject" "$ADMIN_EMAIL"
    fi
}

# 主函数
main() {
    echo "=================================="
    echo "        系统健康检查报告"
    echo "        检查时间: $(date)"
    echo "=================================="
    echo
    
    check_services
    check_disk_space
    check_memory
    check_temperature
    check_users
    check_updates
    
    echo "=================================="
    echo "        检查完成"
    echo "=================================="
}

# 执行主函数
main "$@"
```

## 系统清理脚本

### 日志清理脚本

```bash
#!/bin/bash

# 日志清理脚本
# 文件名: log_cleanup.sh

# 配置参数
LOG_DIRS=("/var/log" "/var/log/apache2" "/var/log/nginx")
MAX_AGE_DAYS=30
MAX_SIZE_GB=5
DRY_RUN=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# 显示帮助信息
show_help() {
    echo "日志清理脚本"
    echo "用法: $0 [选项]"
    echo "选项:"
    echo "  -d, --dry-run     试运行模式，不实际删除文件"
    echo "  -a, --age DAYS    设置日志文件最大保存天数 (默认: 30)"
    echo "  -s, --size GB     设置日志目录最大大小 (默认: 5GB)"
    echo "  -h, --help        显示此帮助信息"
    echo
    echo "示例:"
    echo "  $0                  # 使用默认参数执行清理"
    echo "  $0 -d              # 试运行模式"
    echo "  $0 -a 7 -s 10      # 保留7天日志，最大10GB"
}

# 解析命令行参数
parse_args() {
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -a|--age)
                MAX_AGE_DAYS="$2"
                shift 2
                ;;
            -s|--size)
                MAX_SIZE_GB="$2"
                shift 2
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# 检查磁盘使用情况
check_disk_usage() {
    local dir=$1
    local max_size_bytes=$((MAX_SIZE_GB * 1024 * 1024 * 1024))
    
    if [ ! -d "$dir" ]
    then
        log_warn "目录不存在: $dir"
        return 1
    fi
    
    local current_size=$(du -sb "$dir" 2>/dev/null | cut -f1)
    
    if [ -z "$current_size" ]
    then
        log_error "无法获取目录大小: $dir"
        return 1
    fi
    
    log_info "目录 $dir 当前大小: $(echo "scale=2; $current_size/1024/1024" | bc) MB"
    
    if [ $current_size -gt $max_size_bytes ]
    then
        local excess_size=$((current_size - max_size_bytes))
        log_warn "目录大小超过限制 ${MAX_SIZE_GB}GB，超出 $(echo "scale=2; $excess_size/1024/1024" | bc) MB"
        return 0
    else
        log_success "目录大小在限制范围内"
        return 1
    fi
}

# 清理旧日志文件
cleanup_old_logs() {
    local dir=$1
    local max_age=$MAX_AGE_DAYS
    
    if [ ! -d "$dir" ]
    then
        log_warn "目录不存在: $dir"
        return 1
    fi
    
    log_info "清理目录: $dir"
    
    # 查找并删除旧的压缩日志文件
    local old_compressed=$(find "$dir" -name "*.gz" -type f -mtime +$max_age 2>/dev/null)
    if [ -n "$old_compressed" ]
    then
        local count=$(echo "$old_compressed" | wc -l)
        log_info "找到 $count 个超过 ${max_age} 天的压缩日志文件"
        
        if [ "$DRY_RUN" = false ]
        then
            echo "$old_compressed" | while read file
            do
                if rm "$file" 2>/dev/null
                then
                    log_success "已删除: $file"
                else
                    log_error "删除失败: $file"
                fi
            done
        else
            echo "$old_compressed" | while read file
            do
                log_info "[试运行] 将删除: $file"
            done
        fi
    fi
    
    # 查找并删除旧的普通日志文件
    local old_logs=$(find "$dir" -name "*.log" -type f -mtime +$max_age 2>/dev/null)
    if [ -n "$old_logs" ]
    then
        local count=$(echo "$old_logs" | wc -l)
        log_info "找到 $count 个超过 ${max_age} 天的日志文件"
        
        if [ "$DRY_RUN" = false ]
        then
            echo "$old_logs" | while read file
            do
                if rm "$file" 2>/dev/null
                then
                    log_success "已删除: $file"
                else
                    log_error "删除失败: $file"
                fi
            done
        else
            echo "$old_logs" | while read file
            do
                log_info "[试运行] 将删除: $file"
            done
        fi
    fi
}

# 压缩旧日志文件
compress_old_logs() {
    local dir=$1
    local compress_age=7  # 7天前的日志进行压缩
    
    if [ ! -d "$dir" ]
    then
        log_warn "目录不存在: $dir"
        return 1
    fi
    
    log_info "压缩目录中的旧日志文件: $dir"
    
    # 查找7天前未压缩的日志文件
    local old_uncompressed=$(find "$dir" -name "*.log" -type f -mtime +$compress_age ! -name "*.gz" 2>/dev/null)
    if [ -n "$old_uncompressed" ]
    then
        local count=$(echo "$old_uncompressed" | wc -l)
        log_info "找到 $count 个超过 ${compress_age} 天的未压缩日志文件"
        
        if [ "$DRY_RUN" = false ]
        then
            echo "$old_uncompressed" | while read file
            do
                if gzip "$file" 2>/dev/null
                then
                    log_success "已压缩: $file"
                else
                    log_error "压缩失败: $file"
                fi
            done
        else
            echo "$old_uncompressed" | while read file
            do
                log_info "[试运行] 将压缩: $file"
            done
        fi
    fi
}

# 清理临时文件
cleanup_temp_files() {
    local temp_dirs=("/tmp" "/var/tmp")
    local max_temp_age=7
    
    log_info "清理临时文件"
    
    for temp_dir in "${temp_dirs[@]}"
    do
        if [ -d "$temp_dir" ]
        then
            log_info "清理临时目录: $temp_dir"
            
            # 删除旧的临时文件
            local old_temp=$(find "$temp_dir" -type f -mtime +$max_temp_age 2>/dev/null)
            if [ -n "$old_temp" ]
            then
                local count=$(echo "$old_temp" | wc -l)
                log_info "找到 $count 个超过 ${max_temp_age} 天的临时文件"
                
                if [ "$DRY_RUN" = false ]
                then
                    echo "$old_temp" | while read file
                    do
                        if rm "$file" 2>/dev/null
                        then
                            log_success "已删除临时文件: $file"
                        else
                            log_error "删除临时文件失败: $file"
                        fi
                    done
                else
                    echo "$old_temp" | while read file
                    do
                        log_info "[试运行] 将删除临时文件: $file"
                    done
                fi
            fi
            
            # 删除空的临时目录
            local empty_dirs=$(find "$temp_dir" -type d -empty 2>/dev/null)
            if [ -n "$empty_dirs" ]
            then
                local count=$(echo "$empty_dirs" | wc -l)
                log_info "找到 $count 个空的临时目录"
                
                if [ "$DRY_RUN" = false ]
                then
                    echo "$empty_dirs" | while read dir
                    do
                        if rmdir "$dir" 2>/dev/null
                        then
                            log_success "已删除空目录: $dir"
                        else
                            log_error "删除空目录失败: $dir"
                        fi
                    done
                else
                    echo "$empty_dirs" | while read dir
                    do
                        log_info "[试运行] 将删除空目录: $dir"
                    done
                fi
            fi
        fi
    done
}

# 主函数
main() {
    parse_args "$@"
    
    log_info "=== 日志清理脚本开始 ==="
    log_info "运行模式: $([ "$DRY_RUN" = true ] && echo "试运行" || echo "实际运行")"
    log_info "日志保留天数: $MAX_AGE_DAYS 天"
    log_info "日志目录大小限制: $MAX_SIZE_GB GB"
    log_info "开始时间: $(date)"
    log_info "========================"
    
    # 清理每个日志目录
    for log_dir in "${LOG_DIRS[@]}"
    do
        if [ -d "$log_dir" ]
        then
            log_info "处理日志目录: $log_dir"
            
            # 检查磁盘使用情况
            check_disk_usage "$log_dir"
            
            # 压缩旧日志
            compress_old_logs "$log_dir"
            
            # 清理旧日志
            cleanup_old_logs "$log_dir"
            
            log_info "完成处理日志目录: $log_dir"
            echo
        else
            log_warn "日志目录不存在: $log_dir"
        fi
    done
    
    # 清理临时文件
    cleanup_temp_files
    
    log_info "========================"
    log_info "=== 日志清理脚本结束 ==="
    log_info "结束时间: $(date)"
}

# 执行主函数
main "$@"
```

### 系统缓存清理脚本

```bash
#!/bin/bash

# 系统缓存清理脚本
# 文件名: cache_cleanup.sh

# 配置参数
DRY_RUN=false
VERBOSE=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# 显示帮助信息
show_help() {
    echo "系统缓存清理脚本"
    echo "用法: $0 [选项]"
    echo "选项:"
    echo "  -d, --dry-run     试运行模式，不实际清理缓存"
    echo "  -v, --verbose     详细输出模式"
    echo "  -h, --help        显示此帮助信息"
    echo
    echo "此脚本将清理以下缓存:"
    echo "  - 页面缓存 (page cache)"
    echo "  - dentries 和 inodes 缓存"
    echo "  - swap 缓冲区"
    echo "  - 应用程序缓存"
}

# 解析命令行参数
parse_args() {
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# 显示内存使用情况
show_memory_usage() {
    log_info "内存使用情况:"
    free -h | while read line
    do
        log_info "  $line"
    done
}

# 清理页面缓存
clear_page_cache() {
    if [ "$DRY_RUN" = false ]
    then
        sync  # 同步数据到磁盘
        echo 1 > /proc/sys/vm/drop_caches 2>/dev/null
        if [ $? -eq 0 ]
        then
            log_success "页面缓存已清理"
        else
            log_error "页面缓存清理失败 (可能需要root权限)"
        fi
    else
        log_info "[试运行] 将清理页面缓存"
    fi
}

# 清理dentries和inodes缓存
clear_dentry_inode_cache() {
    if [ "$DRY_RUN" = false ]
    then
        sync  # 同步数据到磁盘
        echo 2 > /proc/sys/vm/drop_caches 2>/dev/null
        if [ $? -eq 0 ]
        then
            log_success "dentries和inodes缓存已清理"
        else
            log_error "dentries和inodes缓存清理失败 (可能需要root权限)"
        fi
    else
        log_info "[试运行] 将清理dentries和inodes缓存"
    fi
}

# 清理所有缓存
clear_all_cache() {
    if [ "$DRY_RUN" = false ]
    then
        sync  # 同步数据到磁盘
        echo 3 > /proc/sys/vm/drop_caches 2>/dev/null
        if [ $? -eq 0 ]
        then
            log_success "所有缓存已清理"
        else
            log_error "所有缓存清理失败 (可能需要root权限)"
        fi
    else
        log_info "[试运行] 将清理所有缓存"
    fi
}

# 清理swap空间
clear_swap() {
    if [ "$DRY_RUN" = false ]
    then
        if swapon --show | grep -q .
        then
            log_info "正在清理swap空间..."
            swapoff -a && swapon -a 2>/dev/null
            if [ $? -eq 0 ]
            then
                log_success "swap空间已清理"
            else
                log_error "swap空间清理失败"
            fi
        else
            log_info "系统未使用swap空间"
        fi
    else
        if swapon --show | grep -q .
        then
            log_info "[试运行] 将清理swap空间"
        else
            log_info "[试运行] 系统未使用swap空间"
        fi
    fi
}

# 清理应用程序缓存
clear_app_cache() {
    log_info "清理应用程序缓存..."
    
    # 清理用户缓存
    local user_cache_dirs=("$HOME/.cache" "$HOME/.local/share/Trash")
    for cache_dir in "${user_cache_dirs[@]}"
    do
        if [ -d "$cache_dir" ]
        then
            local cache_size=$(du -sh "$cache_dir" 2>/dev/null | cut -f1)
            if [ "$DRY_RUN" = false ]
            then
                rm -rf "$cache_dir"/* 2>/dev/null
                if [ $? -eq 0 ]
                then
                    log_success "已清理 $cache_dir (约 $cache_size)"
                else
                    log_warn "部分文件清理失败: $cache_dir"
                fi
            else
                log_info "[试运行] 将清理 $cache_dir (约 $cache_size)"
            fi
        fi
    done
    
    # 清理浏览器缓存 (示例)
    local browser_cache_dirs=("$HOME/.mozilla/firefox" "$HOME/.config/google-chrome")
    for browser_dir in "${browser_cache_dirs[@]}"
    do
        if [ -d "$browser_dir" ]
        then
            local cache_dirs=$(find "$browser_dir" -name "Cache" -o -name "cache" 2>/dev/null)
            if [ -n "$cache_dirs" ]
            then
                echo "$cache_dirs" | while read cache_dir
                do
                    if [ -d "$cache_dir" ]
                    then
                        local cache_size=$(du -sh "$cache_dir" 2>/dev/null | cut -f1)
                        if [ "$DRY_RUN" = false ]
                        then
                            rm -rf "$cache_dir"/* 2>/dev/null
                            if [ $? -eq 0 ]
                            then
                                log_success "已清理浏览器缓存: $cache_dir (约 $cache_size)"
                            else
                                log_warn "浏览器缓存清理失败: $cache_dir"
                            fi
                        else
                            log_info "[试运行] 将清理浏览器缓存: $cache_dir (约 $cache_size)"
                        fi
                    fi
                done
            fi
        fi
    done
}

# 主函数
main() {
    parse_args "$@"
    
    log_info "=== 系统缓存清理脚本开始 ==="
    log_info "运行模式: $([ "$DRY_RUN" = true ] && echo "试运行" || echo "实际运行")"
    log_info "详细模式: $([ "$VERBOSE" = true ] && echo "开启" || echo "关闭")"
    log_info "开始时间: $(date)"
    log_info "=========================="
    
    # 显示清理前的内存使用情况
    log_info "清理前内存使用情况:"
    show_memory_usage
    
    echo
    
    # 清理各种缓存
    clear_page_cache
    clear_dentry_inode_cache
    clear_all_cache
    clear_swap
    clear_app_cache
    
    echo
    
    # 显示清理后的内存使用情况
    log_info "清理后内存使用情况:"
    show_memory_usage
    
    log_info "=========================="
    log_info "=== 系统缓存清理脚本结束 ==="
    log_info "结束时间: $(date)"
}

# 检查是否为root用户（部分操作需要）
check_root() {
    if [ "$EUID" -ne 0 ] && [ "$DRY_RUN" = false ]
    then
        log_warn "某些缓存清理操作需要root权限"
        log_info "建议以root身份运行或使用sudo"
    fi
}

# 执行主函数
check_root
main "$@"
```

## 定时任务设置

### 系统维护任务的crontab配置

```bash
# 系统维护任务的crontab配置示例
# 使用命令: crontab -e 编辑当前用户的crontab
# 使用命令: sudo crontab -e 编辑root用户的crontab

# 每天凌晨2点执行系统监控
0 2 * * * /usr/local/bin/system_monitor.sh

# 每小时检查系统健康状态
0 * * * * /usr/local/bin/health_check.sh

# 每周日凌晨3点执行日志清理
0 3 * * 0 /usr/local/bin/log_cleanup.sh -a 30 -s 10

# 每月1号凌晨4点执行缓存清理
0 4 1 * * /usr/local/bin/cache_cleanup.sh

# 每天凌晨1点检查磁盘空间并发送报告
0 1 * * * /usr/local/bin/disk_check.sh | mail -s "磁盘空间报告" admin@example.com

# 每5分钟检查关键服务状态
*/5 * * * * /usr/local/bin/service_check.sh

# 每天凌晨5点备份重要配置文件
0 5 * * * /usr/local/bin/config_backup.sh
```

## 最佳实践

1. **权限管理**：确保脚本具有适当的执行权限，敏感操作需要root权限
2. **日志记录**：详细记录脚本执行过程和结果，便于问题排查
3. **错误处理**：添加适当的错误处理机制，确保脚本稳定运行
4. **测试验证**：在生产环境使用前充分测试脚本
5. **定期更新**：根据系统变化定期更新维护脚本
6. **安全考虑**：避免在脚本中硬编码敏感信息
7. **资源控制**：避免脚本消耗过多系统资源
8. **通知机制**：设置适当的告警和通知机制

## 总结

系统维护脚本是保障系统稳定运行的重要工具。通过本章的学习，你应该掌握了：

1. 系统资源监控脚本的编写方法
2. 系统健康检查脚本的实现
3. 日志清理和缓存清理脚本的开发
4. 定时任务的配置和管理
5. 实际应用场景和最佳实践

这些脚本可以帮助你自动化系统维护工作，提高系统管理效率和可靠性。在下一章中，我们将学习文件管理脚本，进一步增强文件操作能力。

