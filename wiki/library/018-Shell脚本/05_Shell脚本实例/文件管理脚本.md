# 文件管理脚本

## 文件管理脚本概述

文件管理是系统管理中最基本也是最重要的任务之一。通过自动化脚本，我们可以高效地处理文件的创建、复制、移动、删除、备份等操作。本章将介绍一些实用的文件管理脚本实例。

## 文件备份脚本

### 基本备份脚本

```bash
#!/bin/bash

# 基本文件备份脚本
# 文件名: basic_backup.sh

# 配置参数
SOURCE_DIR=""
BACKUP_DIR=""
BACKUP_NAME=""
DRY_RUN=false
VERBOSE=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# 显示帮助信息
show_help() {
    echo "基本文件备份脚本"
    echo "用法: $0 [选项] -s <源目录> -b <备份目录>"
    echo "选项:"
    echo "  -s, --source DIR     指定要备份的源目录"
    echo "  -b, --backup DIR     指定备份目录"
    echo "  -n, --name NAME      指定备份名称 (默认: 自动生成)"
    echo "  -d, --dry-run        试运行模式，不实际执行备份"
    echo "  -v, --verbose        详细输出模式"
    echo "  -h, --help           显示此帮助信息"
    echo
    echo "示例:"
    echo "  $0 -s /home/user/documents -b /backup"
    echo "  $0 -s /var/www -b /backup -n website_backup"
}

# 解析命令行参数
parse_args() {
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -s|--source)
                SOURCE_DIR="$2"
                shift 2
                ;;
            -b|--backup)
                BACKUP_DIR="$2"
                shift 2
                ;;
            -n|--name)
                BACKUP_NAME="$2"
                shift 2
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# 验证参数
validate_args() {
    if [ -z "$SOURCE_DIR" ]
    then
        log_error "必须指定源目录 (-s 参数)"
        show_help
        exit 1
    fi
    
    if [ -z "$BACKUP_DIR" ]
    then
        log_error "必须指定备份目录 (-b 参数)"
        show_help
        exit 1
    fi
    
    if [ ! -d "$SOURCE_DIR" ]
    then
        log_error "源目录不存在: $SOURCE_DIR"
        exit 1
    fi
    
    if [ ! -d "$BACKUP_DIR" ]
    then
        if [ "$DRY_RUN" = false ]
        then
            log_info "创建备份目录: $BACKUP_DIR"
            mkdir -p "$BACKUP_DIR"
            if [ $? -ne 0 ]
            then
                log_error "无法创建备份目录: $BACKUP_DIR"
                exit 1
            fi
        else
            log_info "[试运行] 将创建备份目录: $BACKUP_DIR"
        fi
    fi
    
    if [ ! -w "$BACKUP_DIR" ]
    then
        log_error "备份目录不可写: $BACKUP_DIR"
        exit 1
    fi
    
    if [ -z "$BACKUP_NAME" ]
    then
        BACKUP_NAME="$(basename "$SOURCE_DIR")_$(date +%Y%m%d_%H%M%S)"
    fi
}

# 计算目录大小
calculate_size() {
    local dir=$1
    if command -v du &>/dev/null
    then
        du -sh "$dir" 2>/dev/null | cut -f1
    else
        echo "未知"
    fi
}

# 执行备份
perform_backup() {
    local source_size=$(calculate_size "$SOURCE_DIR")
    local backup_path="$BACKUP_DIR/$BACKUP_NAME.tar.gz"
    
    log_info "开始备份任务"
    log_info "源目录: $SOURCE_DIR ($source_size)"
    log_info "备份目录: $BACKUP_DIR"
    log_info "备份名称: $BACKUP_NAME"
    log_info "备份路径: $backup_path"
    
    if [ "$DRY_RUN" = false ]
    then
        log_info "正在执行备份..."
        
        # 使用tar创建压缩备份
        if tar -czf "$backup_path" -C "$(dirname "$SOURCE_DIR")" "$(basename "$SOURCE_DIR")" 2>/dev/null
        then
            local backup_size=$(calculate_size "$backup_path")
            log_success "备份完成: $backup_path ($backup_size)"
            
            # 记录备份信息
            echo "$(date): 备份 $SOURCE_DIR 到 $backup_path (大小: $backup_size)" >> "$BACKUP_DIR/backup.log"
        else
            log_error "备份失败"
            exit 1
        fi
    else
        log_info "[试运行] 将执行备份操作"
        log_info "[试运行] 命令: tar -czf $backup_path -C $(dirname "$SOURCE_DIR") $(basename "$SOURCE_DIR")"
    fi
}

# 主函数
main() {
    parse_args "$@"
    validate_args
    
    log_info "=== 基本文件备份脚本开始 ==="
    log_info "运行模式: $([ "$DRY_RUN" = true ] && echo "试运行" || echo "实际运行")"
    log_info "详细模式: $([ "$VERBOSE" = true ] && echo "开启" || echo "关闭")"
    log_info "开始时间: $(date)"
    log_info "=========================="
    
    perform_backup
    
    log_info "=========================="
    log_info "=== 基本文件备份脚本结束 ==="
    log_info "结束时间: $(date)"
}

# 执行主函数
main "$@"
```

### 增量备份脚本

```bash
#!/bin/bash

# 增量备份脚本
# 文件名: incremental_backup.sh

# 配置参数
SOURCE_DIR=""
BACKUP_DIR=""
FULL_BACKUP_INTERVAL=7  # 每7天进行一次完整备份
DRY_RUN=false
VERBOSE=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# 显示帮助信息
show_help() {
    echo "增量备份脚本"
    echo "用法: $0 [选项] -s <源目录> -b <备份目录>"
    echo "选项:"
    echo "  -s, --source DIR     指定要备份的源目录"
    echo "  -b, --backup DIR     指定备份目录"
    echo "  -i, --interval DAYS  完整备份间隔天数 (默认: 7)"
    echo "  -d, --dry-run        试运行模式，不实际执行备份"
    echo "  -v, --verbose        详细输出模式"
    echo "  -h, --help           显示此帮助信息"
    echo
    echo "说明:"
    echo "  此脚本使用rsync实现增量备份"
    echo "  完整备份: 创建源目录的完整副本"
    echo "  增量备份: 只备份发生变化的文件"
}

# 解析命令行参数
parse_args() {
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -s|--source)
                SOURCE_DIR="$2"
                shift 2
                ;;
            -b|--backup)
                BACKUP_DIR="$2"
                shift 2
                ;;
            -i|--interval)
                FULL_BACKUP_INTERVAL="$2"
                shift 2
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# 验证参数
validate_args() {
    if [ -z "$SOURCE_DIR" ]
    then
        log_error "必须指定源目录 (-s 参数)"
        show_help
        exit 1
    fi
    
    if [ -z "$BACKUP_DIR" ]
    then
        log_error "必须指定备份目录 (-b 参数)"
        show_help
        exit 1
    fi
    
    if [ ! -d "$SOURCE_DIR" ]
    then
        log_error "源目录不存在: $SOURCE_DIR"
        exit 1
    fi
    
    if [ ! -d "$BACKUP_DIR" ]
    then
        if [ "$DRY_RUN" = false ]
        then
            log_info "创建备份目录: $BACKUP_DIR"
            mkdir -p "$BACKUP_DIR"
            if [ $? -ne 0 ]
            then
                log_error "无法创建备份目录: $BACKUP_DIR"
                exit 1
            fi
        else
            log_info "[试运行] 将创建备份目录: $BACKUP_DIR"
        fi
    fi
    
    if [ ! -w "$BACKUP_DIR" ]
    then
        log_error "备份目录不可写: $BACKUP_DIR"
        exit 1
    fi
    
    # 检查rsync命令是否存在
    if ! command -v rsync &>/dev/null
    then
        log_error "rsync命令未安装"
        exit 1
    fi
}

# 检查是否需要完整备份
need_full_backup() {
    local last_full_backup=$(find "$BACKUP_DIR" -name "full_*" -type d 2>/dev/null | sort | tail -1)
    
    if [ -z "$last_full_backup" ]
    then
        log_info "未找到之前的完整备份，执行完整备份"
        return 0
    fi
    
    local last_backup_time=$(stat -c %Y "$last_full_backup" 2>/dev/null || stat -f %m "$last_full_backup" 2>/dev/null)
    local current_time=$(date +%s)
    local days_since_last=$(( (current_time - last_backup_time) / 86400 ))
    
    if [ $days_since_last -ge $FULL_BACKUP_INTERVAL ]
    then
        log_info "距离上次完整备份已过去 $days_since_last 天，执行完整备份"
        return 0
    else
        log_info "距离上次完整备份 $days_since_last 天，执行增量备份"
        return 1
    fi
}

# 执行完整备份
perform_full_backup() {
    local backup_name="full_$(date +%Y%m%d_%H%M%S)"
    local backup_path="$BACKUP_DIR/$backup_name"
    
    log_info "执行完整备份: $backup_name"
    
    if [ "$DRY_RUN" = false ]
    then
        # 使用rsync创建完整备份
        local rsync_opts="-av --delete"
        [ "$VERBOSE" = true ] && rsync_opts="$rsync_opts --progress"
        
        if rsync $rsync_opts "$SOURCE_DIR/" "$backup_path/"
        then
            log_success "完整备份完成: $backup_path"
            
            # 记录备份信息
            echo "$(date): 完整备份 $SOURCE_DIR 到 $backup_path" >> "$BACKUP_DIR/backup.log"
        else
            log_error "完整备份失败"
            exit 1
        fi
    else
        log_info "[试运行] 将执行完整备份到: $backup_path"
        log_info "[试运行] 命令: rsync -av --delete $SOURCE_DIR/ $backup_path/"
    fi
}

# 执行增量备份
perform_incremental_backup() {
    local latest_backup=$(find "$BACKUP_DIR" -name "full_*" -o -name "incremental_*" -type d 2>/dev/null | sort | tail -1)
    
    if [ -z "$latest_backup" ]
    then
        log_warn "未找到基准备份，执行完整备份"
        perform_full_backup
        return
    fi
    
    local backup_name="incremental_$(date +%Y%m%d_%H%M%S)"
    local backup_path="$BACKUP_DIR/$backup_name"
    
    log_info "执行增量备份: $backup_name"
    log_info "基准备份: $(basename "$latest_backup")"
    
    if [ "$DRY_RUN" = false ]
    then
        # 创建硬链接副本作为增量备份的基础
        if cp -al "$latest_backup" "$backup_path" 2>/dev/null
        then
            # 使用rsync更新变化的文件
            local rsync_opts="-av --delete"
            [ "$VERBOSE" = true ] && rsync_opts="$rsync_opts --progress"
            
            if rsync $rsync_opts "$SOURCE_DIR/" "$backup_path/"
            then
                log_success "增量备份完成: $backup_path"
                
                # 记录备份信息
                echo "$(date): 增量备份 $SOURCE_DIR 到 $backup_path (基于 $(basename "$latest_backup"))" >> "$BACKUP_DIR/backup.log"
            else
                log_error "增量备份同步失败"
                rm -rf "$backup_path" 2>/dev/null
                exit 1
            fi
        else
            log_error "创建增量备份基础失败"
            exit 1
        fi
    else
        log_info "[试运行] 将执行增量备份到: $backup_path"
        log_info "[试运行] 基于: $latest_backup"
        log_info "[试运行] 命令: cp -al $latest_backup $backup_path && rsync -av --delete $SOURCE_DIR/ $backup_path/"
    fi
}

# 清理旧备份（保留最新的3个完整备份和对应的增量备份）
cleanup_old_backups() {
    local keep_full=3
    
    log_info "清理旧备份文件"
    
    # 获取所有完整备份，按时间排序
    local full_backups=($(find "$BACKUP_DIR" -name "full_*" -type d 2>/dev/null | sort))
    local full_count=${#full_backups[@]}
    
    if [ $full_count -gt $keep_full ]
    then
        local to_remove_count=$((full_count - keep_full))
        log_info "需要清理 $to_remove_count 个旧的完整备份"
        
        for ((i=0; i<to_remove_count; i++))
        do
            local backup_to_remove="${full_backups[$i]}"
            local backup_basename=$(basename "$backup_to_remove")
            
            if [ "$DRY_RUN" = false ]
            then
                # 删除对应的增量备份
                local incremental_backups=$(find "$BACKUP_DIR" -name "incremental_*" -type d 2>/dev/null | grep "$backup_basename")
                if [ -n "$incremental_backups" ]
                then
                    echo "$incremental_backups" | while read inc_backup
                    do
                        rm -rf "$inc_backup" 2>/dev/null
                        if [ $? -eq 0 ]
                        then
                            log_success "已删除增量备份: $(basename "$inc_backup")"
                        else
                            log_error "删除增量备份失败: $(basename "$inc_backup")"
                        fi
                    done
                fi
                
                # 删除完整备份
                rm -rf "$backup_to_remove" 2>/dev/null
                if [ $? -eq 0 ]
                then
                    log_success "已删除完整备份: $backup_basename"
                else
                    log_error "删除完整备份失败: $backup_basename"
                fi
            else
                log_info "[试运行] 将删除完整备份: $backup_basename"
                local incremental_backups=$(find "$BACKUP_DIR" -name "incremental_*" -type d 2>/dev/null | grep "$backup_basename")
                if [ -n "$incremental_backups" ]
                then
                    echo "$incremental_backups" | while read inc_backup
                    do
                        log_info "[试运行] 将删除增量备份: $(basename "$inc_backup")"
                    done
                fi
            fi
        done
    else
        log_info "备份数量在保留范围内，无需清理"
    fi
}

# 显示备份状态
show_backup_status() {
    log_info "当前备份状态:"
    
    local full_backups=($(find "$BACKUP_DIR" -name "full_*" -type d 2>/dev/null | sort))
    local incremental_backups=($(find "$BACKUP_DIR" -name "incremental_*" -type d 2>/dev/null | sort))
    
    log_info "  完整备份数量: ${#full_backups[@]}"
    for backup in "${full_backups[@]}"
    do
        local size=$(du -sh "$backup" 2>/dev/null | cut -f1)
        local date=$(stat -c %y "$backup" 2>/dev/null | cut -d' ' -f1 || stat -f %Sm -t %Y-%m-%d "$backup" 2>/dev/null)
        log_info "    $(basename "$backup") - $size ($date)"
    done
    
    log_info "  增量备份数量: ${#incremental_backups[@]}"
    for backup in "${incremental_backups[@]}"
    do
        local size=$(du -sh "$backup" 2>/dev/null | cut -f1)
        local date=$(stat -c %y "$backup" 2>/dev/null | cut -d' ' -f1 || stat -f %Sm -t %Y-%m-%d "$backup" 2>/dev/null)
        log_info "    $(basename "$backup") - $size ($date)"
    done
}

# 主函数
main() {
    parse_args "$@"
    validate_args
    
    log_info "=== 增量备份脚本开始 ==="
    log_info "源目录: $SOURCE_DIR"
    log_info "备份目录: $BACKUP_DIR"
    log_info "完整备份间隔: $FULL_BACKUP_INTERVAL 天"
    log_info "运行模式: $([ "$DRY_RUN" = true ] && echo "试运行" || echo "实际运行")"
    log_info "详细模式: $([ "$VERBOSE" = true ] && echo "开启" || echo "关闭")"
    log_info "开始时间: $(date)"
    log_info "========================"
    
    # 显示当前备份状态
    show_backup_status
    echo
    
    # 执行备份
    if need_full_backup
    then
        perform_full_backup
    else
        perform_incremental_backup
    fi
    
    echo
    # 清理旧备份
    cleanup_old_backups
    
    echo
    # 显示更新后的备份状态
    show_backup_status
    
    log_info "========================"
    log_info "=== 增量备份脚本结束 ==="
    log_info "结束时间: $(date)"
}

# 执行主函数
main "$@"
```

## 文件同步脚本

### 双向同步脚本

```bash
#!/bin/bash

# 双向文件同步脚本
# 文件名: bidirectional_sync.sh

# 配置参数
DIR1=""
DIR2=""
DRY_RUN=false
VERBOSE=false
DELETE=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# 显示帮助信息
show_help() {
    echo "双向文件同步脚本"
    echo "用法: $0 [选项] <目录1> <目录2>"
    echo "选项:"
    echo "  -d, --dry-run        试运行模式，不实际执行同步"
    echo "  -v, --verbose        详细输出模式"
    echo "  -D, --delete         删除只存在于目标目录的文件"
    echo "  -h, --help           显示此帮助信息"
    echo
    echo "说明:"
    echo "  此脚本使用rsync实现两个目录间的双向同步"
    echo "  确保两个目录中的最新文件被保留"
    echo
    echo "示例:"
    echo "  $0 /home/user/docs /mnt/backup/docs"
    echo "  $0 -D /project1 /project2"
}

# 解析命令行参数
parse_args() {
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -D|--delete)
                DELETE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            -*)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
            *)
                if [ -z "$DIR1" ]
                then
                    DIR1="$1"
                elif [ -z "$DIR2" ]
                then
                    DIR2="$1"
                else
                    log_error "参数过多"
                    show_help
                    exit 1
                fi
                shift
                ;;
        esac
    done
}

# 验证参数
validate_args() {
    if [ -z "$DIR1" ] || [ -z "$DIR2" ]
    then
        log_error "必须指定两个目录"
        show_help
        exit 1
    fi
    
    if [ ! -d "$DIR1" ]
    then
        if [ "$DRY_RUN" = false ]
        then
            log_info "创建目录: $DIR1"
            mkdir -p "$DIR1"
            if [ $? -ne 0 ]
            then
                log_error "无法创建目录: $DIR1"
                exit 1
            fi
        else
            log_info "[试运行] 将创建目录: $DIR1"
        fi
    fi
    
    if [ ! -d "$DIR2" ]
    then
        if [ "$DRY_RUN" = false ]
        then
            log_info "创建目录: $DIR2"
            mkdir -p "$DIR2"
            if [ $? -ne 0 ]
            then
                log_error "无法创建目录: $DIR2"
                exit 1
            fi
        else
            log_info "[试运行] 将创建目录: $DIR2"
        fi
    fi
    
    if [ ! -r "$DIR1" ] || [ ! -w "$DIR1" ]
    then
        log_error "目录不可读写: $DIR1"
        exit 1
    fi
    
    if [ ! -r "$DIR2" ] || [ ! -w "$DIR2" ]
    then
        log_error "目录不可读写: $DIR2"
        exit 1
    fi
    
    # 检查rsync命令是否存在
    if ! command -v rsync &>/dev/null
    then
        log_error "rsync命令未安装"
        exit 1
    fi
}

# 计算目录差异
calculate_differences() {
    log_info "分析目录差异..."
    
    # 使用rsync的--itemize-changes选项来显示将要更改的文件
    local rsync_opts="-avn --itemize-changes"
    [ "$DELETE" = true ] && rsync_opts="$rsync_opts --delete"
    
    log_info "从 $DIR1 同步到 $DIR2 的更改:"
    rsync $rsync_opts "$DIR1/" "$DIR2/" | tail -n +2 | head -20
    
    log_info "从 $DIR2 同步到 $DIR1 的更改:"
    rsync $rsync_opts "$DIR2/" "$DIR1/" | tail -n +2 | head -20
}

# 执行双向同步
perform_bidirectional_sync() {
    log_info "开始双向同步"
    log_info "目录1: $DIR1"
    log_info "目录2: $DIR2"
    log_info "删除模式: $([ "$DELETE" = true ] && echo "开启" || echo "关闭")"
    
    # 构建rsync选项
    local rsync_opts="-av"
    [ "$VERBOSE" = true ] && rsync_opts="$rsync_opts --progress"
    [ "$DELETE" = true ] && rsync_opts="$rsync_opts --delete"
    [ "$DRY_RUN" = true ] && rsync_opts="$rsync_opts -n"
    
    # 第一次同步: DIR1 -> DIR2
    log_info "第一次同步: $DIR1 -> $DIR2"
    if rsync $rsync_opts "$DIR1/" "$DIR2/"
    then
        log_success "第一次同步完成"
    else
        log_error "第一次同步失败"
        exit 1
    fi
    
    # 第二次同步: DIR2 -> DIR1
    log_info "第二次同步: $DIR2 -> $DIR1"
    if rsync $rsync_opts "$DIR2/" "$DIR1/"
    then
        log_success "第二次同步完成"
    else
        log_error "第二次同步失败"
        exit 1
    fi
}

# 显示同步统计
show_sync_stats() {
    log_info "同步统计信息:"
    
    local dir1_size=$(du -sh "$DIR1" 2>/dev/null | cut -f1)
    local dir2_size=$(du -sh "$DIR2" 2>/dev/null | cut -f1)
    local dir1_files=$(find "$DIR1" -type f 2>/dev/null | wc -l)
    local dir2_files=$(find "$DIR2" -type f 2>/dev/null | wc -l)
    
    log_info "  $DIR1: $dir1_size ($dir1_files 个文件)"
    log_info "  $DIR2: $dir2_size ($dir2_files 个文件)"
}

# 主函数
main() {
    parse_args "$@"
    validate_args
    
    log_info "=== 双向文件同步脚本开始 ==="
    log_info "运行模式: $([ "$DRY_RUN" = true ] && echo "试运行" || echo "实际运行")"
    log_info "详细模式: $([ "$VERBOSE" = true ] && echo "开启" || echo "关闭")"
    log_info "开始时间: $(date)"
    log_info "=========================="
    
    # 显示同步前统计
    log_info "同步前状态:"
    show_sync_stats
    echo
    
    # 计算差异（仅在详细模式下）
    if [ "$VERBOSE" = true ]
    then
        calculate_differences
        echo
    fi
    
    # 执行同步
    perform_bidirectional_sync
    
    echo
    # 显示同步后统计
    log_info "同步后状态:"
    show_sync_stats
    
    log_info "=========================="
    log_info "=== 双向文件同步脚本结束 ==="
    log_info "结束时间: $(date)"
}

# 执行主函数
main "$@"
```

## 文件整理脚本

### 媒体文件整理脚本

```bash
#!/bin/bash

# 媒体文件整理脚本
# 文件名: media_organizer.sh

# 配置参数
SOURCE_DIR=""
TARGET_DIR=""
DRY_RUN=false
VERBOSE=false

# 文件类型定义
IMAGE_EXTENSIONS=("jpg" "jpeg" "png" "gif" "bmp" "tiff" "webp")
VIDEO_EXTENSIONS=("mp4" "avi" "mkv" "mov" "wmv" "flv" "webm" "m4v")
AUDIO_EXTENSIONS=("mp3" "wav" "flac" "aac" "ogg" "wma" "m4a")
DOCUMENT_EXTENSIONS=("pdf" "doc" "docx" "txt" "rtf" "odt" "xls" "xlsx" "ppt" "pptx")

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# 显示帮助信息
show_help() {
    echo "媒体文件整理脚本"
    echo "用法: $0 [选项] -s <源目录> -t <目标目录>"
    echo "选项:"
    echo "  -s, --source DIR     指定要整理的源目录"
    echo "  -t, --target DIR     指定整理后的目标目录"
    echo "  -d, --dry-run        试运行模式，不实际移动文件"
    echo "  -v, --verbose        详细输出模式"
    echo "  -h, --help           显示此帮助信息"
    echo
    echo "说明:"
    echo "  此脚本将源目录中的媒体文件按类型整理到目标目录"
    echo "  文件将被移动到以下子目录:"
    echo "    images/  - 图片文件"
    echo "    videos/  - 视频文件"
    echo "    audio/   - 音频文件"
    echo "    documents/ - 文档文件"
    echo "    others/  - 其他文件"
}

# 解析命令行参数
parse_args() {
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -s|--source)
                SOURCE_DIR="$2"
                shift 2
                ;;
            -t|--target)
                TARGET_DIR="$2"
                shift 2
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# 验证参数
validate_args() {
    if [ -z "$SOURCE_DIR" ]
    then
        log_error "必须指定源目录 (-s 参数)"
        show_help
        exit 1
    fi
    
    if [ -z "$TARGET_DIR" ]
    then
        log_error "必须指定目标目录 (-t 参数)"
        show_help
        exit 1
    fi
    
    if [ ! -d "$SOURCE_DIR" ]
    then
        log_error "源目录不存在: $SOURCE_DIR"
        exit 1
    fi
    
    if [ ! -d "$TARGET_DIR" ]
    then
        if [ "$DRY_RUN" = false ]
        then
            log_info "创建目标目录: $TARGET_DIR"
            mkdir -p "$TARGET_DIR"
            if [ $? -ne 0 ]
            then
                log_error "无法创建目标目录: $TARGET_DIR"
                exit 1
            fi
        else
            log_info "[试运行] 将创建目标目录: $TARGET_DIR"
        fi
    fi
    
    if [ ! -w "$TARGET_DIR" ]
    then
        log_error "目标目录不可写: $TARGET_DIR"
        exit 1
    fi
}

# 获取文件扩展名
get_file_extension() {
    local filename=$(basename "$1")
    echo "${filename##*.}" | tr '[:upper:]' '[:lower:]'
}

# 确定文件类型
get_file_type() {
    local extension=$1
    
    # 检查图片文件
    for img_ext in "${IMAGE_EXTENSIONS[@]}"
    do
        if [ "$extension" = "$img_ext" ]
        then
            echo "images"
            return
        fi
    done
    
    # 检查视频文件
    for vid_ext in "${VIDEO_EXTENSIONS[@]}"
    do
        if [ "$extension" = "$vid_ext" ]
        then
            echo "videos"
            return
        fi
    done
    
    # 检查音频文件
    for aud_ext in "${AUDIO_EXTENSIONS[@]}"
    do
        if [ "$extension" = "$aud_ext" ]
        then
            echo "audio"
            return
        fi
    done
    
    # 检查文档文件
    for doc_ext in "${DOCUMENT_EXTENSIONS[@]}"
    do
        if [ "$extension" = "$doc_ext" ]
        then
            echo "documents"
            return
        fi
    done
    
    # 其他文件
    echo "others"
}

# 创建目标子目录
create_target_subdirs() {
    local subdirs=("images" "videos" "audio" "documents" "others")
    
    for subdir in "${subdirs[@]}"
    do
        local full_path="$TARGET_DIR/$subdir"
        if [ ! -d "$full_path" ]
        then
            if [ "$DRY_RUN" = false ]
            then
                mkdir -p "$full_path"
                if [ $? -eq 0 ]
                then
                    [ "$VERBOSE" = true ] && log_info "创建目录: $full_path"
                else
                    log_error "无法创建目录: $full_path"
                fi
            else
                log_info "[试运行] 将创建目录: $full_path"
            fi
        fi
    done
}

# 整理文件
organize_files() {
    log_info "开始整理文件"
    log_info "源目录: $SOURCE_DIR"
    log_info "目标目录: $TARGET_DIR"
    
    local file_count=0
    local move_count=0
    
    # 创建目标子目录
    create_target_subdirs
    
    # 遍历源目录中的所有文件
    find "$SOURCE_DIR" -type f -not -path "*/.*" | while read file
    do
        file_count=$((file_count + 1))
        
        local filename=$(basename "$file")
        local extension=$(get_file_extension "$file")
        local file_type=$(get_file_type "$extension")
        local target_path="$TARGET_DIR/$file_type/$filename"
        
        # 检查目标文件是否已存在
        if [ -f "$target_path" ]
        then
            local source_mtime=$(stat -c %Y "$file" 2>/dev/null || stat -f %m "$file" 2>/dev/null)
            local target_mtime=$(stat -c %Y "$target_path" 2>/dev/null || stat -f %m "$target_path" 2>/dev/null)
            
            # 如果源文件更新，则覆盖
            if [ "$source_mtime" -gt "$target_mtime" ]
            then
                if [ "$DRY_RUN" = false ]
                then
                    mv "$file" "$target_path" 2>/dev/null
                    if [ $? -eq 0 ]
                    then
                        move_count=$((move_count + 1))
                        [ "$VERBOSE" = true ] && log_success "移动并覆盖: $filename -> $file_type/"
                    else
                        log_error "移动失败: $filename"
                    fi
                else
                    log_info "[试运行] 将移动并覆盖: $filename -> $file_type/"
                    move_count=$((move_count + 1))
                fi
            else
                [ "$VERBOSE" = true ] && log_info "跳过 (目标文件更新): $filename"
            fi
        else
            # 目标文件不存在，直接移动
            if [ "$DRY_RUN" = false ]
            then
                mv "$file" "$target_path" 2>/dev/null
                if [ $? -eq 0 ]
                then
                    move_count=$((move_count + 1))
                    [ "$VERBOSE" = true ] && log_success "移动: $filename -> $file_type/"
                else
                    log_error "移动失败: $filename"
                fi
            else
                log_info "[试运行] 将移动: $filename -> $file_type/"
                move_count=$((move_count + 1))
            fi
        fi
    done
    
    # 注意：由于在管道中执行，变量不会传递出来
    # 这里只是演示逻辑，实际使用中需要调整
    log_info "处理完成"
}

# 显示整理结果
show_results() {
    log_info "整理结果:"
    
    local total_files=$(find "$SOURCE_DIR" -type f -not -path "*/.*" 2>/dev/null | wc -l)
    local images_count=$(find "$TARGET_DIR/images" -type f 2>/dev/null | wc -l)
    local videos_count=$(find "$TARGET_DIR/videos" -type f 2>/dev/null | wc -l)
    local audio_count=$(find "$TARGET_DIR/audio" -type f 2>/dev/null | wc -l)
    local documents_count=$(find "$TARGET_DIR/documents" -type f 2>/dev/null | wc -l)
    local others_count=$(find "$TARGET_DIR/others" -type f 2>/dev/null | wc -l)
    
    log_info "  总文件数: $total_files"
    log_info "  图片文件: $images_count"
    log_info "  视频文件: $videos_count"
    log_info "  音频文件: $audio_count"
    log_info "  文档文件: $documents_count"
    log_info "  其他文件: $others_count"
}

# 主函数
main() {
    parse_args "$@"
    validate_args
    
    log_info "=== 媒体文件整理脚本开始 ==="
    log_info "运行模式: $([ "$DRY_RUN" = true ] && echo "试运行" || echo "实际运行")"
    log_info "详细模式: $([ "$VERBOSE" = true ] && echo "开启" || echo "关闭")"
    log_info "开始时间: $(date)"
    log_info "=========================="
    
    # 显示整理前状态
    log_info "整理前状态:"
    local source_file_count=$(find "$SOURCE_DIR" -type f -not -path "*/.*" 2>/dev/null | wc -l)
    log_info "  源目录文件数: $source_file_count"
    echo
    
    # 执行整理
    organize_files
    
    echo
    # 显示整理结果
    show_results
    
    log_info "=========================="
    log_info "=== 媒体文件整理脚本结束 ==="
    log_info "结束时间: $(date)"
}

# 执行主函数
main "$@"
```

## 文件搜索和批量处理脚本

### 高级文件搜索脚本

```bash
#!/bin/bash

# 高级文件搜索脚本
# 文件名: advanced_find.sh

# 配置参数
SEARCH_DIR="."
PATTERN=""
FILE_TYPE=""
SIZE_CONDITION=""
DATE_CONDITION=""
MAX_DEPTH=""
EXEC_ACTION=""
DRY_RUN=false
VERBOSE=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# 显示帮助信息
show_help() {
    echo "高级文件搜索脚本"
    echo "用法: $0 [选项] [搜索模式]"
    echo "选项:"
    echo "  -d, --dir DIR        指定搜索目录 (默认: 当前目录)"
    echo "  -t, --type TYPE      指定文件类型 (f=普通文件, d=目录, l=链接)"
    echo "  -s, --size SIZE      指定文件大小条件 (+100M, -1G, 500k等)"
    echo "  -m, --mtime DAYS     指定修改时间条件 (+7, -30等)"
    echo "  -D, --depth LEVEL    限制搜索深度"
    echo "  -e, --exec ACTION    对找到的文件执行操作 (delete, chmod, chown等)"
    echo "  -n, --dry-run        试运行模式，不实际执行操作"
    echo "  -v, --verbose        详细输出模式"
    echo "  -h, --help           显示此帮助信息"
    echo
    echo "搜索模式:"
    echo "  可以是文件名模式 (支持通配符) 或正则表达式"
    echo
    echo "示例:"
    echo "  $0 \"*.log\" -d /var/log -t f -s +10M"
    echo "  $0 -d /home -m +30 -e delete"
    echo "  $0 \"*.sh\" -d /project -t f -e \"chmod +x {}\""
}

# 解析命令行参数
parse_args() {
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -d|--dir)
                SEARCH_DIR="$2"
                shift 2
                ;;
            -t|--type)
                FILE_TYPE="$2"
                shift 2
                ;;
            -s|--size)
                SIZE_CONDITION="$2"
                shift 2
                ;;
            -m|--mtime)
                DATE_CONDITION="$2"
                shift 2
                ;;
            -D|--depth)
                MAX_DEPTH="$2"
                shift 2
                ;;
            -e|--exec)
                EXEC_ACTION="$2"
                shift 2
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            -*)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
            *)
                if [ -z "$PATTERN" ]
                then
                    PATTERN="$1"
                else
                    log_error "参数过多"
                    show_help
                    exit 1
                fi
                shift
                ;;
        esac
    done
}

# 验证参数
validate_args() {
    if [ ! -d "$SEARCH_DIR" ]
    then
        log_error "搜索目录不存在: $SEARCH_DIR"
        exit 1
    fi
    
    if [ ! -r "$SEARCH_DIR" ]
    then
        log_error "搜索目录不可读: $SEARCH_DIR"
        exit 1
    fi
    
    # 验证文件类型
    if [ -n "$FILE_TYPE" ] && [[ ! "$FILE_TYPE" =~ ^[fdl]$ ]]
    then
        log_error "无效的文件类型: $FILE_TYPE (应为 f, d, 或 l)"
        exit 1
    fi
    
    # 验证大小条件
    if [ -n "$SIZE_CONDITION" ] && [[ ! "$SIZE_CONDITION" =~ ^[+-]?[0-9]+[kKmMgG]?$ ]]
    then
        log_error "无效的大小条件: $SIZE_CONDITION"
        exit 1
    fi
}

# 构建find命令
build_find_command() {
    local find_cmd="find \"$SEARCH_DIR\""
    
    # 添加深度限制
    if [ -n "$MAX_DEPTH" ]
    then
        find_cmd="$find_cmd -maxdepth $MAX_DEPTH"
    fi
    
    # 添加文件类型
    if [ -n "$FILE_TYPE" ]
    then
        case $FILE_TYPE in
            f) find_cmd="$find_cmd -type f" ;;
            d) find_cmd="$find_cmd -type d" ;;
            l) find_cmd="$find_cmd -type l" ;;
        esac
    fi
    
    # 添加大小条件
    if [ -n "$SIZE_CONDITION" ]
    then
        find_cmd="$find_cmd -size $SIZE_CONDITION"
    fi
    
    # 添加时间条件
    if [ -n "$DATE_CONDITION" ]
    then
        find_cmd="$find_cmd -mtime $DATE_CONDITION"
    fi
    
    # 添加名称模式
    if [ -n "$PATTERN" ]
    then
        find_cmd="$find_cmd -name \"$PATTERN\""
    fi
    
    echo "$find_cmd"
}

# 执行搜索
perform_search() {
    local find_cmd=$(build_find_command)
    
    log_info "执行搜索命令:"
    log_info "  $find_cmd"
    
    if [ "$VERBOSE" = true ]
    then
        log_info "搜索结果:"
        eval "$find_cmd" | while read file
        do
            local file_size=$(du -h "$file" 2>/dev/null | cut -f1)
            local file_mtime=$(stat -c %y "$file" 2>/dev/null | cut -d' ' -f1 || stat -f %Sm -t %Y-%m-%d "$file" 2>/dev/null)
            echo "  $file (大小: $file_size, 修改时间: $file_mtime)"
        done
    else
        eval "$find_cmd"
    fi
}

# 执行操作
execute_action() {
    if [ -z "$EXEC_ACTION" ]
    then
        return
    fi
    
    local find_cmd=$(build_find_command)
    
    log_info "执行操作: $EXEC_ACTION"
    
    case $EXEC_ACTION in
        delete)
            if [ "$DRY_RUN" = false ]
            then
                log_warn "即将删除文件，确认吗? (y/N)"
                read -r confirm
                if [[ $confirm =~ ^[Yy]$ ]]
                then
                    eval "$find_cmd -delete"
                    log_success "文件已删除"
                else
                    log_info "操作已取消"
                fi
            else
                log_info "[试运行] 将删除找到的文件"
                eval "$find_cmd" | while read file
                do
                    log_info "[试运行] 将删除: $file"
                done
            fi
            ;;
        *)
            # 自定义命令
            if [ "$DRY_RUN" = false ]
            then
                eval "$find_cmd -exec $EXEC_ACTION \;"
            else
                log_info "[试运行] 将执行命令: $EXEC_ACTION"
                eval "$find_cmd" | while read file
                do
                    local cmd=${EXEC_ACTION/\{\}/$file}
                    log_info "[试运行] 将执行: $cmd"
                done
            fi
            ;;
    esac
}

# 显示统计信息
show_statistics() {
    local find_cmd=$(build_find_command)
    local file_count=$(eval "$find_cmd" | wc -l)
    
    log_info "搜索统计:"
    log_info "  找到文件数: $file_count"
    
    if [ $file_count -gt 0 ] && [ "$VERBOSE" = true ]
    then
        local total_size=$(eval "$find_cmd" -exec du -b {} \; 2>/dev/null | awk '{sum += $1} END {print sum}')
        if [ -n "$total_size" ]
        then
            local human_size=$(echo "$total_size" | awk '{
                if ($1 > 1073741824) printf "%.2f GB", $1/1073741824
                else if ($1 > 1048576) printf "%.2f MB", $1/1048576
                else if ($1 > 1024) printf "%.2f KB", $1/1024
                else printf "%d B", $1
            }')
            log_info "  总大小: $human_size"
        fi
    fi
}

# 主函数
main() {
    parse_args "$@"
    validate_args
    
    log_info "=== 高级文件搜索脚本开始 ==="
    log_info "搜索目录: $SEARCH_DIR"
    log_info "文件模式: $PATTERN"
    log_info "运行模式: $([ "$DRY_RUN" = true ] && echo "试运行" || echo "实际运行")"
    log_info "详细模式: $([ "$VERBOSE" = true ] && echo "开启" || echo "关闭")"
    log_info "开始时间: $(date)"
    log_info "=========================="
    
    # 执行搜索
    perform_search
    
    echo
    # 显示统计信息
    show_statistics
    
    echo
    # 执行操作
    execute_action
    
    log_info "=========================="
    log_info "=== 高级文件搜索脚本结束 ==="
    log_info "结束时间: $(date)"
}

# 执行主函数
main "$@"
```

## 最佳实践

1. **备份重要文件**：在执行文件操作前，确保重要文件已备份
2. **权限检查**：验证脚本对相关目录和文件的读写权限
3. **错误处理**：添加适当的错误处理机制，确保脚本稳定运行
4. **日志记录**：详细记录文件操作过程，便于问题排查
5. **测试验证**：在生产环境使用前充分测试脚本
6. **安全考虑**：避免在脚本中硬编码敏感信息，谨慎使用删除操作
7. **资源控制**：避免脚本消耗过多系统资源
8. **用户确认**：对于破坏性操作，添加用户确认步骤

## 总结

文件管理脚本是系统管理中的重要工具。通过本章的学习，你应该掌握了：

1. 基本备份脚本和增量备份脚本的编写方法
2. 双向文件同步脚本的实现
3. 媒体文件整理脚本的开发
4. 高级文件搜索和批量处理脚本的使用
5. 实际应用场景和最佳实践

这些脚本可以帮助你高效地管理文件，提高工作效率。在下一章中，我们将学习网络管理脚本，进一步增强网络操作能力。

