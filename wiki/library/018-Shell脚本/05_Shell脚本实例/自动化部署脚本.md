# 自动化部署脚本

## 自动化部署脚本概述

自动化部署是现代软件开发和运维的重要实践，它能够显著提高部署效率、减少人为错误、确保部署一致性。通过Shell脚本，我们可以自动化执行从代码获取、环境配置、应用部署到服务启动的整个流程。本章将介绍一些实用的自动化部署脚本实例。

## 基础部署脚本

### Web应用部署脚本

```bash
#!/bin/bash

# Web应用自动化部署脚本
# 文件名: web_deploy.sh

# 配置参数
APP_NAME="myapp"
APP_SOURCE=""
DEPLOY_DIR="/var/www/$APP_NAME"
BACKUP_DIR="/var/backups/$APP_NAME"
GIT_REPO=""
GIT_BRANCH="main"
WEB_USER="www-data"
WEB_GROUP="www-data"
RESTART_SERVICE="nginx"
DRY_RUN=false
VERBOSE=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_message() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${timestamp} [${level}] ${message}"
}

log_info() {
    log_message "${BLUE}INFO${NC}" "$1" | tee -a "$LOG_FILE"
}

log_warn() {
    log_message "${YELLOW}WARN${NC}" "$1" | tee -a "$LOG_FILE"
}

log_error() {
    log_message "${RED}ERROR${NC}" "$1" | tee -a "$LOG_FILE"
}

log_success() {
    log_message "${GREEN}SUCCESS${NC}" "$1" | tee -a "$LOG_FILE"
}

# 显示帮助信息
show_help() {
    echo "Web应用自动化部署脚本"
    echo "用法: $0 [选项]"
    echo
    echo "选项:"
    echo "  -a, --app NAME        应用名称"
    echo "  -s, --source PATH     应用源码路径"
    echo "  -d, --deploy DIR      部署目录 (默认: /var/www/APP_NAME)"
    echo "  -r, --repo URL        Git仓库URL"
    echo "  -b, --branch BRANCH   Git分支 (默认: main)"
    echo "  -u, --user USER       Web服务器用户 (默认: www-data)"
    echo "  -g, --group GROUP     Web服务器组 (默认: www-data)"
    echo "  -S, --service SVC     重启的服务 (默认: nginx)"
    echo "  -B, --backup DIR      备份目录 (默认: /var/backups/APP_NAME)"
    echo "  -n, --dry-run         试运行模式，不实际执行部署"
    echo "  -v, --verbose         详细输出模式"
    echo "  -h, --help            显示此帮助信息"
    echo
    echo "示例:"
    echo "  $0 -r https://github.com/user/myapp.git"
    echo "  $0 -s /tmp/myapp -d /var/www/myapp -S apache2"
    echo "  $0 -r https://github.com/user/myapp.git -b develop -n"
}

# 解析命令行参数
parse_args() {
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -a|--app)
                APP_NAME="$2"
                DEPLOY_DIR="/var/www/$APP_NAME"
                BACKUP_DIR="/var/backups/$APP_NAME"
                shift 2
                ;;
            -s|--source)
                APP_SOURCE="$2"
                shift 2
                ;;
            -d|--deploy)
                DEPLOY_DIR="$2"
                shift 2
                ;;
            -r|--repo)
                GIT_REPO="$2"
                shift 2
                ;;
            -b|--branch)
                GIT_BRANCH="$2"
                shift 2
                ;;
            -u|--user)
                WEB_USER="$2"
                shift 2
                ;;
            -g|--group)
                WEB_GROUP="$2"
                shift 2
                ;;
            -S|--service)
                RESTART_SERVICE="$2"
                shift 2
                ;;
            -B|--backup)
                BACKUP_DIR="$2"
                shift 2
                ;;
            -n|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# 验证权限
check_permissions() {
    if [ "$EUID" -ne 0 ]
    then
        log_warn "此脚本建议以root权限运行以确保部署成功"
    fi
}

# 验证依赖
check_dependencies() {
    local dependencies=("git" "rsync" "nginx")
    
    for dep in "${dependencies[@]}"
    do
        if ! command -v "$dep" &>/dev/null
        then
            log_warn "依赖命令未安装: $dep"
            if [ "$dep" = "nginx" ] && [ -n "$RESTART_SERVICE" ]
            then
                log_info "检查服务命令: $RESTART_SERVICE"
                if ! command -v "systemctl" &>/dev/null && ! command -v "service" &>/dev/null
                then
                    log_error "未找到服务管理命令"
                    exit 1
                fi
            fi
        fi
    done
}

# 创建目录
create_directories() {
    local dirs=("$DEPLOY_DIR" "$BACKUP_DIR")
    
    for dir in "${dirs[@]}"
    do
        if [ ! -d "$dir" ]
        then
            if [ "$DRY_RUN" = false ]
            then
                mkdir -p "$dir"
                if [ $? -eq 0 ]
                then
                    log_success "创建目录: $dir"
                else
                    log_error "创建目录失败: $dir"
                    exit 1
                fi
            else
                log_info "[试运行] 将创建目录: $dir"
            fi
        fi
    done
}

# 备份当前部署
backup_current_deployment() {
    if [ -d "$DEPLOY_DIR" ] && [ "$(ls -A $DEPLOY_DIR)" ]
    then
        local backup_name="backup_$(date +%Y%m%d_%H%M%S)"
        local backup_path="$BACKUP_DIR/$backup_name"
        
        if [ "$DRY_RUN" = false ]
        then
            if cp -r "$DEPLOY_DIR" "$backup_path"
            then
                log_success "当前部署已备份到: $backup_path"
            else
                log_error "备份失败"
                exit 1
            fi
        else
            log_info "[试运行] 将备份当前部署到: $backup_path"
        fi
    else
        log_info "部署目录为空，无需备份"
    fi
}

# 获取应用源码
get_application_source() {
    if [ -n "$GIT_REPO" ]
    then
        # 从Git仓库获取源码
        log_info "从Git仓库获取源码: $GIT_REPO ($GIT_BRANCH)"
        
        local temp_dir="/tmp/${APP_NAME}_deploy_$$"
        
        if [ "$DRY_RUN" = false ]
        then
            # 克隆仓库
            if git clone --branch "$GIT_BRANCH" --single-branch "$GIT_REPO" "$temp_dir"
            then
                log_success "源码克隆成功"
                APP_SOURCE="$temp_dir"
            else
                log_error "源码克隆失败"
                exit 1
            fi
        else
            log_info "[试运行] 将克隆仓库: $GIT_REPO (分支: $GIT_BRANCH)"
            # 模拟源码路径
            APP_SOURCE="$temp_dir"
        fi
    elif [ -z "$APP_SOURCE" ]
    then
        log_error "必须指定源码路径 (-s) 或Git仓库 (-r)"
        exit 1
    fi
    
    # 验证源码路径
    if [ ! -d "$APP_SOURCE" ]
    then
        log_error "源码路径不存在: $APP_SOURCE"
        exit 1
    fi
}

# 部署应用
deploy_application() {
    log_info "开始部署应用到: $DEPLOY_DIR"
    
    if [ "$DRY_RUN" = false ]
    then
        # 同步文件
        if rsync -av --delete "$APP_SOURCE/" "$DEPLOY_DIR/"
        then
            log_success "应用部署完成"
        else
            log_error "应用部署失败"
            exit 1
        fi
        
        # 设置权限
        if chown -R "$WEB_USER:$WEB_GROUP" "$DEPLOY_DIR"
        then
            log_success "权限设置完成"
        else
            log_warn "权限设置失败"
        fi
    else
        log_info "[试运行] 将部署应用到: $DEPLOY_DIR"
        log_info "[试运行] 命令: rsync -av --delete $APP_SOURCE/ $DEPLOY_DIR/"
        log_info "[试运行] 命令: chown -R $WEB_USER:$WEB_GROUP $DEPLOY_DIR"
    fi
}

# 安装依赖
install_dependencies() {
    log_info "检查并安装应用依赖"
    
    # 检查是否存在package.json (Node.js应用)
    if [ -f "$DEPLOY_DIR/package.json" ]
    then
        log_info "检测到Node.js应用"
        if command -v npm &>/dev/null
        then
            if [ "$DRY_RUN" = false ]
            then
                cd "$DEPLOY_DIR" && npm install
                if [ $? -eq 0 ]
                then
                    log_success "Node.js依赖安装完成"
                else
                    log_error "Node.js依赖安装失败"
                fi
            else
                log_info "[试运行] 将安装Node.js依赖"
            fi
        else
            log_warn "npm未安装，跳过Node.js依赖安装"
        fi
    fi
    
    # 检查是否存在requirements.txt (Python应用)
    if [ -f "$DEPLOY_DIR/requirements.txt" ]
    then
        log_info "检测到Python应用"
        if command -v pip &>/dev/null
        then
            if [ "$DRY_RUN" = false ]
            then
                pip install -r "$DEPLOY_DIR/requirements.txt"
                if [ $? -eq 0 ]
                then
                    log_success "Python依赖安装完成"
                else
                    log_error "Python依赖安装失败"
                fi
            else
                log_info "[试运行] 将安装Python依赖"
            fi
        else
            log_warn "pip未安装，跳过Python依赖安装"
        fi
    fi
}

# 重启服务
restart_services() {
    if [ -n "$RESTART_SERVICE" ]
    then
        log_info "重启服务: $RESTART_SERVICE"
        
        if [ "$DRY_RUN" = false ]
        then
            if command -v systemctl &>/dev/null
            then
                systemctl reload "$RESTART_SERVICE" || systemctl restart "$RESTART_SERVICE"
            elif command -v service &>/dev/null
            then
                service "$RESTART_SERVICE" reload || service "$RESTART_SERVICE" restart
            else
                log_warn "未找到服务管理命令"
            fi
            
            if [ $? -eq 0 ]
            then
                log_success "服务重启完成"
            else
                log_error "服务重启失败"
            fi
        else
            log_info "[试运行] 将重启服务: $RESTART_SERVICE"
        fi
    fi
}

# 运行应用测试
run_application_tests() {
    log_info "运行应用测试"
    
    # 检查是否存在测试脚本
    if [ -f "$DEPLOY_DIR/test.sh" ]
    then
        if [ "$DRY_RUN" = false ]
        then
            cd "$DEPLOY_DIR" && ./test.sh
            if [ $? -eq 0 ]
            then
                log_success "应用测试通过"
            else
                log_error "应用测试失败"
                exit 1
            fi
        else
            log_info "[试运行] 将运行应用测试"
        fi
    elif [ -f "$DEPLOY_DIR/package.json" ] && grep -q "test" "$DEPLOY_DIR/package.json"
    then
        # Node.js应用测试
        if [ "$DRY_RUN" = false ]
        then
            cd "$DEPLOY_DIR" && npm test
            if [ $? -eq 0 ]
            then
                log_success "Node.js测试通过"
            else
                log_error "Node.js测试失败"
            fi
        else
            log_info "[试运行] 将运行Node.js测试"
        fi
    else
        log_info "未找到测试脚本，跳过测试"
    fi
}

# 清理临时文件
cleanup() {
    # 清理Git克隆的临时目录
    if [[ "$APP_SOURCE" == /tmp/${APP_NAME}_deploy_* ]]
    then
        if [ "$DRY_RUN" = false ]
        then
            rm -rf "$APP_SOURCE"
            log_info "清理临时目录: $APP_SOURCE"
        else
            log_info "[试运行] 将清理临时目录: $APP_SOURCE"
        fi
    fi
}

# 主函数
main() {
    parse_args "$@"
    
    # 设置日志文件
    LOG_FILE="/var/log/${APP_NAME}_deploy_$(date +%Y%m%d).log"
    
    log_info "=== Web应用部署脚本开始 ==="
    log_info "应用名称: $APP_NAME"
    log_info "部署目录: $DEPLOY_DIR"
    log_info "备份目录: $BACKUP_DIR"
    log_info "Git仓库: ${GIT_REPO:-"未指定"}"
    log_info "Git分支: $GIT_BRANCH"
    log_info "Web用户: $WEB_USER"
    log_info "Web组: $WEB_GROUP"
    log_info "重启服务: ${RESTART_SERVICE:-"未指定"}"
    log_info "运行模式: $([ "$DRY_RUN" = true ] && echo "试运行" || echo "实际运行")"
    log_info "详细模式: $([ "$VERBOSE" = true ] && echo "开启" || echo "关闭")"
    log_info "开始时间: $(date)"
    log_info "日志文件: $LOG_FILE"
    log_info "=========================="
    
    # 创建日志目录
    mkdir -p "$(dirname "$LOG_FILE")"
    
    # 执行部署步骤
    check_permissions
    check_dependencies
    create_directories
    backup_current_deployment
    get_application_source
    deploy_application
    install_dependencies
    run_application_tests
    restart_services
    cleanup
    
    log_info "=========================="
    log_success "=== Web应用部署完成 ==="
    log_info "结束时间: $(date)"
}

# 信号处理
trap 'log_error "部署被中断"; cleanup; exit 1' INT TERM

# 执行主函数
main "$@"
```

## 容器化部署脚本

### Docker应用部署脚本

```bash
#!/bin/bash

# Docker应用自动化部署脚本
# 文件名: docker_deploy.sh

# 配置参数
APP_NAME="myapp"
DOCKER_IMAGE=""
DOCKER_TAG="latest"
DOCKER_FILE="Dockerfile"
DOCKER_COMPOSE_FILE="docker-compose.yml"
REGISTRY=""
REGISTRY_USER=""
REGISTRY_PASS=""
PORTS=()
ENV_VARS=()
VOLUMES=()
NETWORKS=()
REPLICAS=1
FORCE_RECREATE=false
DRY_RUN=false
VERBOSE=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_message() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${timestamp} [${level}] ${message}"
}

log_info() {
    log_message "${BLUE}INFO${NC}" "$1"
}

log_warn() {
    log_message "${YELLOW}WARN${NC}" "$1"
}

log_error() {
    log_message "${RED}ERROR${NC}" "$1"
}

log_success() {
    log_message "${GREEN}SUCCESS${NC}" "$1"
}

# 显示帮助信息
show_help() {
    echo "Docker应用自动化部署脚本"
    echo "用法: $0 [选项] <操作>"
    echo
    echo "操作:"
    echo "  build     构建Docker镜像"
    echo "  push      推送Docker镜像到仓库"
    echo "  deploy    部署Docker容器"
    echo "  scale     扩容/缩容服务"
    echo "  rollback  回滚到上一版本"
    echo "  status    查看服务状态"
    echo
    echo "选项:"
    echo "  -n, --name NAME          应用名称"
    echo "  -i, --image IMAGE        Docker镜像名称"
    echo "  -t, --tag TAG            Docker镜像标签 (默认: latest)"
    echo "  -f, --file DOCKERFILE    Dockerfile路径 (默认: Dockerfile)"
    echo "  -c, --compose FILE       docker-compose文件 (默认: docker-compose.yml)"
    echo "  -r, --registry REGISTRY  Docker仓库地址"
    echo "  -u, --user USERNAME      仓库用户名"
    echo "  -p, --pass PASSWORD      仓库密码"
    echo "  -P, --port PORT          端口映射 (格式: 宿主机端口:容器端口)"
    echo "  -e, --env VAR            环境变量 (格式: KEY=VALUE)"
    echo "  -v, --volume VOLUME      数据卷映射 (格式: 宿主机路径:容器路径)"
    echo "  -N, --network NETWORK    Docker网络"
    echo "  -R, --replicas COUNT     服务副本数 (默认: 1)"
    echo "  -F, --force              强制重新创建容器"
    echo "  -d, --dry-run            试运行模式"
    echo "  -V, --verbose            详细输出模式"
    echo "  -h, --help               显示此帮助信息"
    echo
    echo "示例:"
    echo "  $0 build -n myapp -f Dockerfile.prod"
    echo "  $0 push -i myapp -t v1.0 -r registry.example.com"
    echo "  $0 deploy -i nginx -P 8080:80 -e ENV=prod"
    echo "  $0 scale -n myapp -R 3"
}

# 解析命令行参数
parse_args() {
    if [ $# -lt 1 ]
    then
        show_help
        exit 1
    fi
    
    ACTION="$1"
    shift
    
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -n|--name)
                APP_NAME="$2"
                shift 2
                ;;
            -i|--image)
                DOCKER_IMAGE="$2"
                shift 2
                ;;
            -t|--tag)
                DOCKER_TAG="$2"
                shift 2
                ;;
            -f|--file)
                DOCKER_FILE="$2"
                shift 2
                ;;
            -c|--compose)
                DOCKER_COMPOSE_FILE="$2"
                shift 2
                ;;
            -r|--registry)
                REGISTRY="$2"
                shift 2
                ;;
            -u|--user)
                REGISTRY_USER="$2"
                shift 2
                ;;
            -p|--pass)
                REGISTRY_PASS="$2"
                shift 2
                ;;
            -P|--port)
                PORTS+=("$2")
                shift 2
                ;;
            -e|--env)
                ENV_VARS+=("$2")
                shift 2
                ;;
            -v|--volume)
                VOLUMES+=("$2")
                shift 2
                ;;
            -N|--network)
                NETWORKS+=("$2")
                shift 2
                ;;
            -R|--replicas)
                REPLICAS="$2"
                shift 2
                ;;
            -F|--force)
                FORCE_RECREATE=true
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -V|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# 验证依赖
check_dependencies() {
    local dependencies=("docker")
    
    if [ -f "$DOCKER_COMPOSE_FILE" ] || [[ "$ACTION" =~ ^(deploy|scale|rollback|status)$ ]]
    then
        dependencies+=("docker-compose")
    fi
    
    for dep in "${dependencies[@]}"
    do
        if ! command -v "$dep" &>/dev/null
        then
            log_error "$dep 未安装"
            exit 1
        fi
    done
}

# 登录Docker仓库
docker_login() {
    if [ -n "$REGISTRY" ] && [ -n "$REGISTRY_USER" ] && [ -n "$REGISTRY_PASS" ]
    then
        log_info "登录Docker仓库: $REGISTRY"
        
        if [ "$DRY_RUN" = false ]
        then
            if echo "$REGISTRY_PASS" | docker login "$REGISTRY" -u "$REGISTRY_USER" --password-stdin
            then
                log_success "Docker仓库登录成功"
            else
                log_error "Docker仓库登录失败"
                exit 1
            fi
        else
            log_info "[试运行] 将登录Docker仓库: $REGISTRY"
        fi
    fi
}

# 构建Docker镜像
build_image() {
    if [ ! -f "$DOCKER_FILE" ]
    then
        log_error "Dockerfile不存在: $DOCKER_FILE"
        exit 1
    fi
    
    local image_name="${DOCKER_IMAGE:-$APP_NAME}"
    local full_image_name="${REGISTRY:+$REGISTRY/}$image_name:$DOCKER_TAG"
    
    log_info "构建Docker镜像: $full_image_name"
    log_info "使用Dockerfile: $DOCKER_FILE"
    
    if [ "$DRY_RUN" = false ]
    then
        if docker build -t "$full_image_name" -f "$DOCKER_FILE" .
        then
            log_success "Docker镜像构建成功"
        else
            log_error "Docker镜像构建失败"
            exit 1
        fi
    else
        log_info "[试运行] 将构建镜像: $full_image_name"
        log_info "[试运行] 命令: docker build -t $full_image_name -f $DOCKER_FILE ."
    fi
}

# 推送Docker镜像
push_image() {
    local image_name="${DOCKER_IMAGE:-$APP_NAME}"
    local full_image_name="${REGISTRY:+$REGISTRY/}$image_name:$DOCKER_TAG"
    
    log_info "推送Docker镜像: $full_image_name"
    
    if [ "$DRY_RUN" = false ]
    then
        if docker push "$full_image_name"
        then
            log_success "Docker镜像推送成功"
        else
            log_error "Docker镜像推送失败"
            exit 1
        fi
    else
        log_info "[试运行] 将推送镜像: $full_image_name"
        log_info "[试运行] 命令: docker push $full_image_name"
    fi
}

# 部署Docker容器
deploy_container() {
    local image_name="${DOCKER_IMAGE:-$APP_NAME}"
    local full_image_name="${REGISTRY:+$REGISTRY/}$image_name:$DOCKER_TAG"
    local container_name="${APP_NAME}_${DOCKER_TAG}_$(date +%s)"
    
    log_info "部署Docker容器"
    log_info "镜像: $full_image_name"
    log_info "容器名: $container_name"
    
    # 构建docker run命令
    local docker_run_cmd="docker run -d --name $container_name"
    
    # 添加端口映射
    for port in "${PORTS[@]}"
    do
        docker_run_cmd="$docker_run_cmd -p $port"
    done
    
    # 添加环境变量
    for env in "${ENV_VARS[@]}"
    do
        docker_run_cmd="$docker_run_cmd -e $env"
    done
    
    # 添加数据卷
    for volume in "${VOLUMES[@]}"
    do
        docker_run_cmd="$docker_run_cmd -v $volume"
    done
    
    # 添加网络
    for network in "${NETWORKS[@]}"
    do
        docker_run_cmd="$docker_run_cmd --network $network"
    done
    
    # 添加强制重建选项
    if [ "$FORCE_RECREATE" = true ]
    then
        docker_run_cmd="$docker_run_cmd --rm"
    fi
    
    # 添加镜像名
    docker_run_cmd="$docker_run_cmd $full_image_name"
    
    log_info "运行命令: $docker_run_cmd"
    
    if [ "$DRY_RUN" = false ]
    then
        if eval "$docker_run_cmd"
        then
            log_success "Docker容器部署成功"
            log_info "容器ID: $(docker ps -q -f name=$container_name)"
        else
            log_error "Docker容器部署失败"
            exit 1
        fi
    else
        log_info "[试运行] 将部署容器"
    fi
}

# 使用Docker Compose部署
deploy_with_compose() {
    if [ ! -f "$DOCKER_COMPOSE_FILE" ]
    then
        log_error "docker-compose文件不存在: $DOCKER_COMPOSE_FILE"
        exit 1
    fi
    
    log_info "使用Docker Compose部署"
    log_info "Compose文件: $DOCKER_COMPOSE_FILE"
    log_info "服务副本数: $REPLICAS"
    
    local compose_cmd="docker-compose -f $DOCKER_COMPOSE_FILE"
    
    if [ "$FORCE_RECREATE" = true ]
    then
        compose_cmd="$compose_cmd up -d --force-recreate"
    else
        compose_cmd="$compose_cmd up -d"
    fi
    
    log_info "运行命令: $compose_cmd"
    
    if [ "$DRY_RUN" = false ]
    then
        if eval "$compose_cmd"
        then
            log_success "Docker Compose部署成功"
        else
            log_error "Docker Compose部署失败"
            exit 1
        fi
    else
        log_info "[试运行] 将使用Docker Compose部署"
    fi
}

# 扩容/缩容服务
scale_service() {
    if [ ! -f "$DOCKER_COMPOSE_FILE" ]
    then
        log_error "docker-compose文件不存在: $DOCKER_COMPOSE_FILE"
        exit 1
    fi
    
    log_info "调整服务规模: $APP_NAME"
    log_info "目标副本数: $REPLICAS"
    
    local scale_cmd="docker-compose -f $DOCKER_COMPOSE_FILE scale $APP_NAME=$REPLICAS"
    
    log_info "运行命令: $scale_cmd"
    
    if [ "$DRY_RUN" = false ]
    then
        if eval "$scale_cmd"
        then
            log_success "服务规模调整成功"
        else
            log_error "服务规模调整失败"
            exit 1
        fi
    else
        log_info "[试运行] 将调整服务规模"
    fi
}

# 查看服务状态
show_status() {
    log_info "查看服务状态"
    
    if [ -f "$DOCKER_COMPOSE_FILE" ]
    then
        log_info "Docker Compose服务状态:"
        docker-compose -f "$DOCKER_COMPOSE_FILE" ps
    else
        log_info "Docker容器状态:"
        docker ps -f ancestor="${DOCKER_IMAGE:-$APP_NAME}"
    fi
}

# 主函数
main() {
    parse_args "$@"
    
    log_info "=== Docker应用部署脚本 ==="
    log_info "操作: $ACTION"
    log_info "应用名称: $APP_NAME"
    log_info "Docker镜像: ${DOCKER_IMAGE:-"未指定"}"
    log_info "镜像标签: $DOCKER_TAG"
    log_info "运行模式: $([ "$DRY_RUN" = true ] && echo "试运行" || echo "实际运行")"
    log_info "详细模式: $([ "$VERBOSE" = true ] && echo "开启" || echo "关闭")"
    log_info "开始时间: $(date)"
    log_info "========================"
    
    # 验证依赖
    check_dependencies
    
    # 根据操作执行相应功能
    case $ACTION in
        build)
            docker_login
            build_image
            ;;
        push)
            docker_login
            push_image
            ;;
        deploy)
            if [ -f "$DOCKER_COMPOSE_FILE" ]
            then
                deploy_with_compose
            else
                docker_login
                deploy_container
            fi
            ;;
        scale)
            scale_service
            ;;
        status)
            show_status
            ;;
        *)
            log_error "未知操作: $ACTION"
            show_help
            exit 1
            ;;
    esac
    
    log_info "========================"
    log_success "=== 操作完成 ==="
    log_info "结束时间: $(date)"
}

# 执行主函数
main "$@"
```

## 数据库部署脚本

### MySQL数据库部署脚本

```bash
#!/bin/bash

# MySQL数据库自动化部署脚本
# 文件名: mysql_deploy.sh

# 配置参数
DB_NAME=""
DB_USER=""
DB_PASSWORD=""
DB_ROOT_PASSWORD=""
DB_VERSION="8.0"
DB_PORT=3306
DB_DATA_DIR="/var/lib/mysql"
DB_CONFIG_FILE="/etc/mysql/mysql.conf.d/mysqld.cnf"
DOCKER_IMAGE="mysql"
BACKUP_FILE=""
RESTORE_FILE=""
ACTION="deploy"
DRY_RUN=false
VERBOSE=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_message() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${timestamp} [${level}] ${message}"
}

log_info() {
    log_message "${BLUE}INFO${NC}" "$1"
}

log_warn() {
    log_message "${YELLOW}WARN${NC}" "$1"
}

log_error() {
    log_message "${RED}ERROR${NC}" "$1"
}

log_success() {
    log_message "${GREEN}SUCCESS${NC}" "$1"
}

# 显示帮助信息
show_help() {
    echo "MySQL数据库自动化部署脚本"
    echo "用法: $0 [选项] <操作>"
    echo
    echo "操作:"
    echo "  deploy   部署MySQL数据库"
    echo "  backup   备份数据库"
    echo "  restore  恢复数据库"
    echo "  status   查看数据库状态"
    echo "  stop     停止数据库"
    echo "  start    启动数据库"
    echo
    echo "选项:"
    echo "  -n, --name NAME          数据库名称"
    echo "  -u, --user USER          数据库用户"
    echo "  -p, --password PASS      数据库用户密码"
    echo "  -r, --root-pass PASS     root用户密码"
    echo "  -v, --version VERSION    MySQL版本 (默认: 8.0)"
    echo "  -P, --port PORT          数据库端口 (默认: 3306)"
    echo "  -d, --data-dir DIR       数据存储目录"
    echo "  -c, --config FILE        配置文件路径"
    echo "  -i, --image IMAGE        Docker镜像 (默认: mysql)"
    echo "  -b, --backup FILE        备份文件路径"
    echo "  -R, --restore FILE       恢复文件路径"
    echo "  -D, --dry-run            试运行模式"
    echo "  -V, --verbose            详细输出模式"
    echo "  -h, --help               显示此帮助信息"
    echo
    echo "示例:"
    echo "  $0 deploy -n myapp -u appuser -p apppass -r rootpass"
    echo "  $0 backup -n myapp -b /backups/myapp_$(date +%Y%m%d).sql"
    echo "  $0 restore -n myapp -R /backups/myapp_backup.sql"
}

# 解析命令行参数
parse_args() {
    if [ $# -lt 1 ]
    then
        show_help
        exit 1
    fi
    
    ACTION="$1"
    shift
    
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -n|--name)
                DB_NAME="$2"
                shift 2
                ;;
            -u|--user)
                DB_USER="$2"
                shift 2
                ;;
            -p|--password)
                DB_PASSWORD="$2"
                shift 2
                ;;
            -r|--root-pass)
                DB_ROOT_PASSWORD="$2"
                shift 2
                ;;
            -v|--version)
                DB_VERSION="$2"
                shift 2
                ;;
            -P|--port)
                DB_PORT="$2"
                shift 2
                ;;
            -d|--data-dir)
                DB_DATA_DIR="$2"
                shift 2
                ;;
            -c|--config)
                DB_CONFIG_FILE="$2"
                shift 2
                ;;
            -i|--image)
                DOCKER_IMAGE="$2"
                shift 2
                ;;
            -b|--backup)
                BACKUP_FILE="$2"
                shift 2
                ;;
            -R|--restore)
                RESTORE_FILE="$2"
                shift 2
                ;;
            -D|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -V|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# 验证参数
validate_args() {
    case $ACTION in
        deploy)
            if [ -z "$DB_NAME" ] || [ -z "$DB_USER" ] || [ -z "$DB_PASSWORD" ] || [ -z "$DB_ROOT_PASSWORD" ]
            then
                log_error "部署操作需要指定数据库名称、用户、密码和root密码"
                exit 1
            fi
            ;;
        backup)
            if [ -z "$DB_NAME" ] || [ -z "$BACKUP_FILE" ]
            then
                log_error "备份操作需要指定数据库名称和备份文件路径"
                exit 1
            fi
            ;;
        restore)
            if [ -z "$DB_NAME" ] || [ -z "$RESTORE_FILE" ]
            then
                log_error "恢复操作需要指定数据库名称和恢复文件路径"
                exit 1
            fi
            if [ ! -f "$RESTORE_FILE" ]
            then
                log_error "恢复文件不存在: $RESTORE_FILE"
                exit 1
            fi
            ;;
    esac
}

# 验证依赖
check_dependencies() {
    local dependencies=("docker" "mysqldump" "mysql")
    
    for dep in "${dependencies[@]}"
    do
        if ! command -v "$dep" &>/dev/null
        then
            log_error "$dep 未安装"
            exit 1
        fi
    done
}

# 部署MySQL数据库
deploy_mysql() {
    log_info "部署MySQL数据库"
    log_info "数据库名称: $DB_NAME"
    log_info "数据库用户: $DB_USER"
    log_info "MySQL版本: $DB_VERSION"
    log_info "端口: $DB_PORT"
    log_info "数据目录: $DB_DATA_DIR"
    
    # 创建数据目录
    if [ "$DRY_RUN" = false ]
    then
        mkdir -p "$DB_DATA_DIR"
        log_success "创建数据目录: $DB_DATA_DIR"
    else
        log_info "[试运行] 将创建数据目录: $DB_DATA_DIR"
    fi
    
    # 构建docker run命令
    local docker_run_cmd="docker run -d \
        --name mysql_$DB_NAME \
        -e MYSQL_ROOT_PASSWORD=$DB_ROOT_PASSWORD \
        -e MYSQL_DATABASE=$DB_NAME \
        -e MYSQL_USER=$DB_USER \
        -e MYSQL_PASSWORD=$DB_PASSWORD \
        -v $DB_DATA_DIR:/var/lib/mysql \
        -p $DB_PORT:3306 \
        $DOCKER_IMAGE:$DB_VERSION"
    
    log_info "运行命令: $docker_run_cmd"
    
    if [ "$DRY_RUN" = false ]
    then
        if eval "$docker_run_cmd"
        then
            log_success "MySQL数据库部署成功"
            log_info "等待数据库启动..."
            sleep 30  # 等待数据库启动
            test_connection
        else
            log_error "MySQL数据库部署失败"
            exit 1
        fi
    else
        log_info "[试运行] 将部署MySQL数据库"
    fi
}

# 测试数据库连接
test_connection() {
    log_info "测试数据库连接"
    
    local test_cmd="mysql -h 127.0.0.1 -P $DB_PORT -u $DB_USER -p$DB_PASSWORD -e 'SELECT 1;'"
    
    if [ "$DRY_RUN" = false ]
    then
        if eval "$test_cmd"
        then
            log_success "数据库连接测试成功"
        else
            log_error "数据库连接测试失败"
        fi
    else
        log_info "[试运行] 将测试数据库连接"
    fi
}

# 备份数据库
backup_database() {
    log_info "备份数据库: $DB_NAME"
    log_info "备份文件: $BACKUP_FILE"
    
    local backup_cmd="mysqldump -h 127.0.0.1 -P $DB_PORT -u $DB_USER -p$DB_PASSWORD $DB_NAME > $BACKUP_FILE"
    
    log_info "运行命令: $backup_cmd"
    
    if [ "$DRY_RUN" = false ]
    then
        if eval "$backup_cmd"
        then
            log_success "数据库备份成功"
            local backup_size=$(du -h "$BACKUP_FILE" | cut -f1)
            log_info "备份文件大小: $backup_size"
        else
            log_error "数据库备份失败"
            exit 1
        fi
    else
        log_info "[试运行] 将备份数据库"
    fi
}

# 恢复数据库
restore_database() {
    log_info "恢复数据库: $DB_NAME"
    log_info "恢复文件: $RESTORE_FILE"
    
    local restore_cmd="mysql -h 127.0.0.1 -P $DB_PORT -u $DB_USER -p$DB_PASSWORD $DB_NAME < $RESTORE_FILE"
    
    log_info "运行命令: $restore_cmd"
    
    if [ "$DRY_RUN" = false ]
    then
        if eval "$restore_cmd"
        then
            log_success "数据库恢复成功"
        else
            log_error "数据库恢复失败"
            exit 1
        fi
    else
        log_info "[试运行] 将恢复数据库"
    fi
}

# 查看数据库状态
show_status() {
    log_info "查看MySQL数据库状态"
    
    if [ "$DRY_RUN" = false ]
    then
        docker ps -f name=mysql_$DB_NAME
    else
        log_info "[试运行] 将查看数据库状态"
    fi
}

# 停止数据库
stop_database() {
    log_info "停止MySQL数据库"
    
    if [ "$DRY_RUN" = false ]
    then
        if docker stop mysql_$DB_NAME
        then
            log_success "数据库已停止"
        else
            log_error "停止数据库失败"
        fi
    else
        log_info "[试运行] 将停止数据库"
    fi
}

# 启动数据库
start_database() {
    log_info "启动MySQL数据库"
    
    if [ "$DRY_RUN" = false ]
    then
        if docker start mysql_$DB_NAME
        then
            log_success "数据库已启动"
            log_info "等待数据库启动..."
            sleep 30
            test_connection
        else
            log_error "启动数据库失败"
        fi
    else
        log_info "[试运行] 将启动数据库"
    fi
}

# 主函数
main() {
    parse_args "$@"
    validate_args
    
    log_info "=== MySQL数据库部署脚本 ==="
    log_info "操作: $ACTION"
    log_info "数据库名称: ${DB_NAME:-"未指定"}"
    log_info "运行模式: $([ "$DRY_RUN" = true ] && echo "试运行" || echo "实际运行")"
    log_info "详细模式: $([ "$VERBOSE" = true ] && echo "开启" || echo "关闭")"
    log_info "开始时间: $(date)"
    log_info "========================"
    
    # 验证依赖
    check_dependencies
    
    # 根据操作执行相应功能
    case $ACTION in
        deploy)
            deploy_mysql
            ;;
        backup)
            backup_database
            ;;
        restore)
            restore_database
            ;;
        status)
            show_status
            ;;
        stop)
            stop_database
            ;;
        start)
            start_database
            ;;
        *)
            log_error "未知操作: $ACTION"
            show_help
            exit 1
            ;;
    esac
    
    log_info "========================"
    log_success "=== 操作完成 ==="
    log_info "结束时间: $(date)"
}

# 执行主函数
main "$@"
```

## 配置管理脚本

### 应用配置部署脚本

```bash
#!/bin/bash

# 应用配置自动化部署脚本
# 文件名: config_deploy.sh

# 配置参数
APP_NAME=""
CONFIG_SOURCE=""
CONFIG_TARGET=""
CONFIG_TYPE="file"
ENCRYPTION_KEY=""
BACKUP_EXISTING=true
VALIDATE_CONFIG=true
DRY_RUN=false
VERBOSE=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_message() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${timestamp} [${level}] ${message}"
}

log_info() {
    log_message "${BLUE}INFO${NC}" "$1"
}

log_warn() {
    log_message "${YELLOW}WARN${NC}" "$1"
}

log_error() {
    log_message "${RED}ERROR${NC}" "$1"
}

log_success() {
    log_message "${GREEN}SUCCESS${NC}" "$1"
}

# 显示帮助信息
show_help() {
    echo "应用配置自动化部署脚本"
    echo "用法: $0 [选项]"
    echo
    echo "选项:"
    echo "  -a, --app NAME          应用名称"
    echo "  -s, --source PATH       配置源路径"
    echo "  -t, --target PATH       配置目标路径"
    echo "  -T, --type TYPE         配置类型 (file, template, directory)"
    echo "  -e, --encrypt KEY       加密密钥"
    echo "  -B, --no-backup         不备份现有配置"
    echo "  -V, --no-validate       不验证配置"
    echo "  -d, --dry-run           试运行模式"
    echo "  -v, --verbose           详细输出模式"
    echo "  -h, --help              显示此帮助信息"
    echo
    echo "示例:"
    echo "  $0 -a myapp -s /configs/prod/app.conf -t /etc/myapp/app.conf"
    echo "  $0 -a webapp -s /configs/templates/nginx.conf.tmpl -t /etc/nginx/sites-available/default -T template"
    echo "  $0 -a database -s /configs/prod/mysql -t /etc/mysql -T directory"
}

# 解析命令行参数
parse_args() {
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -a|--app)
                APP_NAME="$2"
                shift 2
                ;;
            -s|--source)
                CONFIG_SOURCE="$2"
                shift 2
                ;;
            -t|--target)
                CONFIG_TARGET="$2"
                shift 2
                ;;
            -T|--type)
                CONFIG_TYPE="$2"
                shift 2
                ;;
            -e|--encrypt)
                ENCRYPTION_KEY="$2"
                shift 2
                ;;
            -B|--no-backup)
                BACKUP_EXISTING=false
                shift
                ;;
            -V|--no-validate)
                VALIDATE_CONFIG=false
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# 验证参数
validate_args() {
    if [ -z "$APP_NAME" ]
    then
        log_error "必须指定应用名称 (-a)"
        exit 1
    fi
    
    if [ -z "$CONFIG_SOURCE" ]
    then
        log_error "必须指定配置源路径 (-s)"
        exit 1
    fi
    
    if [ -z "$CONFIG_TARGET" ]
    then
        log_error "必须指定配置目标路径 (-t)"
        exit 1
    fi
    
    if [ ! -e "$CONFIG_SOURCE" ]
    then
        log_error "配置源不存在: $CONFIG_SOURCE"
        exit 1
    fi
    
    if [[ ! "$CONFIG_TYPE" =~ ^(file|template|directory)$ ]]
    then
        log_error "无效的配置类型: $CONFIG_TYPE"
        log_info "有效类型: file, template, directory"
        exit 1
    fi
}

# 备份现有配置
backup_existing_config() {
    if [ "$BACKUP_EXISTING" = false ]
    then
        log_info "跳过配置备份"
        return
    fi
    
    if [ -e "$CONFIG_TARGET" ]
    then
        local backup_name="${CONFIG_TARGET}_backup_$(date +%Y%m%d_%H%M%S)"
        
        if [ "$DRY_RUN" = false ]
        then
            if cp -r "$CONFIG_TARGET" "$backup_name"
            then
                log_success "现有配置已备份到: $backup_name"
            else
                log_error "配置备份失败"
            fi
        else
            log_info "[试运行] 将备份现有配置到: $backup_name"
        fi
    else
        log_info "目标路径不存在，无需备份"
    fi
}

# 解密配置文件
decrypt_config() {
    local source=$1
    local temp_file="/tmp/config_decrypt_$$_$(basename "$source")"
    
    if [ -n "$ENCRYPTION_KEY" ]
    then
        log_info "解密配置文件: $source"
        
        if [ "$DRY_RUN" = false ]
        then
            if command -v openssl &>/dev/null
            then
                if openssl enc -d -aes-256-cbc -in "$source" -out "$temp_file" -k "$ENCRYPTION_KEY" 2>/dev/null
                then
                    log_success "配置文件解密成功"
                    echo "$temp_file"
                    return 0
                else
                    log_error "配置文件解密失败"
                    rm -f "$temp_file"
                    exit 1
                fi
            else
                log_error "openssl未安装，无法解密配置文件"
                exit 1
            fi
        else
            log_info "[试运行] 将解密配置文件"
            echo "$temp_file"
            return 0
        fi
    else
        # 无需解密
        echo "$source"
        return 0
    fi
}

# 部署配置文件
deploy_config_file() {
    local source=$1
    local target=$2
    
    log_info "部署配置文件"
    log_info "源文件: $source"
    log_info "目标文件: $target"
    
    # 解密配置文件（如果需要）
    local decrypted_source=$(decrypt_config "$source")
    
    # 创建目标目录
    local target_dir=$(dirname "$target")
    if [ ! -d "$target_dir" ]
    then
        if [ "$DRY_RUN" = false ]
        then
            mkdir -p "$target_dir"
            if [ $? -eq 0 ]
            then
                log_success "创建目录: $target_dir"
            else
                log_error "创建目录失败: $target_dir"
                exit 1
            fi
        else
            log_info "[试运行] 将创建目录: $target_dir"
        fi
    fi
    
    # 部署文件
    if [ "$DRY_RUN" = false ]
    then
        if cp "$decrypted_source" "$target"
        then
            log_success "配置文件部署成功"
        else
            log_error "配置文件部署失败"
            exit 1
        fi
    else
        log_info "[试运行] 将部署配置文件"
    fi
    
    # 清理临时解密文件
    if [ "$decrypted_source" != "$source" ]
    then
        if [ "$DRY_RUN" = false ]
        then
            rm -f "$decrypted_source"
        else
            log_info "[试运行] 将清理临时文件: $decrypted_source"
        fi
    fi
}

# 部署配置模板
deploy_config_template() {
    local template=$1
    local target=$2
    
    log_info "部署配置模板"
    log_info "模板文件: $template"
    log_info "目标文件: $target"
    
    # 解密模板文件（如果需要）
    local decrypted_template=$(decrypt_config "$template")
    
    # 创建目标目录
    local target_dir=$(dirname "$target")
    if [ ! -d "$target_dir" ]
    then
        if [ "$DRY_RUN" = false ]
        then
            mkdir -p "$target_dir"
            if [ $? -eq 0 ]
            then
                log_success "创建目录: $target_dir"
            else
                log_error "创建目录失败: $target_dir"
                exit 1
            fi
        else
            log_info "[试运行] 将创建目录: $target_dir"
        fi
    fi
    
    # 部署并处理模板
    if [ "$DRY_RUN" = false ]
    then
        # 这里可以添加模板处理逻辑
        # 例如替换环境变量等
        if cp "$decrypted_template" "$target"
        then
            log_success "配置模板部署成功"
        else
            log_error "配置模板部署失败"
            exit 1
        fi
    else
        log_info "[试运行] 将部署配置模板"
    fi
    
    # 清理临时解密文件
    if [ "$decrypted_template" != "$template" ]
    then
        if [ "$DRY_RUN" = false ]
        then
            rm -f "$decrypted_template"
        else
            log_info "[试运行] 将清理临时文件: $decrypted_template"
        fi
    fi
}

# 部署配置目录
deploy_config_directory() {
    local source=$1
    local target=$2
    
    log_info "部署配置目录"
    log_info "源目录: $source"
    log_info "目标目录: $target"
    
    if [ "$DRY_RUN" = false ]
    then
        if rsync -av "$source/" "$target/"
        then
            log_success "配置目录部署成功"
        else
            log_error "配置目录部署失败"
            exit 1
        fi
    else
        log_info "[试运行] 将部署配置目录"
        log_info "[试运行] 命令: rsync -av $source/ $target/"
    fi
}

# 验证配置
validate_configuration() {
    if [ "$VALIDATE_CONFIG" = false ]
    then
        log_info "跳过配置验证"
        return
    fi
    
    log_info "验证配置: $CONFIG_TARGET"
    
    case $CONFIG_TYPE in
        file)
            if [ -f "$CONFIG_TARGET" ]
            then
                log_success "配置文件存在"
                # 可以添加更具体的验证逻辑
                if [ "$VERBOSE" = true ]
                then
                    log_info "配置文件大小: $(du -h "$CONFIG_TARGET" | cut -f1)"
                    log_info "配置文件权限: $(ls -l "$CONFIG_TARGET" | cut -d' ' -f1)"
                fi
            else
                log_error "配置文件不存在: $CONFIG_TARGET"
            fi
            ;;
        directory)
            if [ -d "$CONFIG_TARGET" ]
            then
                log_success "配置目录存在"
                local file_count=$(find "$CONFIG_TARGET" -type f | wc -l)
                log_info "配置文件数量: $file_count"
            else
                log_error "配置目录不存在: $CONFIG_TARGET"
            fi
            ;;
    esac
}

# 主函数
main() {
    parse_args "$@"
    validate_args
    
    log_info "=== 应用配置部署脚本 ==="
    log_info "应用名称: $APP_NAME"
    log_info "配置类型: $CONFIG_TYPE"
    log_info "源路径: $CONFIG_SOURCE"
    log_info "目标路径: $CONFIG_TARGET"
    log_info "备份现有配置: $([ "$BACKUP_EXISTING" = true ] && echo "是" || echo "否")"
    log_info "验证配置: $([ "$VALIDATE_CONFIG" = true ] && echo "是" || echo "否")"
    log_info "运行模式: $([ "$DRY_RUN" = true ] && echo "试运行" || echo "实际运行")"
    log_info "详细模式: $([ "$VERBOSE" = true ] && echo "开启" || echo "关闭")"
    log_info "开始时间: $(date)"
    log_info "========================"
    
    # 备份现有配置
    backup_existing_config
    
    # 根据配置类型执行部署
    case $CONFIG_TYPE in
        file)
            deploy_config_file "$CONFIG_SOURCE" "$CONFIG_TARGET"
            ;;
        template)
            deploy_config_template "$CONFIG_SOURCE" "$CONFIG_TARGET"
            ;;
        directory)
            deploy_config_directory "$CONFIG_SOURCE" "$CONFIG_TARGET"
            ;;
    esac
    
    # 验证配置
    validate_configuration
    
    log_info "========================"
    log_success "=== 配置部署完成 ==="
    log_info "结束时间: $(date)"
}

# 执行主函数
main "$@"
```

## 最佳实践

1. **版本控制**：将部署脚本纳入版本控制系统，确保可追溯性
2. **环境分离**：为不同环境（开发、测试、生产）创建不同的配置
3. **安全考虑**：避免在脚本中硬编码敏感信息，使用环境变量或加密存储
4. **错误处理**：添加适当的错误处理机制，确保部署失败时能够正确回滚
5. **日志记录**：详细记录部署过程，便于问题排查和审计
6. **测试验证**：在生产环境部署前充分测试脚本
7. **回滚机制**：实现可靠的回滚机制，确保部署失败时能恢复到之前状态
8. **权限管理**：确保部署脚本具有适当的执行权限，敏感操作需要相应权限

## 总结

自动化部署脚本是现代DevOps实践的核心组成部分。通过本章的学习，你应该掌握了：

1. Web应用自动化部署脚本的编写方法
2. Docker容器化应用的部署脚本实现
3. 数据库部署和管理脚本的开发
4. 应用配置自动化部署脚本的使用
5. 实际应用场景和最佳实践

这些脚本可以帮助你实现应用部署的自动化，提高部署效率和可靠性，减少人为错误。自动化部署是持续集成/持续部署(CI/CD)流水线的重要环节，掌握这些技能对于现代软件开发和运维工作至关重要。