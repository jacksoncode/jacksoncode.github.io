# 网络管理脚本

## 网络管理脚本概述

网络管理是现代系统管理的重要组成部分。通过自动化脚本，我们可以监控网络状态、诊断网络问题、管理网络配置和执行网络相关任务。本章将介绍一些实用的网络管理脚本实例。

## 网络监控脚本

### 网络连接监控脚本

```bash
#!/bin/bash

# 网络连接监控脚本
# 文件名: network_monitor.sh

# 配置参数
TARGET_HOSTS=("8.8.8.8" "google.com" "github.com")
CHECK_INTERVAL=60
LOG_FILE="/var/log/network_monitor.log"
ALERT_EMAIL=""
ENABLE_EMAIL=false
DRY_RUN=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_message() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${timestamp} [${level}] ${message}" | tee -a "$LOG_FILE"
}

log_info() {
    log_message "INFO" "$1"
}

log_warn() {
    log_message "${YELLOW}WARN${NC}" "$1"
}

log_error() {
    log_message "${RED}ERROR${NC}" "$1"
}

log_success() {
    log_message "${GREEN}SUCCESS${NC}" "$1"
}

# 显示帮助信息
show_help() {
    echo "网络连接监控脚本"
    echo "用法: $0 [选项]"
    echo "选项:"
    echo "  -h, --hosts HOSTS    监控的目标主机列表 (逗号分隔)"
    echo "  -i, --interval SEC   检查间隔秒数 (默认: 60)"
    echo "  -l, --log FILE       日志文件路径 (默认: /var/log/network_monitor.log)"
    echo "  -e, --email EMAIL    告警邮件地址"
    echo "  -d, --dry-run        试运行模式，不实际执行监控"
    echo "  -v, --verbose        详细输出模式"
    echo "  --help               显示此帮助信息"
    echo
    echo "示例:"
    echo "  $0"
    echo "  $0 -h \"google.com,github.com\" -i 30"
    echo "  $0 -e admin@example.com -l /tmp/network.log"
}

# 解析命令行参数
parse_args() {
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -h|--hosts)
                IFS=',' read -ra TARGET_HOSTS <<< "$2"
                shift 2
                ;;
            -i|--interval)
                CHECK_INTERVAL="$2"
                shift 2
                ;;
            -l|--log)
                LOG_FILE="$2"
                shift 2
                ;;
            -e|--email)
                ALERT_EMAIL="$2"
                ENABLE_EMAIL=true
                shift 2
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --help)
                show_help
                exit 0
                ;;
            *)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# 检查网络连接
check_connectivity() {
    local host=$1
    local timeout=5
    
    if ping -c 1 -W $timeout "$host" >/dev/null 2>&1
    then
        log_success "连接正常: $host"
        return 0
    else
        log_error "连接失败: $host"
        return 1
    fi
}

# 检查DNS解析
check_dns() {
    local host=$1
    
    if host "$host" >/dev/null 2>&1
    then
        log_success "DNS解析正常: $host"
        return 0
    else
        log_error "DNS解析失败: $host"
        return 1
    fi
}

# 检查端口连通性
check_port() {
    local host=$1
    local port=$2
    local timeout=5
    
    if timeout $timeout bash -c "echo >/dev/tcp/$host/$port" 2>/dev/null
    then
        log_success "端口连通正常: $host:$port"
        return 0
    else
        log_error "端口连通失败: $host:$port"
        return 1
    fi
}

# 发送告警邮件
send_alert() {
    local subject=$1
    local message=$2
    
    if [ "$ENABLE_EMAIL" = true ] && [ -n "$ALERT_EMAIL" ]
    then
        if command -v mail &>/dev/null
        then
            if [ "$DRY_RUN" = false ]
            then
                echo "$message" | mail -s "$subject" "$ALERT_EMAIL"
                log_info "告警邮件已发送至: $ALERT_EMAIL"
            else
                log_info "[试运行] 将发送告警邮件至: $ALERT_EMAIL"
                log_info "[试运行] 邮件主题: $subject"
                log_info "[试运行] 邮件内容: $message"
            fi
        else
            log_warn "邮件命令不可用，无法发送告警邮件"
        fi
    fi
}

# 执行网络检查
perform_network_check() {
    log_info "=== 网络连接检查开始 ==="
    
    local failed_hosts=()
    local success_count=0
    local fail_count=0
    
    for host in "${TARGET_HOSTS[@]}"
    do
        log_info "检查主机: $host"
        
        # 检查基本连通性
        if check_connectivity "$host"
        then
            # 检查DNS解析
            check_dns "$host"
            
            # 如果是IP地址，检查特定端口
            if [[ $host =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]
            then
                check_port "$host" 80
                check_port "$host" 443
            fi
            
            success_count=$((success_count + 1))
        else
            failed_hosts+=("$host")
            fail_count=$((fail_count + 1))
        fi
        
        echo  # 添加空行分隔
    done
    
    log_info "检查完成: 成功 $success_count, 失败 $fail_count"
    
    # 如果有失败的主机，发送告警
    if [ ${#failed_hosts[@]} -gt 0 ]
    then
        local alert_subject="网络连接告警 - ${#failed_hosts[@]} 个主机连接失败"
        local alert_message="网络监控脚本检测到以下主机连接失败:
$(printf '%s\n' "${failed_hosts[@]}")

检查时间: $(date)
监控主机: $(hostname)

请检查网络连接状态。"
        
        send_alert "$alert_subject" "$alert_message"
    fi
    
    log_info "=== 网络连接检查结束 ==="
}

# 显示网络接口信息
show_network_info() {
    log_info "网络接口信息:"
    
    # 显示IP地址
    if command -v ip &>/dev/null
    then
        ip addr show | grep -E "^[0-9]+:|inet " | while read line
        do
            log_info "  $line"
        done
    elif command -v ifconfig &>/dev/null
    then
        ifconfig | grep -E "^[a-z]|inet " | while read line
        do
            log_info "  $line"
        done
    fi
    
    # 显示默认路由
    log_info "默认路由:"
    if command -v ip &>/dev/null
    then
        ip route show default | while read line
        do
            log_info "  $line"
        done
    elif command -v route &>/dev/null
    then
        route -n | grep "^0.0.0.0" | while read line
        do
            log_info "  $line"
        done
    fi
}

# 主函数
main() {
    parse_args "$@"
    
    log_info "=== 网络监控脚本启动 ==="
    log_info "监控主机: ${TARGET_HOSTS[*]}"
    log_info "检查间隔: ${CHECK_INTERVAL}秒"
    log_info "日志文件: $LOG_FILE"
    log_info "邮件告警: $([ "$ENABLE_EMAIL" = true ] && echo "开启 ($ALERT_EMAIL)" || echo "关闭")"
    log_info "运行模式: $([ "$DRY_RUN" = true ] && echo "试运行" || echo "实际运行")"
    log_info "开始时间: $(date)"
    log_info "========================"
    
    # 显示网络信息
    show_network_info
    
    echo
    
    # 如果是试运行，只执行一次检查
    if [ "$DRY_RUN" = true ]
    then
        perform_network_check
    else
        # 循环执行检查
        while true
        do
            perform_network_check
            log_info "等待 ${CHECK_INTERVAL} 秒后进行下次检查..."
            sleep $CHECK_INTERVAL
            echo
        done
    fi
}

# 信号处理
trap 'log_info "脚本被中断"; exit 0' INT TERM

# 执行主函数
main "$@"
```

### 带宽监控脚本

```bash
#!/bin/bash

# 网络带宽监控脚本
# 文件名: bandwidth_monitor.sh

# 配置参数
INTERFACE="eth0"
DURATION=60
INTERVAL=5
LOG_FILE="/var/log/bandwidth_monitor.log"
THRESHOLD_RX=0  # 接收带宽阈值 (KB/s)
THRESHOLD_TX=0  # 发送带宽阈值 (KB/s)
ENABLE_ALERT=false
ALERT_EMAIL=""

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_message() {
    local level=$1
    local message=$2
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${timestamp} [${level}] ${message}" | tee -a "$LOG_FILE"
}

log_info() {
    log_message "INFO" "$1"
}

log_warn() {
    log_message "${YELLOW}WARN${NC}" "$1"
}

log_error() {
    log_message "${RED}ERROR${NC}" "$1"
}

log_success() {
    log_message "${GREEN}SUCCESS${NC}" "$1"
}

# 显示帮助信息
show_help() {
    echo "网络带宽监控脚本"
    echo "用法: $0 [选项]"
    echo "选项:"
    echo "  -i, --interface IFACE  网络接口名称 (默认: eth0)"
    echo "  -d, --duration SEC     监控总时长秒数 (默认: 60)"
    echo "  -I, --interval SEC     采样间隔秒数 (默认: 5)"
    echo "  -l, --log FILE         日志文件路径"
    echo "  -r, --rx-threshold KB  接收带宽告警阈值 (KB/s)"
    echo "  -t, --tx-threshold KB  发送带宽告警阈值 (KB/s)"
    echo "  -e, --email EMAIL      告警邮件地址"
    echo "  -h, --help             显示此帮助信息"
    echo
    echo "示例:"
    echo "  $0 -i eth0 -d 300 -I 10"
    echo "  $0 -r 1000 -t 500 -e admin@example.com"
}

# 解析命令行参数
parse_args() {
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -i|--interface)
                INTERFACE="$2"
                shift 2
                ;;
            -d|--duration)
                DURATION="$2"
                shift 2
                ;;
            -I|--interval)
                INTERVAL="$2"
                shift 2
                ;;
            -l|--log)
                LOG_FILE="$2"
                shift 2
                ;;
            -r|--rx-threshold)
                THRESHOLD_RX="$2"
                ENABLE_ALERT=true
                shift 2
                ;;
            -t|--tx-threshold)
                THRESHOLD_TX="$2"
                ENABLE_ALERT=true
                shift 2
                ;;
            -e|--email)
                ALERT_EMAIL="$2"
                ENABLE_ALERT=true
                shift 2
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# 验证网络接口
validate_interface() {
    if ! ip link show "$INTERFACE" >/dev/null 2>&1
    then
        log_error "网络接口不存在: $INTERFACE"
        log_info "可用接口:"
        ip link show | grep -E "^[0-9]+:" | cut -d: -f2 | sed 's/ //g' | while read iface
        do
            log_info "  $iface"
        done
        exit 1
    fi
}

# 获取网络统计信息
get_network_stats() {
    local iface=$1
    local rx_file="/sys/class/net/$iface/statistics/rx_bytes"
    local tx_file="/sys/class/net/$iface/statistics/tx_bytes"
    
    if [ -f "$rx_file" ] && [ -f "$tx_file" ]
    then
        local rx_bytes=$(cat "$rx_file")
        local tx_bytes=$(cat "$tx_file")
        echo "$rx_bytes $tx_bytes"
    else
        log_error "无法读取网络统计信息"
        echo "0 0"
    fi
}

# 计算带宽
calculate_bandwidth() {
    local prev_rx=$1
    local prev_tx=$2
    local curr_rx=$3
    local curr_tx=$4
    local interval=$5
    
    local rx_diff=$((curr_rx - prev_rx))
    local tx_diff=$((curr_tx - prev_tx))
    
    # 转换为 KB/s
    local rx_kbps=$((rx_diff / interval / 1024))
    local tx_kbps=$((tx_diff / interval / 1024))
    
    echo "$rx_kbps $tx_kbps"
}

# 发送告警邮件
send_bandwidth_alert() {
    local rx_kbps=$1
    local tx_kbps=$2
    
    if [ -n "$ALERT_EMAIL" ] && command -v mail &>/dev/null
    then
        local subject="带宽使用告警 - $(hostname)"
        local message="网络带宽使用超过阈值:

接口: $INTERFACE
时间: $(date)
接收带宽: ${rx_kbps} KB/s (阈值: ${THRESHOLD_RX} KB/s)
发送带宽: ${tx_kbps} KB/s (阈值: ${THRESHOLD_TX} KB/s)

请检查网络使用情况。"
        
        echo "$message" | mail -s "$subject" "$ALERT_EMAIL"
        log_info "带宽告警邮件已发送至: $ALERT_EMAIL"
    fi
}

# 显示带宽信息
show_bandwidth_info() {
    local rx_kbps=$1
    local tx_kbps=$2
    
    # 格式化输出
    local rx_display=$(printf "%8s" "$rx_kbps")
    local tx_display=$(printf "%8s" "$tx_kbps")
    
    # 根据阈值显示颜色
    local rx_color=""
    local tx_color=""
    
    if [ "$THRESHOLD_RX" -gt 0 ] && [ "$rx_kbps" -gt "$THRESHOLD_RX" ]
    then
        rx_color="$RED"
    elif [ "$THRESHOLD_RX" -gt 0 ] && [ "$rx_kbps" -gt "$((THRESHOLD_RX * 80 / 100))" ]
    then
        rx_color="$YELLOW"
    else
        rx_color="$GREEN"
    fi
    
    if [ "$THRESHOLD_TX" -gt 0 ] && [ "$tx_kbps" -gt "$THRESHOLD_TX" ]
    then
        tx_color="$RED"
    elif [ "$THRESHOLD_TX" -gt 0 ] && [ "$tx_kbps" -gt "$((THRESHOLD_TX * 80 / 100))" ]
    then
        tx_color="$YELLOW"
    else
        tx_color="$GREEN"
    fi
    
    echo -e "接收: ${rx_color}${rx_display}${NC} KB/s  发送: ${tx_color}${tx_display}${NC} KB/s"
}

# 主监控循环
monitor_bandwidth() {
    log_info "=== 网络带宽监控开始 ==="
    log_info "监控接口: $INTERFACE"
    log_info "监控时长: ${DURATION}秒"
    log_info "采样间隔: ${INTERVAL}秒"
    log_info "接收阈值: ${THRESHOLD_RX} KB/s"
    log_info "发送阈值: ${THRESHOLD_TX} KB/s"
    log_info "告警功能: $([ "$ENABLE_ALERT" = true ] && echo "开启" || echo "关闭")"
    log_info "========================"
    
    # 获取初始统计值
    local prev_stats=($(get_network_stats "$INTERFACE"))
    local prev_rx=${prev_stats[0]}
    local prev_tx=${prev_stats[1]}
    
    local start_time=$(date +%s)
    local end_time=$((start_time + DURATION))
    
    log_info "时间                接收带宽    发送带宽"
    log_info "----------------------------------------"
    
    while [ $(date +%s) -lt $end_time ]
    do
        sleep $INTERVAL
        
        # 获取当前统计值
        local curr_stats=($(get_network_stats "$INTERFACE"))
        local curr_rx=${curr_stats[0]}
        local curr_tx=${curr_stats[1]}
        
        # 计算带宽
        local bandwidth=($(calculate_bandwidth $prev_rx $prev_tx $curr_rx $curr_tx $INTERVAL))
        local rx_kbps=${bandwidth[0]}
        local tx_kbps=${bandwidth[1]}
        
        # 显示带宽信息
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        echo -n "$timestamp  "
        show_bandwidth_info $rx_kbps $tx_kbps
        
        # 记录到日志
        log_info "带宽统计 - 接收: ${rx_kbps} KB/s, 发送: ${tx_kbps} KB/s"
        
        # 检查阈值并发送告警
        if [ "$ENABLE_ALERT" = true ]
        then
            local alert_sent=false
            if [ "$THRESHOLD_RX" -gt 0 ] && [ "$rx_kbps" -gt "$THRESHOLD_RX" ]
            then
                log_warn "接收带宽超过阈值: ${rx_kbps} KB/s > ${THRESHOLD_RX} KB/s"
                alert_sent=true
            fi
            
            if [ "$THRESHOLD_TX" -gt 0 ] && [ "$tx_kbps" -gt "$THRESHOLD_TX" ]
            then
                log_warn "发送带宽超过阈值: ${tx_kbps} KB/s > ${THRESHOLD_TX} KB/s"
                alert_sent=true
            fi
            
            if [ "$alert_sent" = true ] && [ -n "$ALERT_EMAIL" ]
            then
                send_bandwidth_alert $rx_kbps $tx_kbps
            fi
        fi
        
        # 更新前一次的值
        prev_rx=$curr_rx
        prev_tx=$curr_tx
    done
    
    log_info "========================"
    log_info "=== 网络带宽监控结束 ==="
}

# 主函数
main() {
    parse_args "$@"
    validate_interface
    
    # 创建日志目录（如果需要）
    local log_dir=$(dirname "$LOG_FILE")
    if [ ! -d "$log_dir" ]
    then
        mkdir -p "$log_dir" 2>/dev/null
    fi
    
    monitor_bandwidth
}

# 信号处理
trap 'log_info "带宽监控被中断"; exit 0' INT TERM

# 执行主函数
main "$@"
```

## 网络配置管理脚本

### 网络接口配置脚本

```bash
#!/bin/bash

# 网络接口配置脚本
# 文件名: network_config.sh

# 配置参数
INTERFACE=""
ACTION=""
IP_ADDRESS=""
NETMASK=""
GATEWAY=""
DNS_SERVERS=()
ENABLE_DHCP=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# 显示帮助信息
show_help() {
    echo "网络接口配置脚本"
    echo "用法: $0 [选项] <接口名称> <操作>"
    echo "操作:"
    echo "  show     显示接口配置信息"
    echo "  up       启用接口"
    echo "  down     禁用接口"
    echo "  config   配置接口IP地址"
    echo "  dhcp     启用DHCP"
    echo
    echo "选项:"
    echo "  -i, --ip ADDRESS     IP地址"
    echo "  -n, --netmask MASK   子网掩码"
    echo "  -g, --gateway GW     网关地址"
    echo "  -d, --dns SERVER     DNS服务器 (可多次指定)"
    echo "  -h, --help           显示此帮助信息"
    echo
    echo "示例:"
    echo "  $0 eth0 show"
    echo "  $0 eth0 config -i 192.168.1.100 -n 255.255.255.0 -g 192.168.1.1"
    echo "  $0 eth0 dhcp"
    echo "  $0 eth0 up"
}

# 解析命令行参数
parse_args() {
    if [ $# -lt 2 ]
    then
        show_help
        exit 1
    fi
    
    INTERFACE="$1"
    ACTION="$2"
    shift 2
    
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -i|--ip)
                IP_ADDRESS="$2"
                shift 2
                ;;
            -n|--netmask)
                NETMASK="$2"
                shift 2
                ;;
            -g|--gateway)
                GATEWAY="$2"
                shift 2
                ;;
            -d|--dns)
                DNS_SERVERS+=("$2")
                shift 2
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# 验证权限
check_permissions() {
    if [ "$EUID" -ne 0 ]
    then
        log_error "此脚本需要root权限运行"
        exit 1
    fi
}

# 验证网络接口
validate_interface() {
    if ! ip link show "$INTERFACE" >/dev/null 2>&1
    then
        log_error "网络接口不存在: $INTERFACE"
        log_info "可用接口:"
        ip link show | grep -E "^[0-9]+:" | cut -d: -f2 | sed 's/ //g' | while read iface
        do
            log_info "  $iface"
        done
        exit 1
    fi
}

# 显示接口信息
show_interface_info() {
    log_info "接口信息: $INTERFACE"
    log_info "=================="
    
    # 显示接口状态
    local state=$(ip link show "$INTERFACE" | grep -o "state [A-Z]*" | cut -d' ' -f2)
    log_info "状态: $state"
    
    # 显示IP地址
    log_info "IP地址:"
    ip addr show "$INTERFACE" | grep "inet " | while read line
    do
        log_info "  $line"
    done
    
    # 显示统计信息
    log_info "统计信息:"
    ip -s link show "$INTERFACE" | tail -n +3 | head -2 | while read line
    do
        log_info "  $line"
    done
}

# 启用接口
enable_interface() {
    log_info "启用接口: $INTERFACE"
    
    if ip link set "$INTERFACE" up
    then
        log_success "接口已启用"
    else
        log_error "启用接口失败"
        exit 1
    fi
}

# 禁用接口
disable_interface() {
    log_info "禁用接口: $INTERFACE"
    
    if ip link set "$INTERFACE" down
    then
        log_success "接口已禁用"
    else
        log_error "禁用接口失败"
        exit 1
    fi
}

# 配置静态IP
configure_static_ip() {
    if [ -z "$IP_ADDRESS" ]
    then
        log_error "必须指定IP地址"
        exit 1
    fi
    
    log_info "配置静态IP: $INTERFACE"
    log_info "IP地址: $IP_ADDRESS"
    log_info "子网掩码: ${NETMASK:-自动检测}"
    log_info "网关: ${GATEWAY:-未指定}"
    
    # 构建CIDR表示法
    local cidr="$IP_ADDRESS"
    if [ -n "$NETMASK" ]
    then
        # 将子网掩码转换为CIDR
        local cidr_prefix=$(netmask_to_cidr "$NETMASK")
        cidr="$IP_ADDRESS/$cidr_prefix"
    else
        cidr="$IP_ADDRESS/24"  # 默认/24
    fi
    
    # 配置IP地址
    if ip addr add "$cidr" dev "$INTERFACE"
    then
        log_success "IP地址配置成功: $cidr"
    else
        log_error "IP地址配置失败"
        exit 1
    fi
    
    # 配置网关（如果有指定）
    if [ -n "$GATEWAY" ]
    then
        log_info "配置默认网关: $GATEWAY"
        # 删除现有默认路由
        ip route del default 2>/dev/null
        # 添加新默认路由
        if ip route add default via "$GATEWAY" dev "$INTERFACE"
        then
            log_success "默认网关配置成功"
        else
            log_error "默认网关配置失败"
        fi
    fi
    
    # 配置DNS（如果有指定）
    if [ ${#DNS_SERVERS[@]} -gt 0 ]
    then
        configure_dns
    fi
}

# 配置DHCP
configure_dhcp() {
    log_info "启用DHCP: $INTERFACE"
    
    # 使用dhclient获取IP地址
    if command -v dhclient &>/dev/null
    then
        if dhclient "$INTERFACE"
        then
            log_success "DHCP配置成功"
        else
            log_error "DHCP配置失败"
            exit 1
        fi
    elif command -v dhcpcd &>/dev/null
    then
        if dhcpcd "$INTERFACE"
        then
            log_success "DHCP配置成功"
        else
            log_error "DHCP配置失败"
            exit 1
        fi
    else
        log_error "未找到DHCP客户端 (dhclient 或 dhcpcd)"
        exit 1
    fi
}

# 配置DNS
configure_dns() {
    local resolv_conf="/etc/resolv.conf"
    local backup_conf="/etc/resolv.conf.backup"
    
    log_info "配置DNS服务器"
    
    # 备份原配置
    if [ ! -f "$backup_conf" ]
    then
        cp "$resolv_conf" "$backup_conf"
        log_info "备份原DNS配置到: $backup_conf"
    fi
    
    # 创建新的resolv.conf
    echo "# Generated by network_config.sh" > "$resolv_conf"
    for dns in "${DNS_SERVERS[@]}"
    do
        echo "nameserver $dns" >> "$resolv_conf"
        log_info "添加DNS服务器: $dns"
    done
    
    log_success "DNS配置完成"
}

# 子网掩码转CIDR
netmask_to_cidr() {
    local netmask=$1
    local cidr=0
    
    # 将子网掩码转换为二进制并计算1的个数
    IFS='.' read -ra octets <<< "$netmask"
    for octet in "${octets[@]}"
    do
        local binary=$(echo "obase=2; $octet" | bc)
        cidr=$((cidr + $(echo "$binary" | grep -o "1" | wc -l)))
    done
    
    echo "$cidr"
}

# 主函数
main() {
    parse_args "$@"
    check_permissions
    validate_interface
    
    log_info "=== 网络接口配置脚本 ==="
    log_info "接口: $INTERFACE"
    log_info "操作: $ACTION"
    log_info "时间: $(date)"
    log_info "========================"
    
    case $ACTION in
        show)
            show_interface_info
            ;;
        up)
            enable_interface
            ;;
        down)
            disable_interface
            ;;
        config)
            configure_static_ip
            ;;
        dhcp)
            configure_dhcp
            ;;
        *)
            log_error "未知操作: $ACTION"
            show_help
            exit 1
            ;;
    esac
    
    log_info "========================"
    log_info "=== 操作完成 ==="
}

# 执行主函数
main "$@"
```

## 网络安全脚本

### 端口扫描和安全检查脚本

```bash
#!/bin/bash

# 网络安全检查脚本
# 文件名: network_security_check.sh

# 配置参数
TARGET_HOST="localhost"
PORT_RANGE="1-1000"
SCAN_TYPE="tcp"
OUTPUT_FORMAT="text"
OUTPUT_FILE=""
VERBOSE=false

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 日志函数
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# 显示帮助信息
show_help() {
    echo "网络安全检查脚本"
    echo "用法: $0 [选项] [目标主机]"
    echo
    echo "选项:"
    echo "  -p, --ports RANGE      端口范围 (默认: 1-1000)"
    echo "  -t, --type TYPE        扫描类型 (tcp, udp, both)"
    echo "  -o, --output FILE      输出文件"
    echo "  -f, --format FORMAT    输出格式 (text, json, xml)"
    echo "  -v, --verbose          详细输出模式"
    echo "  -h, --help             显示此帮助信息"
    echo
    echo "示例:"
    echo "  $0 192.168.1.1"
    echo "  $0 -p 1-65535 -t both scan.example.com"
    echo "  $0 -o report.txt -f json 10.0.0.1"
}

# 解析命令行参数
parse_args() {
    while [[ $# -gt 0 ]]
    do
        case $1 in
            -p|--ports)
                PORT_RANGE="$2"
                shift 2
                ;;
            -t|--type)
                SCAN_TYPE="$2"
                shift 2
                ;;
            -o|--output)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            -f|--format)
                OUTPUT_FORMAT="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            -*)
                log_error "未知参数: $1"
                show_help
                exit 1
                ;;
            *)
                if [ -z "$TARGET_HOST" ] || [ "$TARGET_HOST" = "localhost" ]
                then
                    TARGET_HOST="$1"
                else
                    log_error "参数过多"
                    show_help
                    exit 1
                fi
                shift
                ;;
        esac
    done
}

# 验证参数
validate_args() {
    # 验证端口范围
    if [[ ! "$PORT_RANGE" =~ ^[0-9]+-[0-9]+$ ]]
    then
        log_error "无效的端口范围格式: $PORT_RANGE"
        log_info "正确格式: start-end (例如: 1-1000)"
        exit 1
    fi
    
    # 验证扫描类型
    if [[ ! "$SCAN_TYPE" =~ ^(tcp|udp|both)$ ]]
    then
        log_error "无效的扫描类型: $SCAN_TYPE"
        log_info "有效类型: tcp, udp, both"
        exit 1
    fi
    
    # 验证输出格式
    if [[ ! "$OUTPUT_FORMAT" =~ ^(text|json|xml)$ ]]
    then
        log_error "无效的输出格式: $OUTPUT_FORMAT"
        log_info "有效格式: text, json, xml"
        exit 1
    fi
}

# TCP端口扫描
scan_tcp_ports() {
    local host=$1
    local start_port=$2
    local end_port=$3
    
    log_info "开始TCP端口扫描: $host ($start_port-$end_port)"
    
    local open_ports=()
    local closed_ports=0
    
    for port in $(seq $start_port $end_port)
    do
        if timeout 1 bash -c "echo >/dev/tcp/$host/$port" 2>/dev/null
        then
            open_ports+=($port)
            if [ "$VERBOSE" = true ]
            then
                log_success "端口 $port 开放"
            fi
        else
            closed_ports=$((closed_ports + 1))
            if [ "$VERBOSE" = true ]
            then
                log_info "端口 $port 关闭"
            fi
        fi
        
        # 每100个端口显示进度
        if [ $((port % 100)) -eq 0 ] && [ "$VERBOSE" = false ]
        then
            local progress=$(( (port - start_port + 1) * 100 / (end_port - start_port + 1) ))
            log_info "扫描进度: $progress%"
        fi
    done
    
    log_success "TCP扫描完成: ${#open_ports[@]} 个开放端口"
    
    # 显示开放端口
    if [ ${#open_ports[@]} -gt 0 ]
    then
        log_info "开放的TCP端口:"
        for port in "${open_ports[@]}"
        do
            # 尝试识别服务
            local service="未知"
            case $port in
                22) service="SSH" ;;
                80) service="HTTP" ;;
                443) service="HTTPS" ;;
                21) service="FTP" ;;
                25) service="SMTP" ;;
                110) service="POP3" ;;
                143) service="IMAP" ;;
                3306) service="MySQL" ;;
                5432) service="PostgreSQL" ;;
                6379) service="Redis" ;;
                27017) service="MongoDB" ;;
            esac
            log_success "  $port ($service)"
        done
    fi
    
    echo "${open_ports[@]}"
}

# UDP端口扫描
scan_udp_ports() {
    local host=$1
    local start_port=$2
    local end_port=$3
    
    log_info "开始UDP端口扫描: $host ($start_port-$end_port)"
    log_warn "UDP扫描可能不准确，因为UDP是无连接协议"
    
    local open_ports=()
    
    # 简单的UDP扫描（仅检查是否能发送数据）
    for port in $(seq $start_port $end_port)
    do
        if command -v nc &>/dev/null
        then
            if timeout 1 nc -u -z "$host" $port 2>/dev/null
            then
                open_ports+=($port)
                if [ "$VERBOSE" = true ]
                then
                    log_success "端口 $port 可能开放 (UDP)"
                fi
            elif [ "$VERBOSE" = true ]
            then
                log_info "端口 $port 关闭 (UDP)"
            fi
        else
            # 如果没有nc命令，跳过UDP扫描
            log_warn "nc命令不可用，跳过UDP扫描"
            break
        fi
    done
    
    log_success "UDP扫描完成: ${#open_ports[@]} 个可能开放的端口"
    
    # 显示开放端口
    if [ ${#open_ports[@]} -gt 0 ]
    then
        log_info "可能开放的UDP端口:"
        for port in "${open_ports[@]}"
        do
            log_success "  $port"
        done
    fi
    
    echo "${open_ports[@]}"
}

# 检查常见安全问题
check_security_issues() {
    local host=$1
    local open_tcp_ports=($2)
    
    log_info "安全检查开始"
    
    # 检查不安全的端口
    local insecure_ports=(23 135 139 445 1433 3389)
    local found_insecure=false
    
    for port in "${insecure_ports[@]}"
    do
        for open_port in "${open_tcp_ports[@]}"
        do
            if [ "$port" = "$open_port" ]
            then
                case $port in
                    23) service="Telnet" ;;
                    135) service="RPC" ;;
                    139) service="NetBIOS" ;;
                    445) service="SMB" ;;
                    1433) service="MSSQL" ;;
                    3389) service="RDP" ;;
                esac
                log_warn "发现不安全的端口: $port ($service)"
                found_insecure=true
            fi
        done
    done
    
    if [ "$found_insecure" = false ]
    then
        log_success "未发现明显的不安全端口"
    fi
    
    # 检查SSH端口
    for port in "${open_tcp_ports[@]}"
    do
        if [ "$port" = "22" ]
        then
            log_info "发现SSH服务 (端口 22)"
            log_info "建议: 确保使用强密码或密钥认证，考虑更改默认端口"
        fi
    done
    
    # 检查Web服务
    for port in "${open_tcp_ports[@]}"
    do
        if [ "$port" = "80" ] || [ "$port" = "443" ]
        then
            local protocol="HTTP"
            [ "$port" = "443" ] && protocol="HTTPS"
            log_info "发现Web服务 (端口 $port - $protocol)"
            log_info "建议: 确保使用最新的安全补丁，配置适当的防火墙规则"
        fi
    done
}

# 生成报告
generate_report() {
    local host=$1
    local tcp_ports=$2
    local udp_ports=$3
    local format=$4
    local output_file=$5
    
    local report_content=""
    
    case $format in
        text)
            report_content="网络安全扫描报告
==================
目标主机: $host
扫描时间: $(date)
TCP开放端口: $tcp_ports
UDP开放端口: $udp_ports

详细信息:
[TCP端口详情]
$(for port in $tcp_ports; do
    case $port in
        22) service="SSH" ;;
        80) service="HTTP" ;;
        443) service="HTTPS" ;;
        *) service="未知" ;;
    esac
    echo "  $port ($service)"
done)

[安全建议]
$(if [[ "$tcp_ports" =~ "23" ]]; then echo "  - 发现Telnet服务，建议使用SSH替代"; fi)
$(if [[ "$tcp_ports" =~ "22" ]]; then echo "  - 确保SSH使用强认证方式"; fi)
"
            ;;
        json)
            report_content="{
  \"target\": \"$host\",
  \"scan_time\": \"$(date -Iseconds)\",
  \"tcp_ports\": [$(echo $tcp_ports | sed 's/ /, /g')],
  \"udp_ports\": [$(echo $udp_ports | sed 's/ /, /g')]
}"
            ;;
        xml)
            report_content="<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<scan_report>
  <target>$host</target>
  <scan_time>$(date -Iseconds)</scan_time>
  <tcp_ports>$(for port in $tcp_ports; do echo "    <port>$port</port>"; done)</tcp_ports>
  <udp_ports>$(for port in $udp_ports; do echo "    <port>$port</port>"; done)</udp_ports>
</scan_report>"
            ;;
    esac
    
    if [ -n "$output_file" ]
    then
        echo "$report_content" > "$output_file"
        log_success "报告已保存到: $output_file"
    else
        echo "$report_content"
    fi
}

# 主函数
main() {
    parse_args "$@"
    validate_args
    
    log_info "=== 网络安全检查脚本 ==="
    log_info "目标主机: $TARGET_HOST"
    log_info "端口范围: $PORT_RANGE"
    log_info "扫描类型: $SCAN_TYPE"
    log_info "输出格式: $OUTPUT_FORMAT"
    log_info "详细模式: $([ "$VERBOSE" = true ] && echo "开启" || echo "关闭")"
    log_info "开始时间: $(date)"
    log_info "========================"
    
    # 解析端口范围
    local start_port=$(echo "$PORT_RANGE" | cut -d'-' -f1)
    local end_port=$(echo "$PORT_RANGE" | cut -d'-' -f2)
    
    # 执行扫描
    local tcp_open_ports=""
    local udp_open_ports=""
    
    if [ "$SCAN_TYPE" = "tcp" ] || [ "$SCAN_TYPE" = "both" ]
    then
        tcp_open_ports=$(scan_tcp_ports "$TARGET_HOST" $start_port $end_port)
    fi
    
    if [ "$SCAN_TYPE" = "udp" ] || [ "$SCAN_TYPE" = "both" ]
    then
        udp_open_ports=$(scan_udp_ports "$TARGET_HOST" $start_port $end_port)
    fi
    
    echo
    
    # 安全检查
    check_security_issues "$TARGET_HOST" "$tcp_open_ports"
    
    echo
    
    # 生成报告
    generate_report "$TARGET_HOST" "$tcp_open_ports" "$udp_open_ports" "$OUTPUT_FORMAT" "$OUTPUT_FILE"
    
    log_info "========================"
    log_info "=== 安全检查完成 ==="
    log_info "结束时间: $(date)"
}

# 执行主函数
main "$@"
```

## 最佳实践

1. **权限管理**：网络管理脚本通常需要root权限，确保只在必要时以root身份运行
2. **安全考虑**：避免在脚本中硬编码敏感信息，如密码和密钥
3. **错误处理**：添加适当的错误处理机制，确保脚本稳定运行
4. **日志记录**：详细记录网络操作过程，便于问题排查和审计
5. **测试验证**：在生产环境使用前充分测试脚本
6. **资源控制**：避免脚本消耗过多网络或系统资源
7. **通知机制**：设置适当的告警和通知机制
8. **备份配置**：在修改网络配置前备份原配置

## 总结

网络管理脚本是现代系统管理的重要工具。通过本章的学习，你应该掌握了：

1. 网络连接监控脚本的编写方法
2. 网络带宽监控脚本的实现
3. 网络接口配置脚本的开发
4. 网络安全检查脚本的使用
5. 实际应用场景和最佳实践

这些脚本可以帮助你自动化网络管理任务，提高网络管理效率和可靠性。在下一章中，我们将学习自动化安装脚本，进一步增强系统部署能力。