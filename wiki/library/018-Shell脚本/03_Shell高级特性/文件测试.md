# 文件测试

## 文件测试概述

在Shell脚本编程中，文件测试是一项重要功能，它允许我们检查文件和目录的各种属性，如是否存在、是否可读、是否可写等。通过文件测试，我们可以编写更加健壮和智能的脚本，根据文件状态做出相应的处理。

## 基本文件测试操作符

Shell提供了丰富的文件测试操作符，用于检查文件的各种属性：

### 文件类型测试

```bash
#!/bin/bash

file="/etc/passwd"

# 检查文件是否存在
if [ -e "$file" ]
then
    echo "文件 $file 存在"
else
    echo "文件 $file 不存在"
fi

# 检查是否为普通文件
if [ -f "$file" ]
then
    echo "$file 是普通文件"
fi

# 检查是否为目录
if [ -d "/etc" ]
then
    echo "/etc 是目录"
fi

# 检查是否为符号链接
if [ -L "/dev/stdin" ] 2>/dev/null
then
    echo "/dev/stdin 是符号链接"
fi

# 检查是否为字符设备
if [ -c "/dev/null" ]
then
    echo "/dev/null 是字符设备"
fi

# 检查是否为块设备
if [ -b "/dev/sda" ] 2>/dev/null
then
    echo "/dev/sda 是块设备"
fi

# 检查是否为命名管道
if [ -p "/dev/fd/0" ] 2>/dev/null
then
    echo "/dev/fd/0 是命名管道"
fi

# 检查是否为套接字
# if [ -S "/var/run/docker.sock" ] 2>/dev/null
# then
#     echo "/var/run/docker.sock 是套接字"
# fi
```

### 文件权限测试

```bash
#!/bin/bash

file="/etc/passwd"

# 检查文件是否可读
if [ -r "$file" ]
then
    echo "$file 可读"
else
    echo "$file 不可读"
fi

# 检查文件是否可写
if [ -w "$file" ]
then
    echo "$file 可写"
else
    echo "$file 不可写"
fi

# 检查文件是否可执行
if [ -x "$file" ]
then
    echo "$file 可执行"
else
    echo "$file 不可执行"
fi

# 检查文件是否有suid位
if [ -u "/usr/bin/sudo" ] 2>/dev/null
then
    echo "/usr/bin/sudo 有suid位"
fi

# 检查文件是否有sgid位
if [ -g "/usr/bin/ssh" ] 2>/dev/null
then
    echo "/usr/bin/ssh 有sgid位"
fi

# 检查文件是否有粘滞位
if [ -k "/tmp" ]
then
    echo "/tmp 有粘滞位"
fi
```

### 文件大小和时间测试

```bash
#!/bin/bash

file="/etc/passwd"

# 检查文件是否为空
if [ -s "$file" ]
then
    echo "$file 非空"
else
    echo "$file 为空"
fi

# 获取文件大小（字节）
if [ -f "$file" ]
then
    size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
    echo "$file 大小: $size 字节"
fi

# 使用stat命令获取详细信息
if [ -e "$file" ]
then
    echo "文件详细信息:"
    stat "$file" 2>/dev/null || ls -l "$file"
fi
```

## 组合文件测试

可以使用逻辑运算符组合多个文件测试条件：

```bash
#!/bin/bash

file="test.txt"

# 检查文件是否存在且可读
if [ -e "$file" ] && [ -r "$file" ]
then
    echo "文件 $file 存在且可读"
fi

# 检查文件是否不存在或不可写
if [ ! -e "$file" ] || [ ! -w "$file" ]
then
    echo "文件 $file 不存在或不可写"
fi

# 使用[[ ]]进行更复杂的测试
if [[ -f "$file" && -r "$file" && -w "$file" ]]
then
    echo "文件 $file 存在且可读可写"
fi
```

## 文件测试的实际应用

### 文件备份脚本

```bash
#!/bin/bash

# 文件备份函数
backup_file() {
    local source_file=$1
    local backup_dir=${2:-"./backups"}
    
    # 检查源文件
    if [ ! -e "$source_file" ]
    then
        echo "错误: 源文件 $source_file 不存在"
        return 1
    fi
    
    if [ ! -f "$source_file" ]
    then
        echo "错误: $source_file 不是普通文件"
        return 1
    fi
    
    if [ ! -r "$source_file" ]
    then
        echo "错误: 源文件 $source_file 不可读"
        return 1
    fi
    
    # 创建备份目录
    if [ ! -d "$backup_dir" ]
    then
        echo "创建备份目录: $backup_dir"
        mkdir -p "$backup_dir"
        
        if [ $? -ne 0 ]
        then
            echo "错误: 无法创建备份目录 $backup_dir"
            return 1
        fi
    fi
    
    # 检查备份目录是否可写
    if [ ! -w "$backup_dir" ]
    then
        echo "错误: 备份目录 $backup_dir 不可写"
        return 1
    fi
    
    # 生成备份文件名
    local filename=$(basename "$source_file")
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="${backup_dir}/${filename}_${timestamp}.bak"
    
    # 执行备份
    if cp "$source_file" "$backup_file"
    then
        echo "文件已备份到: $backup_file"
        
        # 获取备份文件信息
        local size=$(stat -c%s "$backup_file" 2>/dev/null || stat -f%z "$backup_file" 2>/dev/null)
        echo "备份文件大小: $size 字节"
        return 0
    else
        echo "错误: 备份失败"
        return 1
    fi
}

# 测试备份功能
echo "=== 文件备份测试 ==="
backup_file "/etc/hosts" "./backups"
```

### 目录监控脚本

```bash
#!/bin/bash

# 目录监控函数
monitor_directory() {
    local dir=$1
    local max_size=${2:-1048576}  # 默认1MB
    
    # 检查目录是否存在
    if [ ! -e "$dir" ]
    then
        echo "错误: 目录 $dir 不存在"
        return 1
    fi
    
    if [ ! -d "$dir" ]
    then
        echo "错误: $dir 不是目录"
        return 1
    fi
    
    # 检查目录权限
    if [ ! -r "$dir" ]
    then
        echo "错误: 目录 $dir 不可读"
        return 1
    fi
    
    # 获取目录信息
    echo "=== 目录监控报告: $dir ==="
    
    # 目录大小
    local dir_size=$(du -sb "$dir" 2>/dev/null | cut -f1)
    echo "目录大小: $dir_size 字节 ($(echo "scale=2; $dir_size/1024/1024" | bc) MB)"
    
    if [ $dir_size -gt $max_size ]
    then
        echo "警告: 目录大小超过限制 ($max_size 字节)"
    fi
    
    # 文件数量
    local file_count=$(find "$dir" -type f 2>/dev/null | wc -l)
    echo "文件数量: $file_count"
    
    # 目录数量
    local dir_count=$(find "$dir" -type d 2>/dev/null | wc -l)
    echo "子目录数量: $dir_count"
    
    # 最大文件
    echo "最大的5个文件:"
    find "$dir" -type f -exec du -h {} + 2>/dev/null | sort -rh | head -5
    
    # 最近修改的文件
    echo "最近修改的5个文件:"
    find "$dir" -type f -exec stat -c "%Y %n" {} + 2>/dev/null | sort -nr | head -5 | while read timestamp filename
    do
        echo "  $(date -d @$timestamp) $filename"
    done
    
    # 权限异常文件
    echo "权限异常文件（777权限）:"
    find "$dir" -type f -perm 777 2>/dev/null | head -5
    
    # 空文件
    echo "空文件:"
    find "$dir" -type f -empty 2>/dev/null | head -5
}

# 测试目录监控
echo "=== 目录监控测试 ==="
monitor_directory "/tmp" 5242880  # 5MB限制
```

### 文件清理脚本

```bash
#!/bin/bash

# 文件清理函数
cleanup_files() {
    local dir=$1
    local days=${2:-7}  # 默认清理7天前的文件
    local dry_run=${3:-false}  # 是否为试运行
    
    # 检查目录
    if [ ! -d "$dir" ]
    then
        echo "错误: $dir 不是有效目录"
        return 1
    fi
    
    if [ ! -r "$dir" ] || [ ! -w "$dir" ]
    then
        echo "错误: 目录 $dir 权限不足"
        return 1
    fi
    
    echo "=== 文件清理报告 ==="
    echo "目标目录: $dir"
    echo "清理条件: $days 天前修改的文件"
    echo "试运行模式: $dry_run"
    echo
    
    # 查找需要清理的文件
    local files_to_delete=()
    while IFS= read -r -d '' file
    do
        files_to_delete+=("$file")
    done < <(find "$dir" -type f -mtime +$days -print0 2>/dev/null)
    
    # 显示要删除的文件
    echo "找到 ${#files_to_delete[@]} 个文件需要清理:"
    local total_size=0
    
    for file in "${files_to_delete[@]}"
    do
        if [ -f "$file" ] && [ -r "$file" ]
        then
            local size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
            total_size=$((total_size + size))
            echo "  $(ls -lh "$file" | awk '{print $5, $6, $7, $8, $9}')"
        fi
    done
    
    echo "总计: $(echo "scale=2; $total_size/1024/1024" | bc) MB"
    
    # 执行删除操作
    if [ "${#files_to_delete[@]}" -gt 0 ]
    then
        if [ "$dry_run" = false ]
        then
            echo
            read -p "确认删除这些文件吗? (y/N): " confirm
            if [[ $confirm =~ ^[Yy]$ ]]
            then
                local deleted_count=0
                for file in "${files_to_delete[@]}"
                do
                    if rm "$file" 2>/dev/null
                    then
                        echo "已删除: $file"
                        deleted_count=$((deleted_count + 1))
                    else
                        echo "删除失败: $file"
                    fi
                done
                echo "清理完成: $deleted_count 个文件已删除"
            else
                echo "操作已取消"
            fi
        else
            echo "试运行模式: 未执行实际删除操作"
        fi
    else
        echo "没有需要清理的文件"
    fi
}

# 创建测试文件
mkdir -p ./test_cleanup
for i in {1..5}
do
    echo "Test content $i" > "./test_cleanup/test_file_$i.txt"
    # 修改文件时间戳为3天前
    touch -d "3 days ago" "./test_cleanup/test_file_$i.txt"
done

# 测试清理功能（试运行模式）
echo "=== 文件清理测试 ==="
cleanup_files "./test_cleanup" 2 true

# 清理测试文件
rm -rf ./test_cleanup
```

## 高级文件测试技巧

### 使用find命令进行复杂文件测试

```bash
#!/bin/bash

# 复杂文件查找示例
search_files() {
    local search_dir=${1:-"."}
    
    echo "=== 复杂文件查找 ==="
    
    # 查找大文件（大于1MB）
    echo "大于1MB的文件:"
    find "$search_dir" -type f -size +1M -exec ls -lh {} \; | head -5
    
    # 查找最近修改的文件
    echo "最近1小时内修改的文件:"
    find "$search_dir" -type f -mmin -60 2>/dev/null | head -5
    
    # 查找特定权限的文件
    echo "权限为777的文件:"
    find "$search_dir" -type f -perm 777 2>/dev/null | head -5
    
    # 查找空文件
    echo "空文件:"
    find "$search_dir" -type f -empty 2>/dev/null | head -5
    
    # 查找特定类型的文件
    echo "可执行文件:"
    find "$search_dir" -type f -executable 2>/dev/null | head -5
    
    # 查找特定用户拥有的文件
    echo "当前用户拥有的文件:"
    find "$search_dir" -type f -user "$USER" 2>/dev/null | head -5
}

# 执行搜索
search_files "/tmp"
```

### 文件完整性检查

```bash
#!/bin/bash

# 文件完整性检查函数
check_file_integrity() {
    local file=$1
    
    # 基本检查
    if [ ! -e "$file" ]
    then
        echo "错误: 文件 $file 不存在"
        return 1
    fi
    
    if [ ! -f "$file" ]
    then
        echo "错误: $file 不是普通文件"
        return 1
    fi
    
    # 权限检查
    echo "=== 文件完整性检查: $file ==="
    
    # 文件大小
    local size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
    echo "文件大小: $size 字节"
    
    # 文件类型
    local file_type=$(file -b "$file")
    echo "文件类型: $file_type"
    
    # 校验和
    if command -v md5sum >/dev/null 2>&1
    then
        local md5=$(md5sum "$file" | cut -d' ' -f1)
        echo "MD5校验和: $md5"
    elif command -v md5 >/dev/null 2>&1
    then
        local md5=$(md5 -q "$file")
        echo "MD5校验和: $md5"
    fi
    
    # 修改时间
    local mtime=$(stat -c%y "$file" 2>/dev/null || stat -f%Sm -t "%Y-%m-%d %H:%M:%S" "$file" 2>/dev/null)
    echo "最后修改时间: $mtime"
    
    # 访问时间
    local atime=$(stat -c%x "$file" 2>/dev/null || stat -f%Sa -t "%Y-%m-%d %H:%M:%S" "$file" 2>/dev/null)
    echo "最后访问时间: $atime"
    
    # 权限信息
    local permissions=$(ls -l "$file" | cut -d' ' -f1)
    echo "文件权限: $permissions"
    
    # 所有者信息
    local owner=$(ls -l "$file" | awk '{print $3":"$4}')
    echo "所有者: $owner"
    
    echo "检查完成"
}

# 测试文件完整性检查
check_file_integrity "/etc/hosts"
```

## 最佳实践

1. **始终检查文件是否存在**：在操作文件前使用`-e`或`-f`检查
2. **验证文件权限**：使用`-r`、`-w`、`-x`检查相应权限
3. **处理边界情况**：考虑文件为空、权限不足等情况
4. **使用适当工具**：复杂文件操作考虑使用find、stat等命令
5. **错误处理**：对文件操作添加适当的错误处理机制
6. **安全性考虑**：避免路径遍历等安全问题
7. **跨平台兼容**：注意不同系统stat命令的差异

## 总结

文件测试是Shell脚本中不可或缺的功能，它帮助我们编写更加健壮和智能的脚本。通过本章的学习，你应该掌握了：

1. 基本文件测试操作符的使用
2. 文件类型、权限、大小等属性的检查
3. 组合条件测试的方法
4. 实际应用场景（备份、监控、清理等）
5. 高级文件测试技巧

掌握这些文件测试技能将大大提高你编写Shell脚本处理文件和目录的能力。在下一章中，我们将学习正则表达式，进一步增强脚本的模式匹配能力。

