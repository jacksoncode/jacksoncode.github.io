# 函数的定义与调用

## 什么是函数

函数是将一组相关命令组合在一起的代码块，可以通过函数名多次调用执行。在Shell脚本中，函数提供了一种将复杂任务分解为更小、更易管理的模块的方法，有助于提高代码的可读性、可维护性和可重用性。

## 函数的定义

在Shell中有两种定义函数的语法：

### 方法一：使用function关键字

```bash
function function_name {
    # 函数体
    commands
}
```

### 方法二：不使用function关键字

```bash
function_name() {
    # 函数体
    commands
}
```

两种方法都是有效的，但第二种方法更符合POSIX标准，兼容性更好。

## 函数的基本示例

```bash
#!/bin/bash

# 定义一个简单的函数
function greet {
    echo "你好, 世界!"
}

# 另一种定义方式
say_goodbye() {
    echo "再见!"
}

# 调用函数
greet
say_goodbye
```

## 函数参数

函数可以接收参数，参数在函数内部通过特殊变量访问：

- `$1`, `$2`, `$3` ... 分别表示第1个、第2个、第3个参数
- `$#` 表示参数的个数
- `$@` 表示所有参数
- `$*` 也表示所有参数，但在某些情况下与`$@`有区别

```bash
#!/bin/bash

# 带参数的函数
greet_person() {
    local name=$1
    local age=$2
    
    echo "你好, $name!"
    if [ -n "$age" ]
    then
        echo "你的年龄是 $age 岁"
    fi
}

# 调用带参数的函数
greet_person "张三"
greet_person "李四" 25

# 处理多个参数的函数
sum_numbers() {
    local sum=0
    echo "参数个数: $#"
    echo "所有参数: $@"
    
    for num in "$@"
    do
        sum=$((sum + num))
    done
    
    echo "总和: $sum"
}

# 调用函数
sum_numbers 1 2 3 4 5
```

## 函数返回值

Shell函数有两种返回值机制：

### 1. 使用return语句返回状态码

```bash
#!/bin/bash

# 返回状态码的函数
check_file() {
    local file=$1
    
    if [ -f "$file" ]
    then
        echo "文件存在"
        return 0  # 成功
    else
        echo "文件不存在"
        return 1  # 失败
    fi
}

# 调用函数并检查返回值
if check_file "/etc/passwd"
then
    echo "检查通过"
else
    echo "检查失败"
fi
```

### 2. 使用echo输出结果值

```bash
#!/bin/bash

# 返回计算结果的函数
calculate_square() {
    local num=$1
    echo $((num * num))
}

# 获取函数返回值
result=$(calculate_square 5)
echo "5的平方是: $result"

# 直接在命令中使用函数输出
echo "3的平方是: $(calculate_square 3)"
```

## 局部变量和全局变量

在函数中正确使用局部变量和全局变量非常重要：

```bash
#!/bin/bash

# 全局变量
global_var="我是全局变量"

function test_variables {
    # 局部变量
    local local_var="我是局部变量"
    
    # 修改全局变量
    global_var="我在函数中被修改了"
    
    echo "函数内部:"
    echo "  全局变量: $global_var"
    echo "  局部变量: $local_var"
    
    # 定义另一个局部变量
    local another_local="另一个局部变量"
    echo "  另一个局部变量: $another_local"
}

# 调用函数
test_variables

echo "函数外部:"
echo "  全局变量: $global_var"
# echo "  局部变量: $local_var"  # 这会报错，局部变量在函数外不可访问
```

## 函数库的创建和使用

可以将常用的函数保存在单独的文件中，作为函数库使用：

```bash
# 文件: utils.sh
# 实用函数库

# 颜色定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# 彩色输出函数
print_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 日志记录函数
log_message() {
    local level=$1
    local message=$2
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$level] $message" >> script.log
}

# 文件备份函数
backup_file() {
    local file=$1
    local backup_name="${file}_$(date +%Y%m%d_%H%M%S).bak"
    
    if [ -f "$file" ]
    then
        cp "$file" "$backup_name"
        print_info "文件已备份为: $backup_name"
        return 0
    else
        print_error "文件不存在: $file"
        return 1
    fi
}
```

使用函数库：

```bash
#!/bin/bash

# 导入函数库
source ./utils.sh

# 使用库中的函数
print_info "脚本开始执行"
print_warning "这是一个警告信息"
print_error "这是一个错误信息"

# 记录日志
log_message "INFO" "用户登录系统"

# 备份文件
backup_file "/etc/hosts"
```

## 递归函数

Shell也支持递归函数，即函数调用自身：

```bash
#!/bin/bash

# 计算阶乘的递归函数
factorial() {
    local n=$1
    
    # 基础情况
    if [ $n -le 1 ]
    then
        echo 1
        return
    fi
    
    # 递归情况
    local prev_factorial=$(factorial $((n - 1)))
    echo $((n * prev_factorial))
}

# 计算斐波那契数列的递归函数
fibonacci() {
    local n=$1
    
    # 基础情况
    if [ $n -le 1 ]
    then
        echo $n
        return
    fi
    
    # 递归情况
    local prev1=$(fibonacci $((n - 1)))
    local prev2=$(fibonacci $((n - 2)))
    echo $((prev1 + prev2))
}

# 测试递归函数
echo "5的阶乘是: $(factorial 5)"
echo "斐波那契数列前10项:"
for i in {0..9}
do
    echo -n "$(fibonacci $i) "
done
echo
```

## 实际应用示例

### 系统管理工具函数库

```bash
#!/bin/bash

# 系统管理函数库

# 检查命令是否存在
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# 检查是否以root权限运行
is_root() {
    [ "$EUID" -eq 0 ]
}

# 获取系统信息
get_system_info() {
    echo "=== 系统信息 ==="
    echo "操作系统: $(uname -s)"
    echo "内核版本: $(uname -r)"
    echo "主机名: $(hostname)"
    echo "架构: $(uname -m)"
}

# 检查磁盘使用情况
check_disk_usage() {
    local threshold=${1:-80}  # 默认阈值为80%
    local usage=$(df / | tail -1 | awk '{print $5}' | sed 's/%//')
    
    if [ $usage -gt $threshold ]
    then
        echo "警告: 磁盘使用率过高 (${usage}%)"
        return 1
    else
        echo "磁盘使用率正常 (${usage}%)"
        return 0
    fi
}

# 检查内存使用情况
check_memory_usage() {
    local threshold=${1:-80}
    local usage=$(free | grep Mem | awk '{printf("%.0f", $3/$2 * 100.0)}')
    
    if [ $usage -gt $threshold ]
    then
        echo "警告: 内存使用率过高 (${usage}%)"
        return 1
    else
        echo "内存使用率正常 (${usage}%)"
        return 0
    fi
}

# 创建用户
create_user() {
    local username=$1
    
    if [ -z "$username" ]
    then
        echo "错误: 用户名不能为空"
        return 1
    fi
    
    if id "$username" &>/dev/null
    then
        echo "用户 $username 已存在"
        return 1
    fi
    
    if useradd "$username"
    then
        echo "用户 $username 创建成功"
        return 0
    else
        echo "用户 $username 创建失败"
        return 1
    fi
}

# 备份目录
backup_directory() {
    local source_dir=$1
    local backup_dir=${2:-"/tmp"}
    
    if [ ! -d "$source_dir" ]
    then
        echo "错误: 源目录 $source_dir 不存在"
        return 1
    fi
    
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="$(basename "$source_dir")_${timestamp}.tar.gz"
    local backup_path="${backup_dir}/${backup_name}"
    
    if tar -czf "$backup_path" -C "$(dirname "$source_dir")" "$(basename "$source_dir")"
    then
        echo "目录 $source_dir 已备份到 $backup_path"
        return 0
    else
        echo "备份失败"
        return 1
    fi
}
```

### 使用函数库的主脚本

```bash
#!/bin/bash

# 导入函数库
source ./system_utils.sh

# 主函数
main() {
    echo "系统管理工具"
    echo "============"
    
    # 检查是否以root权限运行
    if ! is_root
    then
        echo "警告: 此脚本需要root权限运行"
        # 可以选择退出或继续执行有限功能
    fi
    
    # 显示系统信息
    get_system_info
    
    echo  # 空行
    
    # 检查系统资源使用情况
    check_disk_usage
    check_memory_usage
    
    echo  # 空行
    
    # 演示其他功能
    echo "演示备份功能:"
    backup_directory "/etc" "/tmp"
}

# 调用主函数
main "$@"
```

## 高级函数技巧

### 函数别名

```bash
#!/bin/bash

# 创建函数别名
alias ll='ls -alF'
alias ..='cd ..'

# 或者创建函数实现类似功能
ll() {
    ls -alF "$@"
}

up() {
    cd .. && pwd
}

mkcd() {
    mkdir -p "$1" && cd "$1"
}
```

### 匿名函数（子Shell）

```bash
#!/bin/bash

# 使用括号创建子Shell执行临时任务
(result=0
 for i in {1..5}
 do
     result=$((result + i))
 done
 echo "子Shell中的计算结果: $result"
)
# 子Shell中的变量在外部不可访问

# 使用大括号分组命令（在同一Shell中执行）
{ 
    var1="hello"
    var2="world"
    echo "$var1 $var2"
}
# 大括号中的变量在外部可访问
echo "大括号外: $var1 $var2"
```

## 最佳实践

1. **使用局部变量**：在函数中尽量使用local关键字声明局部变量
2. **函数命名规范**：使用有意义的函数名，推荐使用小写字母和下划线
3. **参数验证**：在函数开始处验证参数的有效性
4. **返回适当的退出码**：成功返回0，失败返回非0值
5. **函数文档**：为复杂函数添加注释说明功能和参数
6. **模块化设计**：将相关函数组织在单独的文件中
7. **避免全局变量污染**：尽量减少全局变量的使用

## 总结

函数是Shell脚本编程中实现代码重用和模块化的重要机制。通过本章的学习，你应该掌握了：

1. 函数的定义和调用方法
2. 函数参数的处理
3. 函数返回值的使用
4. 局部变量和全局变量的区别
5. 函数库的创建和使用
6. 递归函数的实现
7. 实际应用示例

函数使你的Shell脚本更加结构化和易于维护。在下一章中，我们将学习数组的使用，进一步增强脚本的数据处理能力。