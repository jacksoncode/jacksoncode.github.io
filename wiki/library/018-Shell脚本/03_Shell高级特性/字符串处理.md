# 字符串处理

## Shell中的字符串

字符串是Shell脚本中最常用的数据类型之一。在Shell中，字符串可以包含任意字符，包括字母、数字、特殊符号和空格。正确处理字符串对于编写高效的Shell脚本至关重要。

## 字符串的基本操作

### 字符串的定义和赋值

```bash
#!/bin/bash

# 定义字符串的不同方式
str1="Hello World"           # 双引号
str2='Hello World'           # 单引号
str3=Hello\ World            # 转义空格
str4="Hello $USER"           # 包含变量（双引号中会展开）
str5='Hello $USER'           # 包含变量（单引号中不会展开）

echo "str1: $str1"
echo "str2: $str2"
echo "str3: $str3"
echo "str4: $str4"
echo "str5: $str5"
```

### 字符串的拼接

```bash
#!/bin/bash

first_name="张"
last_name="三"
full_name="${first_name}${last_name}"

echo "全名: $full_name"

# 使用+=操作符
greeting="Hello"
greeting+=" World"
echo "问候语: $greeting"

# 在循环中拼接字符串
result=""
for i in {1..5}
do
    result+="$i "
done
echo "结果: $result"
```

### 获取字符串长度

```bash
#!/bin/bash

text="Hello World"
echo "字符串: $text"
echo "长度: ${#text}"

# 空字符串
empty=""
echo "空字符串长度: ${#empty}"

# 包含特殊字符的字符串
special="Hello 世界"
echo "包含中文的字符串: $special"
echo "长度: ${#special}"
```

## 字符串的截取和切片

### 基本截取语法

```bash
#!/bin/bash

text="Hello World Programming"

# 从指定位置开始截取到末尾
echo "从位置6开始: ${text:6}"

# 从指定位置开始截取指定长度
echo "从位置6开始截取5个字符: ${text:6:5}"

# 从末尾开始截取（负数索引）
echo "最后7个字符: ${text: -7}"

# 注意负数索引前需要有空格
echo "最后7个字符（另一种写法）: ${text:(-7)}"

# 截取中间部分
echo "第7到第11个字符: ${text:6:5}"
```

### 实际应用示例

```bash
#!/bin/bash

# 文件路径处理
filepath="/home/user/documents/script.sh"

echo "完整路径: $filepath"
echo "目录部分: ${filepath%/*}"
echo "文件名: ${filepath##*/}"
echo "文件名（不含扩展名）: ${filepath##*/}"
echo "文件名（不含扩展名）: ${filepath%.*}"
echo "扩展名: ${filepath##*.}"

# URL处理
url="https://www.example.com:8080/path/to/resource?param=value#section"

echo "完整URL: $url"
echo "协议: ${url%%:*}"
echo "域名: ${url#*//}"
echo "域名部分: ${url#*//}"
echo "域名（不含端口）: ${url#*//}"
echo "域名（不含端口）: ${url#*//}"
echo "域名（不含端口）: ${url#*//}"
domain_with_port="${url#*//}"
echo "域名（不含端口）: ${domain_with_port%%/*}"
```

## 字符串的替换和删除

### 字符串替换

```bash
#!/bin/bash

text="Hello World Hello Universe"

# 替换第一个匹配项
echo "替换第一个Hello: ${text/Hello/Hi}"

# 替换所有匹配项
echo "替换所有Hello: ${text//Hello/Hi}"

# 使用变量替换
old="World"
new="Shell"
echo "使用变量替换: ${text/$old/$new}"

# 删除匹配项（替换为空）
echo "删除第一个Hello: ${text/Hello/}"
echo "删除所有Hello: ${text//Hello/}"

# 前缀和后缀匹配替换
filename="document.pdf.backup"

# 删除最短匹配的后缀
echo "删除后缀: ${filename%.*}"

# 删除最长匹配的后缀
echo "删除所有后缀: ${filename%%.*}"

# 删除最短匹配的前缀
echo "删除前缀: ${filename#*.}"

# 删除最长匹配的前缀
echo "删除所有前缀: ${filename##*.}"
```

### 使用正则表达式替换

```bash
#!/bin/bash

text="联系电话: 138-1234-5678"

# 使用正则表达式替换
echo "原始文本: $text"
echo "隐藏中间数字: ${text/[0-9]{4}/****}"

# 更复杂的替换
phone="138-1234-5678"
# 使用sed进行复杂替换
echo "使用sed隐藏手机号: $(echo $phone | sed 's/\([0-9]\{3\}\)-[0-9]\{4\}-[0-9]\{4\}/\1-****-****/')"
```

## 字符串的模式匹配

### 通配符匹配

```bash
#!/bin/bash

filename="document_v1.2.3_final.txt"

# 检查文件名是否匹配模式
case $filename in
    *.txt)
        echo "这是一个文本文件"
        ;;
    *.pdf)
        echo "这是一个PDF文件"
        ;;
    *)
        echo "未知文件类型"
        ;;
esac

# 使用通配符检查
if [[ $filename == *.txt ]]
then
    echo "文件名以.txt结尾"
fi

if [[ $filename == document* ]]
then
    echo "文件名以document开头"
fi

if [[ $filename == *v[0-9]* ]]
then
    echo "文件名包含版本号"
fi
```

### 正则表达式匹配

```bash
#!/bin/bash

email="user@example.com"

# 使用正则表达式验证邮箱格式
if [[ $email =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]
then
    echo "邮箱格式正确: $email"
else
    echo "邮箱格式错误: $email"
fi

# 提取邮箱各部分
if [[ $email =~ ^([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})$ ]]
then
    username=${BASH_REMATCH[1]}
    domain=${BASH_REMATCH[2]}
    echo "用户名: $username"
    echo "域名: $domain"
fi

# IP地址验证
ip="192.168.1.100"

if [[ $ip =~ ^([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$ ]]
then
    # 检查每个数字是否在0-255范围内
    valid=true
    for i in {1..4}
    do
        if [ ${BASH_REMATCH[$i]} -gt 255 ]
        then
            valid=false
            break
        fi
    done
    
    if [ "$valid" = true ]
    then
        echo "IP地址格式正确: $ip"
    else
        echo "IP地址格式错误: $ip"
    fi
else
    echo "IP地址格式错误: $ip"
fi
```

## 字符串的大小写转换

```bash
#!/bin/bash

text="Hello World"

# 转换为小写
echo "小写: ${text,,}"

# 转换为大写
echo "大写: ${text^^}"

# 首字母大写
echo "首字母大写: ${text^}"

# 首字母小写
echo "首字母小写: ${text,}"

# 混合转换示例
name="john DOE"
echo "名字标准化: ${name^,}"

# 使用tr命令进行大小写转换
echo "使用tr转换为大写: $(echo $text | tr '[:lower:]' '[:upper:]')"
echo "使用tr转换为小写: $(echo $text | tr '[:upper:]' '[:lower:]')"
```

## 字符串处理的实际应用

### 日志分析脚本

```bash
#!/bin/bash

# 模拟日志数据
cat > access.log << EOF
192.168.1.100 - - [01/Jan/2023:10:00:01 +0000] "GET /index.html HTTP/1.1" 200 1234
192.168.1.101 - - [01/Jan/2023:10:00:02 +0000] "POST /login HTTP/1.1" 200 567
192.168.1.102 - - [01/Jan/2023:10:00:03 +0000] "GET /style.css HTTP/1.1" 404 0
192.168.1.100 - - [01/Jan/2023:10:00:04 +0000] "GET /script.js HTTP/1.1" 200 890
192.168.1.103 - - [01/Jan/2023:10:00:05 +0000] "GET /index.html HTTP/1.1" 200 1234
EOF

# 分析日志
analyze_log() {
    local log_file=$1
    local -A ip_count
    local -A status_count
    local total_requests=0
    
    while IFS= read -r line
    do
        # 提取IP地址
        ip=$(echo "$line" | cut -d' ' -f1)
        
        # 提取状态码
        status=$(echo "$line" | sed -n 's/.*HTTP\/1\.1" \([0-9]*\) .*/\1/p')
        
        # 统计
        ip_count[$ip]=$((${ip_count[$ip]:-0} + 1))
        status_count[$status]=$((${status_count[$status]:-0} + 1))
        total_requests=$((total_requests + 1))
    done < "$log_file"
    
    # 输出结果
    echo "=== 日志分析报告 ==="
    echo "总请求数: $total_requests"
    echo
    
    echo "IP访问统计:"
    for ip in "${!ip_count[@]}"
    do
        echo "  $ip: ${ip_count[$ip]} 次"
    done
    echo
    
    echo "状态码统计:"
    for status in "${!status_count[@]}"
    do
        echo "  $status: ${status_count[$status]} 次"
    done
}

# 运行分析
analyze_log "access.log"
```

### 配置文件处理器

```bash
#!/bin/bash

# 配置文件处理函数
process_config() {
    local config_file=$1
    local -A config
    
    # 读取配置文件
    while IFS='=' read -r key value
    do
        # 跳过空行和注释
        [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]] && continue
        
        # 去除前后空格
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs)
        
        # 存储配置
        config["$key"]="$value"
    done < "$config_file"
    
    # 处理特定配置项
    echo "处理配置项:"
    for key in "${!config[@]}"
    do
        value="${config[$key]}"
        echo "  $key = $value"
        
        # 根据配置项进行处理
        case $key in
            "debug")
                if [[ $value =~ ^(true|1|yes)$ ]]
                then
                    echo "    [处理] 启用调试模式"
                else
                    echo "    [处理] 禁用调试模式"
                fi
                ;;
            "max_connections")
                if [[ $value =~ ^[0-9]+$ ]] && [ $value -gt 0 ]
                then
                    echo "    [处理] 设置最大连接数为 $value"
                else
                    echo "    [警告] 无效的最大连接数: $value"
                fi
                ;;
            "log_level")
                case $value in
                    "DEBUG"|"INFO"|"WARN"|"ERROR")
                        echo "    [处理] 设置日志级别为 $value"
                        ;;
                    *)
                        echo "    [警告] 无效的日志级别: $value"
                        ;;
                esac
                ;;
        esac
    done
}

# 创建示例配置文件
cat > app.conf << EOF
# 应用配置文件
app_name = MyApplication
version = 1.0.0
debug = true
max_connections = 100
log_level = INFO
# 数据库配置
db_host = localhost
db_port = 3306
db_name = myapp
EOF

# 处理配置文件
process_config "app.conf"
```

### 文本格式化工具

```bash
#!/bin/bash

# 文本格式化函数
format_text() {
    local text="$1"
    local format_type="$2"
    
    case $format_type in
        "upper")
            echo "${text^^}"
            ;;
        "lower")
            echo "${text,,}"
            ;;
        "title")
            # 首字母大写
            echo "${text^}"
            ;;
        "reverse")
            # 反转字符串
            echo "$text" | rev
            ;;
        "camel")
            # 转换为驼峰命名
            echo "$text" | sed 's/[^a-zA-Z0-9]*\([a-zA-Z0-9]\)/\U\1/g' | sed 's/./\L&/'
            ;;
        "snake")
            # 转换为蛇形命名
            echo "$text" | sed 's/\([A-Z]\)/_\L\1/g' | sed 's/^_//' | tr ' ' '_'
            ;;
        *)
            echo "$text"
            ;;
    esac
}

# 测试格式化函数
test_text="hello world example"

echo "原始文本: $test_text"
echo "大写: $(format_text "$test_text" upper)"
echo "小写: $(format_text "$test_text" lower)"
echo "首字母大写: $(format_text "$test_text" title)"
echo "反转: $(format_text "$test_text" reverse)"
echo "驼峰命名: $(format_text "$test_text" camel)"
echo "蛇形命名: $(format_text "$test_text" snake)"
```

## 高级字符串处理技巧

### 使用外部工具

```bash
#!/bin/bash

text="Hello, World! This is a test string."

# 使用awk处理字符串
echo "单词数: $(echo "$text" | awk '{print NF}')"
echo "字符数: $(echo "$text" | awk '{print length}')"

# 使用sed进行复杂替换
echo "删除标点符号: $(echo "$text" | sed 's/[[:punct:]]//g')"

# 使用grep查找模式
echo "包含'test'的行: $(echo "$text" | grep -o 'test')"

# 使用cut提取字段
csv_line="John,Doe,25,Engineer"
echo "姓氏: $(echo "$csv_line" | cut -d',' -f2)"
echo "年龄: $(echo "$csv_line" | cut -d',' -f3)"
```

### 多行字符串处理

```bash
#!/bin/bash

# 处理多行字符串
multiline_text="第一行文本
第二行文本
第三行文本
包含特殊字符的行: \$HOME = $HOME"

# 逐行处理
echo "逐行处理:"
while IFS= read -r line
do
    echo "  处理行: $line"
done <<< "$multiline_text"

# 使用Here文档
process_multiline() {
    local input="$1"
    local line_num=1
    
    while IFS= read -r line
    do
        echo "行 $line_num: $line"
        line_num=$((line_num + 1))
    done <<< "$input"
}

echo "使用函数处理多行文本:"
process_multiline "$multiline_text"
```

## 最佳实践

1. **使用花括号包围变量**：如`${variable}`而不是`$variable`，特别是在字符串拼接时
2. **合理使用引号**：双引号允许变量展开，单引号保持字面值
3. **注意特殊字符转义**：特别是空格、美元符号等
4. **利用参数扩展**：Shell的参数扩展功能强大，优先使用内置功能
5. **验证字符串输入**：对用户输入或外部数据进行验证
6. **处理边界情况**：考虑空字符串、特殊字符等情况
7. **使用适当工具**：复杂文本处理时考虑使用awk、sed等工具

## 总结

字符串处理是Shell脚本编程的核心技能之一。通过本章的学习，你应该掌握了：

1. 字符串的基本操作（定义、拼接、长度获取）
2. 字符串的截取和切片技术
3. 字符串的替换和删除操作
4. 模式匹配和正则表达式使用
5. 大小写转换方法
6. 实际应用场景（日志分析、配置处理等）
7. 高级处理技巧和外部工具使用

掌握这些字符串处理技能将大大提高你编写Shell脚本的能力。在下一章中，我们将学习文件测试技术，进一步增强脚本的文件操作能力。