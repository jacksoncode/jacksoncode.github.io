# 正则表达式

## 什么是正则表达式

正则表达式（Regular Expression，简称regex或regexp）是一种强大的文本匹配工具，它使用特定的语法来描述字符串的模式。在Shell脚本中，正则表达式广泛应用于文本处理、数据验证、日志分析等场景。

## 正则表达式基础

### 基本字符匹配

```bash
#!/bin/bash

text="Hello World"

# 精确匹配
if [[ $text =~ Hello ]]
then
    echo "找到匹配: Hello"
fi

# 区分大小写匹配
if [[ $text =~ hello ]]
then
    echo "找到匹配: hello"
else
    echo "未找到匹配: hello (区分大小写)"
fi

# 不区分大小写匹配
shopt -s nocasematch
if [[ $text =~ hello ]]
then
    echo "找到匹配: hello (不区分大小写)"
fi
shopt -u nocasematch
```

### 特殊字符和元字符

```bash
#!/bin/bash

# 点号 (.) 匹配任意单个字符
text="cat"
if [[ $text =~ c.t ]]
then
    echo "匹配 c.t: $text"
fi

# 星号 (*) 匹配前一个字符0次或多次
text="caaaat"
if [[ $text =~ ca*t ]]
then
    echo "匹配 ca*t: $text"
fi

# 加号 (+) 匹配前一个字符1次或多次
text="caaat"
if [[ $text =~ ca+t ]]
then
    echo "匹配 ca+t: $text"
fi

# 问号 (?) 匹配前一个字符0次或1次
text="cat"
if [[ $text =~ ca?t ]]
then
    echo "匹配 ca?t: $text"
fi
```

### 字符类

```bash
#!/bin/bash

# 字符类 [abc] 匹配方括号中的任意一个字符
text="bat"
if [[ $text =~ [abc]at ]]
then
    echo "匹配 [abc]at: $text"
fi

# 范围字符类 [a-z] 匹配范围内的任意字符
text="hat"
if [[ $text =~ [a-z]at ]]
then
    echo "匹配 [a-z]at: $text"
fi

# 数字字符类 [0-9] 匹配数字
text="123"
if [[ $text =~ [0-9][0-9][0-9] ]]
then
    echo "匹配 [0-9][0-9][0-9]: $text"
fi

# 否定字符类 [^abc] 匹配不在方括号中的任意字符
text="hat"
if [[ $text =~ [^bc]at ]]
then
    echo "匹配 [^bc]at: $text"
fi
```

### 预定义字符类

```bash
#!/bin/bash

# 使用[:class:]格式的预定义字符类
text="Hello123"

# 匹配字母字符
if [[ $text =~ [[:alpha:]]+ ]]
then
    echo "包含字母字符: $text"
fi

# 匹配数字字符
if [[ $text =~ [[:digit:]]+ ]]
then
    echo "包含数字字符: $text"
fi

# 匹配字母数字字符
if [[ $text =~ [[:alnum:]]+ ]]
then
    echo "包含字母数字字符: $text"
fi

# 匹配空白字符
text="hello world"
if [[ $text =~ [[:space:]]+ ]]
then
    echo "包含空白字符: $text"
fi

# 匹配标点符号
text="Hello, World!"
if [[ $text =~ [[:punct:]]+ ]]
then
    echo "包含标点符号: $text"
fi
```

## 位置锚点

```bash
#!/bin/bash

text="Hello World"

# 行首锚点 ^
if [[ $text =~ ^Hello ]]
then
    echo "以 Hello 开头: $text"
fi

# 行尾锚点 $
if [[ $text =~ World$ ]]
then
    echo "以 World 结尾: $text"
fi

# 单词边界 \< 和 \>
text="The theme is there"
if [[ $text =~ \&lt;the\&gt; ]]
then
    echo "包含独立的 the: $text"
fi
```

## 量词

```bash
#!/bin/bash

# 精确次数 {n}
text="aaabbb"
if [[ $text =~ a{3} ]]
then
    echo "包含3个连续的a: $text"
fi

# 范围次数 {n,m}
text="aaaa"
if [[ $text =~ a{2,4} ]]
then
    echo "包含2到4个连续的a: $text"
fi

# 至少n次 {n,}
text="aaaaaa"
if [[ $text =~ a{3,} ]]
then
    echo "包含至少3个连续的a: $text"
fi
```

## 分组和捕获

```bash
#!/bin/bash

# 使用括号进行分组
text="2023-12-25"
if [[ $text =~ ([0-9]{4})-([0-9]{2})-([0-9]{2}) ]]
then
    echo "年份: ${BASH_REMATCH[1]}"
    echo "月份: ${BASH_REMATCH[2]}"
    echo "日期: ${BASH_REMATCH[3]}"
fi

# 使用或操作符 |
text="cat"
if [[ $text =~ (cat|dog|bird) ]]
then
    echo "动物: ${BASH_REMATCH[1]}"
fi
```

## 正则表达式的实际应用

### 数据验证脚本

```bash
#!/bin/bash

# 邮箱验证函数
validate_email() {
    local email=$1
    local email_regex='^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    
    if [[ $email =~ $email_regex ]]
    then
        echo "邮箱格式正确: $email"
        return 0
    else
        echo "邮箱格式错误: $email"
        return 1
    fi
}

# 电话号码验证函数
validate_phone() {
    local phone=$1
    local phone_regex='^(\+86)?[ -]?1[3-9][0-9][ -]?[0-9]{4}[ -]?[0-9]{4}$'
    
    if [[ $phone =~ $phone_regex ]]
    then
        echo "电话号码格式正确: $phone"
        return 0
    else
        echo "电话号码格式错误: $phone"
        return 1
    fi
}

# IP地址验证函数
validate_ip() {
    local ip=$1
    local ip_regex='^([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$'
    
    if [[ $ip =~ $ip_regex ]]
    then
        # 检查每个数字是否在0-255范围内
        for i in {1..4}
        do
            if [ ${BASH_REMATCH[$i]} -gt 255 ]
            then
                echo "IP地址格式错误: $ip (数值超出范围)"
                return 1
            fi
        done
        echo "IP地址格式正确: $ip"
        return 0
    else
        echo "IP地址格式错误: $ip"
        return 1
    fi
}

# 测试验证函数
echo "=== 数据验证测试 ==="
validate_email "user@example.com"
validate_email "invalid.email"
validate_phone "13812345678"
validate_phone "12345"
validate_ip "192.168.1.1"
validate_ip "256.1.1.1"
```

### 日志分析脚本

```bash
#!/bin/bash

# 创建示例日志文件
cat > web_access.log << EOF
192.168.1.100 - - [01/Jan/2023:10:00:01 +0000] "GET /index.html HTTP/1.1" 200 1234
192.168.1.101 - - [01/Jan/2023:10:00:02 +0000] "POST /login HTTP/1.1" 404 0
192.168.1.102 - - [01/Jan/2023:10:00:03 +0000] "GET /style.css HTTP/1.1" 200 567
192.168.1.103 - - [01/Jan/2023:10:00:04 +0000] "GET /script.js HTTP/1.1" 500 0
192.168.1.104 - - [01/Jan/2023:10:00:05 +0000] "GET /index.html HTTP/1.1" 200 1234
EOF

# 日志分析函数
analyze_logs() {
    local log_file=$1
    local -A ip_count
    local -A status_count
    local -A url_count
    local total_requests=0
    
    # Apache/Nginx访问日志的正则表达式
    local log_regex='^([0-9.]+) - - \[([^]]+)\] "([^"]+)" ([0-9]+) ([0-9]+)$'
    
    while IFS= read -r line
    do
        if [[ $line =~ $log_regex ]]
        then
            local ip=${BASH_REMATCH[1]}
            local timestamp=${BASH_REMATCH[2]}
            local request=${BASH_REMATCH[3]}
            local status=${BASH_REMATCH[4]}
            local size=${BASH_REMATCH[5]}
            
            # 统计IP访问次数
            ip_count[$ip]=$((${ip_count[$ip]:-0} + 1))
            
            # 统计状态码
            status_count[$status]=$((${status_count[$status]:-0} + 1))
            
            # 统计URL访问次数
            # 从请求中提取URL
            if [[ $request =~ [A-Z]+[[:space:]]+([^[:space:]]+) ]]
            then
                local url=${BASH_REMATCH[1]}
                url_count[$url]=$((${url_count[$url]:-0} + 1))
            fi
            
            total_requests=$((total_requests + 1))
        fi
    done < "$log_file"
    
    # 输出分析结果
    echo "=== Web访问日志分析报告 ==="
    echo "总请求数: $total_requests"
    echo
    
    echo "IP访问统计 (前5名):"
    for ip in $(for i in "${!ip_count[@]}"; do echo "$i ${ip_count[$i]}"; done | sort -rn -k2 | head -5 | cut -d' ' -f1)
    do
        echo "  $ip: ${ip_count[$ip]} 次"
    done
    echo
    
    echo "状态码统计:"
    for status in "${!status_count[@]}"
    do
        echo "  $status: ${status_count[$status]} 次"
    done
    echo
    
    echo "URL访问统计 (前5名):"
    for url in $(for u in "${!url_count[@]}"; do echo "$u ${url_count[$u]}"; done | sort -rn -k2 | head -5 | cut -d' ' -f1)
    do
        echo "  $url: ${url_count[$url]} 次"
    done
}

# 运行日志分析
analyze_logs "web_access.log"

# 清理测试文件
rm web_access.log
```

### 配置文件处理脚本

```bash
#!/bin/bash

# 创建示例配置文件
cat > app_config.conf << EOF
# 应用配置文件
APP_NAME = MyApplication
VERSION = 1.0.0
DEBUG = true
MAX_CONNECTIONS = 100
LOG_LEVEL = INFO
DATABASE_HOST = localhost
DATABASE_PORT = 3306
DATABASE_NAME = myapp
# 注释行
CACHE_ENABLED = false
CACHE_TTL = 3600
EOF

# 配置文件解析函数
parse_config() {
    local config_file=$1
    local -A config
    
    # 配置行的正则表达式（忽略注释和空行）
    local config_regex='^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*=[[:space:]]*(.*)[[:space:]]*$'
    
    while IFS= read -r line
    do
        # 跳过注释和空行
        if [[ $line =~ ^[[:space:]]*# ]] || [[ $line =~ ^[[:space:]]*$ ]]
        then
            continue
        fi
        
        # 匹配配置行
        if [[ $line =~ $config_regex ]]
        then
            local key=${BASH_REMATCH[1]}
            local value=${BASH_REMATCH[2]}
            
            # 去除值两端的空格和引号
            value=$(echo "$value" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//")
            
            # 存储配置
            config["$key"]="$value"
        fi
    done < "$config_file"
    
    # 输出解析结果
    echo "=== 配置文件解析结果 ==="
    for key in "${!config[@]}"
    do
        echo "$key = ${config[$key]}"
        
        # 根据配置类型进行处理
        case $key in
            DEBUG|CACHE_ENABLED)
                if [[ ${config[$key]} =~ ^(true|false|yes|no|1|0)$ ]]
                then
                    echo "  [验证] 布尔值格式正确"
                else
                    echo "  [警告] 布尔值格式可能不正确: ${config[$key]}"
                fi
                ;;
            MAX_CONNECTIONS|DATABASE_PORT|CACHE_TTL)
                if [[ ${config[$key]} =~ ^[0-9]+$ ]]
                then
                    echo "  [验证] 数字格式正确"
                else
                    echo "  [警告] 数字格式不正确: ${config[$key]}"
                fi
                ;;
        esac
    done
}

# 运行配置解析
parse_config "app_config.conf"

# 清理测试文件
rm app_config.conf
```

## 高级正则表达式技巧

### 非贪婪匹配

```bash
#!/bin/bash

# 在某些工具中使用非贪婪匹配
text="<div>Hello</div><div>World</div>"

# 使用sed进行非贪婪匹配（如果支持）
echo "$text" | sed 's/<div>.*?<\/div>/[REPLACED]/g'
```

### 正向和负向查找

```bash
#!/bin/bash

# 这些在bash中支持有限，但在其他工具中很有用
# (?=pattern) 正向先行查找
# (?!pattern) 负向先行查找
# (?<=pattern) 正向后行查找
# (?<!pattern) 负向后行查找
```

### 使用外部工具处理复杂正则表达式

```bash
#!/bin/bash

text="联系邮箱: user@example.com, 备用邮箱: backup@test.org"

# 使用grep查找邮箱
echo "使用grep查找邮箱:"
echo "$text" | grep -oE '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'

# 使用sed替换邮箱
echo "使用sed隐藏邮箱:"
echo "$text" | sed 's/[a-zA-Z0-9._%+-]*@[a-zA-Z0-9.-]*\.[a-zA-Z]\{2,\}/**EMAIL**/g'

# 使用awk处理复杂模式
echo "使用awk提取邮箱:"
echo "$text" | awk '{
    while(match($0, /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/)) {
        print substr($0, RSTART, RLENGTH)
        $0 = substr($0, RSTART + RLENGTH)
    }
}'
```

## 正则表达式最佳实践

### 性能优化

```bash
#!/bin/bash

# 1. 尽量具体化模式，避免过于宽泛的匹配
# 不好的例子: .*
# 好的例子: [a-zA-Z]+

# 2. 使用锚点提高匹配效率
# 好的例子: ^[0-9]{4}-[0-9]{2}-[0-9]{2}$

# 3. 避免回溯灾难
# 不好的例子: (a+)+b 匹配 aaaaaaaaaaaaaaab
# 好的例子: a+b

# 4. 预编译复杂正则表达式（在支持的语言中）
```

### 安全考虑

```bash
#!/bin/bash

# 1. 验证用户输入
validate_user_input() {
    local input=$1
    # 避免特殊字符注入
    if [[ $input =~ [;\|\&\`\$\(\)] ]]
    then
        echo "输入包含危险字符"
        return 1
    fi
    return 0
}

# 2. 转义特殊字符
escape_regex() {
    local string=$1
    echo "$string" | sed 's/[]\/$*.^|()+{}[]/\\&/g'
}
```

## 常用正则表达式模式

```bash
#!/bin/bash

# 常用正则表达式模式集合
declare -A regex_patterns

regex_patterns[EMAIL]='^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
regex_patterns[PHONE]='^(\+86)?[ -]?1[3-9][0-9][ -]?[0-9]{4}[ -]?[0-9]{4}$'
regex_patterns[DATE]='^[0-9]{4}-[0-9]{2}-[0-9]{2}$'
regex_patterns[TIME]='^[0-9]{2}:[0-9]{2}:[0-9]{2}$'
regex_patterns[IP]='^([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$'
regex_patterns[URL]='^https?://[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(/.*)?$'
regex_patterns[HEX_COLOR]='^#[0-9a-fA-F]{6}$'
regex_patterns[UUID]='^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$'

# 测试函数
test_pattern() {
    local pattern_name=$1
    local test_string=$2
    local pattern=${regex_patterns[$pattern_name]}
    
    if [[ $test_string =~ $pattern ]]
    then
        echo "✓ $pattern_name 匹配: $test_string"
    else
        echo "✗ $pattern_name 不匹配: $test_string"
    fi
}

# 测试常用模式
echo "=== 常用正则表达式测试 ==="
test_pattern "EMAIL" "user@example.com"
test_pattern "PHONE" "13812345678"
test_pattern "DATE" "2023-12-25"
test_pattern "IP" "192.168.1.1"
test_pattern "URL" "https://www.example.com"
```

## 总结

正则表达式是Shell脚本中处理文本的强大工具。通过本章的学习，你应该掌握了：

1. 正则表达式的基本语法和元字符
2. 字符类和预定义字符类的使用
3. 位置锚点和量词的应用
4. 分组和捕获功能
5. 实际应用场景（数据验证、日志分析、配置处理等）
6. 高级技巧和最佳实践

掌握正则表达式将大大提高你处理文本数据的能力。虽然Bash对正则表达式的支持相对有限，但结合外部工具如sed、awk、grep等，可以实现非常强大的文本处理功能。

在Shell脚本编程中，合理使用正则表达式可以让你的脚本更加智能和高效。