# 数组

## 什么是数组

数组是一种数据结构，用于存储一系列相关的数据项。在Shell脚本中，数组可以存储多个值，并通过索引访问这些值。数组是处理批量数据的有效工具，特别适合处理列表、集合等数据结构。

## 数组的定义

在Bash中，有多种方式定义数组：

### 1. 直接赋值定义

```bash
# 定义空数组
arr=()

# 定义包含元素的数组
fruits=("苹果" "香蕉" "橙子")

# 定义数字数组
numbers=(1 2 3 4 5)

# 定义混合类型数组
mixed=("字符串" 123 "another string" 45.6)
```

### 2. 逐个赋值定义

```bash
# 通过索引赋值
colors[0]="红色"
colors[1]="绿色"
colors[2]="蓝色"

# 也可以不按顺序赋值
animals[0]="猫"
animals[2]="狗"
animals[5]="鸟"
```

### 3. 使用declare命令定义

```bash
# 显式声明数组
declare -a my_array

# 声明并初始化
declare -a weekdays=("周一" "周二" "周三" "周四" "周五")
```

## 数组的访问

### 访问单个元素

```bash
#!/bin/bash

# 定义数组
fruits=("苹果" "香蕉" "橙子" "葡萄" "草莓")

# 访问数组元素（索引从0开始）
echo "第一个水果: ${fruits[0]}"
echo "第三个水果: ${fruits[2]}"

# 使用变量作为索引
index=1
echo "索引为$index的水果: ${fruits[$index]}"

# 访问不存在的索引（返回空值）
echo "不存在的索引: '${fruits[10]}'"
```

### 访问所有元素

```bash
#!/bin/bash

numbers=(10 20 30 40 50)

# 访问所有元素
echo "所有数字: ${numbers[@]}"

# 另一种方式
echo "所有数字: ${numbers[*]}"

# 注意 @ 和 * 的区别
echo "使用@的引号: '${numbers[@]}'"
echo "使用*的引号: '${numbers[*]}'"

# 在循环中访问所有元素
echo "逐个输出:"
for num in "${numbers[@]}"
do
    echo "  数字: $num"
done
```

### 获取数组信息

```bash
#!/bin/bash

data=("a" "b" "c" "d" "e")

# 获取数组长度
echo "数组长度: ${#data[@]}"
echo "数组长度（另一种方式）: ${#data[*]}"

# 获取单个元素的长度
echo "第一个元素的长度: ${#data[0]}"

# 获取数组所有索引
echo "所有索引: ${!data[@]}"

# 检查数组是否为空
if [ ${#data[@]} -eq 0 ]
then
    echo "数组为空"
else
    echo "数组不为空，包含 ${#data[@]} 个元素"
fi
```

## 数组的操作

### 添加元素

```bash
#!/bin/bash

# 初始化数组
colors=("红色" "绿色")

# 在末尾添加元素
colors+=("蓝色")
echo "添加后: ${colors[@]}"

# 添加多个元素
colors+=("黄色" "紫色")
echo "添加多个后: ${colors[@]}"

# 在指定位置插入元素（需要重新构建数组）
colors=("${colors[@]:0:2}" "橙色" "${colors[@]:2}")
echo "插入后: ${colors[@]}"
```

### 修改元素

```bash
#!/bin/bash

fruits=("苹果" "香蕉" "橙子")

# 修改指定索引的元素
fruits[1]="梨"
echo "修改后: ${fruits[@]}"

# 批量修改
fruits=("${fruits[@]/苹果/桃子}")  # 替换所有"苹果"为"桃子"
echo "批量修改后: ${fruits[@]}"
```

### 删除元素

```bash
#!/bin/bash

numbers=(1 2 3 4 5)

# 删除指定索引的元素
unset numbers[2]
echo "删除索引2后: ${numbers[@]}"
echo "删除后的索引: ${!numbers[@]}"

# 重新构建连续索引的数组
numbers=("${numbers[@]}")
echo "重新构建后: ${numbers[@]}"
echo "新索引: ${!numbers[@]}"

# 删除整个数组
unset numbers
# echo "删除后: ${numbers[@]}"  # 这会报错
```

## 数组切片

```bash
#!/bin/bash

letters=("a" "b" "c" "d" "e" "f" "g")

# 获取子数组（从索引2开始的3个元素）
sub_array=("${letters[@]:2:3}")
echo "子数组: ${sub_array[@]}"

# 从索引3开始到末尾的所有元素
sub_array=("${letters[@]:3}")
echo "从索引3开始: ${sub_array[@]}"

# 获取最后3个元素
sub_array=("${letters[@]: -3}")
echo "最后3个元素: ${sub_array[@]}"

# 注意负数索引前需要有空格
```

## 关联数组

关联数组使用字符串作为键，而不是数字索引。需要使用`declare -A`声明：

```bash
#!/bin/bash

# 声明关联数组
declare -A person

# 赋值
person[name]="张三"
person[age]=25
person[city]="北京"

# 访问元素
echo "姓名: ${person[name]}"
echo "年龄: ${person[age]}"
echo "城市: ${person[city]}"

# 获取所有键
echo "所有键: ${!person[@]}"

# 获取所有值
echo "所有值: ${person[@]}"

# 获取键的数量
echo "键的数量: ${#person[@]}"

# 遍历关联数组
for key in "${!person[@]}"
do
    echo "$key: ${person[$key]}"
done
```

## 数组的实际应用示例

### 文件处理示例

```bash
#!/bin/bash

# 收集目录中的文件信息
collect_files() {
    local directory=${1:-.}
    local -a files
    local -a sizes
    local -a types
    
    # 检查目录是否存在
    if [ ! -d "$directory" ]
    then
        echo "错误: 目录 $directory 不存在"
        return 1
    fi
    
    # 收集文件信息
    local index=0
    for file in "$directory"/*
    do
        # 检查是否为普通文件
        if [ -f "$file" ]
        then
            files[$index]=$(basename "$file")
            sizes[$index]=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
            types[$index]=$(file -b "$file")
            index=$((index + 1))
        fi
    done
    
    # 显示结果
    echo "目录 $directory 中的文件:"
    echo "========================"
    for i in "${!files[@]}"
    do
        printf "%-20s %10s bytes %s\n" "${files[$i]}" "${sizes[$i]}" "${types[$i]}"
    done
}

# 调用函数
collect_files "/etc"
```

### 用户管理系统示例

```bash
#!/bin/bash

# 用户管理系统示例
declare -a users
declare -a user_ages
declare -a user_emails

# 添加用户
add_user() {
    local name=$1
    local age=$2
    local email=$3
    
    # 检查参数
    if [ -z "$name" ] || [ -z "$age" ] || [ -z "$email" ]
    then
        echo "错误: 所有字段都必须填写"
        return 1
    fi
    
    # 检查用户是否已存在
    for user in "${users[@]}"
    do
        if [ "$user" = "$name" ]
        then
            echo "错误: 用户 $name 已存在"
            return 1
        fi
    done
    
    # 添加用户信息
    local index=${#users[@]}
    users[$index]=$name
    user_ages[$index]=$age
    user_emails[$index]=$email
    
    echo "用户 $name 添加成功"
}

# 查找用户
find_user() {
    local name=$1
    local found=false
    
    for i in "${!users[@]}"
    do
        if [ "${users[$i]}" = "$name" ]
        then
            echo "用户信息:"
            echo "  姓名: ${users[$i]}"
            echo "  年龄: ${user_ages[$i]}"
            echo "  邮箱: ${user_emails[$i]}"
            found=true
            break
        fi
    done
    
    if [ "$found" = false ]
    then
        echo "用户 $name 不存在"
        return 1
    fi
}

# 列出所有用户
list_users() {
    if [ ${#users[@]} -eq 0 ]
    then
        echo "没有用户数据"
        return
    fi
    
    echo "用户列表:"
    echo "========"
    for i in "${!users[@]}"
    do
        echo "$((i+1)). ${users[$i]} (${user_ages[$i]}岁) - ${user_emails[$i]}"
    done
}

# 删除用户
delete_user() {
    local name=$1
    local found=false
    
    for i in "${!users[@]}"
    do
        if [ "${users[$i]}" = "$name" ]
        then
            unset users[$i]
            unset user_ages[$i]
            unset user_emails[$i]
            
            # 重新索引数组
            users=("${users[@]}")
            user_ages=("${user_ages[@]}")
            user_emails=("${user_emails[@]}")
            
            echo "用户 $name 已删除"
            found=true
            break
        fi
    done
    
    if [ "$found" = false ]
    then
        echo "用户 $name 不存在"
        return 1
    fi
}

# 演示使用
echo "=== 用户管理系统演示 ==="
add_user "张三" 25 "zhangsan@example.com"
add_user "李四" 30 "lisi@example.com"
add_user "王五" 28 "wangwu@example.com"

list_users

echo
find_user "李四"

echo
delete_user "李四"

echo
list_users
```

### 配置文件解析示例

```bash
#!/bin/bash

# 解析简单的键值对配置文件
parse_config() {
    local config_file=$1
    declare -A config
    
    # 检查文件是否存在
    if [ ! -f "$config_file" ]
    then
        echo "配置文件 $config_file 不存在"
        return 1
    fi
    
    # 逐行读取配置文件
    while IFS='=' read -r key value
    do
        # 跳过空行和注释行
        [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]] && continue
        
        # 去除键和值的前后空格
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs)
        
        # 存储配置项
        config["$key"]="$value"
    done < "$config_file"
    
    # 返回关联数组（通过全局变量）
    CONFIG_ARRAY=config
}

# 创建示例配置文件
cat > app.conf << EOF
# 应用配置文件
app_name=MyApplication
version=1.0.0
debug=true
max_connections=100
log_level=INFO
# 数据库配置
db_host=localhost
db_port=3306
db_name=myapp
EOF

# 解析配置文件
parse_config "app.conf"

# 显示配置
echo "配置信息:"
echo "========"
for key in "${!config[@]}"
do
    echo "$key = ${config[$key]}"
done

# 获取特定配置值
echo
echo "应用名称: ${config[app_name]}"
echo "数据库主机: ${config[db_host]}"
echo "最大连接数: ${config[max_connections]}"
```

## 数组与函数

数组可以作为函数参数传递和返回：

```bash
#!/bin/bash

# 接收数组作为参数的函数
process_array() {
    local -a arr=("$@")
    
    echo "接收到的数组元素:"
    for element in "${arr[@]}"
    do
        echo "  $element"
    done
    
    echo "数组长度: ${#arr[@]}"
}

# 返回数组的函数
get_weekdays() {
    echo "周一" "周二" "周三" "周四" "周五" "周六" "周日"
}

# 使用示例
numbers=(1 2 3 4 5)
process_array "${numbers[@]}"

echo
weekdays=($(get_weekdays))
echo "星期数组: ${weekdays[@]}"

# 数组排序函数
sort_array() {
    local -a arr=("$@")
    # 使用printf和sort进行排序
    printf '%s\n' "${arr[@]}" | sort
}

# 测试排序
unsorted=(zebra apple monkey banana)
echo "排序前: ${unsorted[@]}"
sorted=($(sort_array "${unsorted[@]}"))
echo "排序后: ${sorted[@]}"
```

## 最佳实践

1. **使用引号保护数组元素**：访问数组时使用`"${array[@]}"`格式
2. **明确数组类型**：普通数组使用数字索引，关联数组使用字符串键
3. **检查数组边界**：访问数组元素前检查索引是否有效
4. **使用局部数组**：在函数中使用local声明局部数组
5. **合理命名**：使用有意义的数组名和变量名
6. **初始化数组**：明确定义空数组`array=()`而不是未声明的变量
7. **处理稀疏数组**：注意数组索引可能不连续的情况

## 总结

数组是Shell脚本中处理批量数据的重要工具。通过本章的学习，你应该掌握了：

1. 数组的定义和初始化方法
2. 数组元素的访问和修改
3. 数组的基本操作（添加、删除、切片等）
4. 关联数组的使用
5. 数组在实际应用中的使用示例
6. 数组与函数的结合使用

数组使你的Shell脚本能够更有效地处理复杂的数据结构。在下一章中，我们将学习字符串处理技术，进一步增强脚本的文本处理能力。